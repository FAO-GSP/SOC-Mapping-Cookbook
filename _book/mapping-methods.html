<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Soil Organic Carbon Mapping cookbook</title>
  <meta name="description" content="The soilll cookbook.">
  <meta name="generator" content="bookdown 0.5.15 and GitBook 2.6.7">

  <meta property="og:title" content="Soil Organic Carbon Mapping cookbook" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="images/cover.png" />
  <meta property="og:description" content="The soilll cookbook." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Soil Organic Carbon Mapping cookbook" />
  
  <meta name="twitter:description" content="The soilll cookbook." />
  <meta name="twitter:image" content="images/cover.png" />

<meta name="author" content="">


<meta name="date" content="2018-02-09">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="covariates.html">
<link rel="next" href="validation.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Foreword</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#editorial-board"><i class="fa fa-check"></i>Editorial Board</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#contributing-authors"><i class="fa fa-check"></i>Contributing Authors</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="copyright-and-disclaimer.html"><a href="copyright-and-disclaimer.html"><i class="fa fa-check"></i>Copyright and disclaimer</a></li>
<li class="chapter" data-level="1" data-path="presentation.html"><a href="presentation.html"><i class="fa fa-check"></i><b>1</b> Presentation</a></li>
<li class="chapter" data-level="2" data-path="soil-property-maps.html"><a href="soil-property-maps.html"><i class="fa fa-check"></i><b>2</b> Soil Property Maps</a><ul>
<li class="chapter" data-level="2.1" data-path="soil-property-maps.html"><a href="soil-property-maps.html#definitions-and-objectives"><i class="fa fa-check"></i><b>2.1</b> Definitions and Objectives</a></li>
<li class="chapter" data-level="2.2" data-path="soil-property-maps.html"><a href="soil-property-maps.html#generic-mapping-of-soil-grids-upscaling-of-plot-level-measurements-and-estimates"><i class="fa fa-check"></i><b>2.2</b> Generic Mapping of Soil Grids: Upscaling of Plot-Level Measurements and Estimates</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="preparation-of-local-soil-property-data.html"><a href="preparation-of-local-soil-property-data.html"><i class="fa fa-check"></i><b>3</b> Preparation of Local Soil Property Data</a><ul>
<li class="chapter" data-level="3.1" data-path="preparation-of-local-soil-property-data.html"><a href="preparation-of-local-soil-property-data.html#soil-profiles-and-soil-augers"><i class="fa fa-check"></i><b>3.1</b> Soil Profiles and Soil Augers</a></li>
<li class="chapter" data-level="3.2" data-path="preparation-of-local-soil-property-data.html"><a href="preparation-of-local-soil-property-data.html#soil-database"><i class="fa fa-check"></i><b>3.2</b> Soil Database</a><ul>
<li class="chapter" data-level="3.2.1" data-path="preparation-of-local-soil-property-data.html"><a href="preparation-of-local-soil-property-data.html#technical-steps---loading-data-from-tables-in-r"><i class="fa fa-check"></i><b>3.2.1</b> Technical Steps - Loading Data from Tables in R</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="preparation-of-local-soil-property-data.html"><a href="preparation-of-local-soil-property-data.html#completeness-of-measurements-and-estimates"><i class="fa fa-check"></i><b>3.3</b> Completeness of Measurements and Estimates</a><ul>
<li class="chapter" data-level="3.3.1" data-path="preparation-of-local-soil-property-data.html"><a href="preparation-of-local-soil-property-data.html#stones"><i class="fa fa-check"></i><b>3.3.1</b> Stones</a></li>
<li class="chapter" data-level="3.3.2" data-path="preparation-of-local-soil-property-data.html"><a href="preparation-of-local-soil-property-data.html#bulk-density"><i class="fa fa-check"></i><b>3.3.2</b> Bulk density</a></li>
<li class="chapter" data-level="3.3.3" data-path="preparation-of-local-soil-property-data.html"><a href="preparation-of-local-soil-property-data.html#soil-carbon-analysis"><i class="fa fa-check"></i><b>3.3.3</b> Soil Carbon Analysis</a></li>
<li class="chapter" data-level="3.3.4" data-path="preparation-of-local-soil-property-data.html"><a href="preparation-of-local-soil-property-data.html#carbonates"><i class="fa fa-check"></i><b>3.3.4</b> Carbonates</a></li>
<li class="chapter" data-level="3.3.5" data-path="preparation-of-local-soil-property-data.html"><a href="preparation-of-local-soil-property-data.html#depth"><i class="fa fa-check"></i><b>3.3.5</b> Depth</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="preparation-of-local-soil-property-data.html"><a href="preparation-of-local-soil-property-data.html#completeness-of-depth-estimate"><i class="fa fa-check"></i><b>3.4</b> Completeness of Depth Estimate</a><ul>
<li class="chapter" data-level="3.4.1" data-path="preparation-of-local-soil-property-data.html"><a href="preparation-of-local-soil-property-data.html#technical-steps---equal-area-splines-using-r"><i class="fa fa-check"></i><b>3.4.1</b> Technical Steps - Equal-Area Splines Using R</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html"><i class="fa fa-check"></i><b>4</b> Setting-Up the Software Environment</a><ul>
<li class="chapter" data-level="4.1" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#use-of-r-rstudio-and-r-packages"><i class="fa fa-check"></i><b>4.1</b> Use of R , RStudio and R Packages</a><ul>
<li class="chapter" data-level="4.1.1" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#obtaining-and-installing-r"><i class="fa fa-check"></i><b>4.1.1</b> Obtaining and Installing R</a></li>
<li class="chapter" data-level="4.1.2" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#obtaining-and-installing-r-studio"><i class="fa fa-check"></i><b>4.1.2</b> Obtaining and Installing R Studio</a></li>
<li class="chapter" data-level="4.1.3" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#getting-started-with-r"><i class="fa fa-check"></i><b>4.1.3</b> Getting Started with R</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#r-packages"><i class="fa fa-check"></i><b>4.2</b> R Packages</a><ul>
<li class="chapter" data-level="4.2.1" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#finding-r-packages"><i class="fa fa-check"></i><b>4.2.1</b> Finding R Packages</a></li>
<li class="chapter" data-level="4.2.2" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#most-used-r-packages-for-digital-soil-mapping"><i class="fa fa-check"></i><b>4.2.2</b> Most Used R Packages for Digital Soil Mapping</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#r-and-spatial-data"><i class="fa fa-check"></i><b>4.3</b> R and Spatial Data</a><ul>
<li class="chapter" data-level="4.3.1" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#reading-shapefiles"><i class="fa fa-check"></i><b>4.3.1</b> Reading Shapefiles</a></li>
<li class="chapter" data-level="4.3.2" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#coordinate-reference-systems-crs-in-r"><i class="fa fa-check"></i><b>4.3.2</b> Coordinate Reference Systems (CRS) in R</a></li>
<li class="chapter" data-level="4.3.3" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#working-with-rasters"><i class="fa fa-check"></i><b>4.3.3</b> Working with Rasters</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#other-dsm-related-software-and-tools"><i class="fa fa-check"></i><b>4.4</b> Other DSM Related Software and Tools</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="covariates.html"><a href="covariates.html"><i class="fa fa-check"></i><b>5</b> Preparation of Spatial covariates</a><ul>
<li class="chapter" data-level="5.1" data-path="covariates.html"><a href="covariates.html#dem-derived-covariates"><i class="fa fa-check"></i><b>5.1</b> DEM-Derived Covariates</a><ul>
<li class="chapter" data-level="5.1.1" data-path="covariates.html"><a href="covariates.html#dem-source-data-sets"><i class="fa fa-check"></i><b>5.1.1</b> DEM Source Data Sets</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="covariates.html"><a href="covariates.html#parent-material"><i class="fa fa-check"></i><b>5.2</b> Parent Material</a></li>
<li class="chapter" data-level="5.3" data-path="covariates.html"><a href="covariates.html#soil-maps"><i class="fa fa-check"></i><b>5.3</b> Soil Maps</a><ul>
<li class="chapter" data-level="5.3.1" data-path="covariates.html"><a href="covariates.html#technical-steps---rasterizing-a-vector-layer-in-r"><i class="fa fa-check"></i><b>5.3.1</b> Technical Steps - Rasterizing a Vector Layer in R</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="covariates.html"><a href="covariates.html#land-cover-and-land-use"><i class="fa fa-check"></i><b>5.4</b> Land Cover and Land use</a><ul>
<li class="chapter" data-level="5.4.1" data-path="covariates.html"><a href="covariates.html#globcover-global"><i class="fa fa-check"></i><b>5.4.1</b> GlobCover (Global)</a></li>
<li class="chapter" data-level="5.4.2" data-path="covariates.html"><a href="covariates.html#landsat-geocover-global"><i class="fa fa-check"></i><b>5.4.2</b> Landsat GeoCover (Global)</a></li>
<li class="chapter" data-level="5.4.3" data-path="covariates.html"><a href="covariates.html#globeland30-global"><i class="fa fa-check"></i><b>5.4.3</b> Globeland30 (Global)</a></li>
<li class="chapter" data-level="5.4.4" data-path="covariates.html"><a href="covariates.html#corine-land-cover-europe-only"><i class="fa fa-check"></i><b>5.4.4</b> CORINE Land Cover (Europe Only)</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="covariates.html"><a href="covariates.html#climate"><i class="fa fa-check"></i><b>5.5</b> Climate</a><ul>
<li class="chapter" data-level="5.5.1" data-path="covariates.html"><a href="covariates.html#worldclim-v1.4-and-v2-global"><i class="fa fa-check"></i><b>5.5.1</b> WorldClim V1.4 and V2 (Global)</a></li>
<li class="chapter" data-level="5.5.2" data-path="covariates.html"><a href="covariates.html#gridded-agro-meteorological-data-in-europe-europe"><i class="fa fa-check"></i><b>5.5.2</b> Gridded Agro-Meteorological Data in Europe (Europe)</a></li>
</ul></li>
<li class="chapter" data-level="5.6" data-path="covariates.html"><a href="covariates.html#GSOC-data-repo"><i class="fa fa-check"></i><b>5.6</b> GSOCMap - Data Repository (ISRIC, 2017)</a><ul>
<li class="chapter" data-level="5.6.1" data-path="covariates.html"><a href="covariates.html#covariates-and-empty-mask"><i class="fa fa-check"></i><b>5.6.1</b> Covariates and Empty Mask</a></li>
<li class="chapter" data-level="5.6.2" data-path="covariates.html"><a href="covariates.html#data-specifications"><i class="fa fa-check"></i><b>5.6.2</b> Data Specifications</a></li>
<li class="chapter" data-level="5.6.3" data-path="covariates.html"><a href="covariates.html#data-access"><i class="fa fa-check"></i><b>5.6.3</b> Data Access</a></li>
</ul></li>
<li class="chapter" data-level="5.7" data-path="covariates.html"><a href="covariates.html#extending-the-soil-property-table-for-spatial-statistics"><i class="fa fa-check"></i><b>5.7</b> Extending the Soil Property Table for Spatial Statistics</a></li>
<li class="chapter" data-level="5.8" data-path="covariates.html"><a href="covariates.html#preparation-of-a-soil-property-table-for-spatial-statistics"><i class="fa fa-check"></i><b>5.8</b> Preparation of a Soil Property Table for Spatial Statistics</a></li>
<li class="chapter" data-level="5.9" data-path="covariates.html"><a href="covariates.html#overlay-soil-covariates"><i class="fa fa-check"></i><b>5.9</b> Technical Steps - Overlay Covariates and Soil Points Data</a><ul>
<li class="chapter" data-level="5.9.1" data-path="covariates.html"><a href="covariates.html#load-soil-sample-data-and-covariates"><i class="fa fa-check"></i><b>5.9.1</b> Load soil sample data and covariates</a></li>
<li class="chapter" data-level="5.9.2" data-path="covariates.html"><a href="covariates.html#combine-the-covariates-provided-with-the-raster-version-of-the-soil-map"><i class="fa fa-check"></i><b>5.9.2</b> Combine the covariates provided with the raster version of the soil map</a></li>
<li class="chapter" data-level="5.9.3" data-path="covariates.html"><a href="covariates.html#overlay-covariates-and-spatial-data"><i class="fa fa-check"></i><b>5.9.3</b> Overlay Covariates and Spatial Data</a></li>
<li class="chapter" data-level="5.9.4" data-path="covariates.html"><a href="covariates.html#convert-result-to-data.frame-and-save-as-a-csv-table"><i class="fa fa-check"></i><b>5.9.4</b> Convert result to data.frame and save as a csv table</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="mapping-methods.html"><a href="mapping-methods.html"><i class="fa fa-check"></i><b>6</b> Mapping Methods</a><ul>
<li class="chapter" data-level="6.1" data-path="mapping-methods.html"><a href="mapping-methods.html#conventional-upscaling-using-soil-maps"><i class="fa fa-check"></i><b>6.1</b> Conventional Upscaling Using Soil Maps</a><ul>
<li class="chapter" data-level="6.1.1" data-path="mapping-methods.html"><a href="mapping-methods.html#overview"><i class="fa fa-check"></i><b>6.1.1</b> Overview</a></li>
<li class="chapter" data-level="6.1.2" data-path="mapping-methods.html"><a href="mapping-methods.html#technical-steps-class-matching"><i class="fa fa-check"></i><b>6.1.2</b> Technical Steps: Class-matching</a></li>
<li class="chapter" data-level="6.1.3" data-path="mapping-methods.html"><a href="mapping-methods.html#technical-steps-geo-matching"><i class="fa fa-check"></i><b>6.1.3</b> Technical Steps: Geo-Matching</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="mapping-methods.html"><a href="mapping-methods.html#regression-kriging"><i class="fa fa-check"></i><b>6.2</b> Regression-Kriging</a><ul>
<li class="chapter" data-level="6.2.1" data-path="mapping-methods.html"><a href="mapping-methods.html#overview-1"><i class="fa fa-check"></i><b>6.2.1</b> Overview</a></li>
<li class="chapter" data-level="6.2.2" data-path="mapping-methods.html"><a href="mapping-methods.html#assumptions"><i class="fa fa-check"></i><b>6.2.2</b> Assumptions</a></li>
<li class="chapter" data-level="6.2.3" data-path="mapping-methods.html"><a href="mapping-methods.html#pre-processing-of-covariates"><i class="fa fa-check"></i><b>6.2.3</b> Pre-Processing of Covariates</a></li>
<li class="chapter" data-level="6.2.4" data-path="mapping-methods.html"><a href="mapping-methods.html#the-terminology"><i class="fa fa-check"></i><b>6.2.4</b> The Terminology</a></li>
<li class="chapter" data-level="6.2.5" data-path="mapping-methods.html"><a href="mapping-methods.html#interpret-the-key-results-of-multiple-regression"><i class="fa fa-check"></i><b>6.2.5</b> Interpret the Key Results of Multiple Regression</a></li>
<li class="chapter" data-level="6.2.6" data-path="mapping-methods.html"><a href="mapping-methods.html#using-the-results-of-a-regression-analysis-to-make-predictions"><i class="fa fa-check"></i><b>6.2.6</b> Using the Results of a Regression Analysis to Make Predictions</a></li>
<li class="chapter" data-level="6.2.7" data-path="mapping-methods.html"><a href="mapping-methods.html#technical-steps---regression-kriging"><i class="fa fa-check"></i><b>6.2.7</b> Technical Steps - Regression Kriging</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="mapping-methods.html"><a href="mapping-methods.html#data-mining-random-forest"><i class="fa fa-check"></i><b>6.3</b> Data mining: Random Forest</a><ul>
<li class="chapter" data-level="6.3.1" data-path="mapping-methods.html"><a href="mapping-methods.html#overview-2"><i class="fa fa-check"></i><b>6.3.1</b> Overview</a></li>
<li class="chapter" data-level="6.3.2" data-path="mapping-methods.html"><a href="mapping-methods.html#random-forests"><i class="fa fa-check"></i><b>6.3.2</b> Random forests</a></li>
<li class="chapter" data-level="6.3.3" data-path="mapping-methods.html"><a href="mapping-methods.html#conceptual-model-and-data-preparation"><i class="fa fa-check"></i><b>6.3.3</b> Conceptual model and data preparation</a></li>
<li class="chapter" data-level="6.3.4" data-path="mapping-methods.html"><a href="mapping-methods.html#software"><i class="fa fa-check"></i><b>6.3.4</b> Software</a></li>
<li class="chapter" data-level="6.3.5" data-path="mapping-methods.html"><a href="mapping-methods.html#tunning-random-forest-parameters"><i class="fa fa-check"></i><b>6.3.5</b> Tunning Random forest parameters</a></li>
<li class="chapter" data-level="6.3.6" data-path="mapping-methods.html"><a href="mapping-methods.html#technical-steps---random-forest"><i class="fa fa-check"></i><b>6.3.6</b> Technical steps - Random forest</a></li>
<li class="chapter" data-level="6.3.7" data-path="mapping-methods.html"><a href="mapping-methods.html#modelling-uncertainty-using-random-forest"><i class="fa fa-check"></i><b>6.3.7</b> Modelling Uncertainty Using Random Forest</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="mapping-methods.html"><a href="mapping-methods.html#data-minning-support-vector-machines"><i class="fa fa-check"></i><b>6.4</b> Data minning: Support Vector Machines</a><ul>
<li class="chapter" data-level="6.4.1" data-path="mapping-methods.html"><a href="mapping-methods.html#technical-steps---fitting-a-svm-model-to-predict-the-soc"><i class="fa fa-check"></i><b>6.4.1</b> Technical Steps - Fitting a SVM Model to Predict the SOC</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="validation.html"><a href="validation.html"><i class="fa fa-check"></i><b>7</b> Validation</a><ul>
<li class="chapter" data-level="7.1" data-path="validation.html"><a href="validation.html#what-is-validation"><i class="fa fa-check"></i><b>7.1</b> What is Validation?</a></li>
<li class="chapter" data-level="7.2" data-path="validation.html"><a href="validation.html#map-quality-measures"><i class="fa fa-check"></i><b>7.2</b> Map Quality Measures</a><ul>
<li class="chapter" data-level="7.2.1" data-path="validation.html"><a href="validation.html#quality-measures-for-quantitative-soil-maps"><i class="fa fa-check"></i><b>7.2.1</b> Quality Measures for Quantitative Soil Maps</a></li>
<li class="chapter" data-level="7.2.2" data-path="validation.html"><a href="validation.html#quality-measures-for-qualitative-soil-maps"><i class="fa fa-check"></i><b>7.2.2</b> Quality Measures for Qualitative Soil Maps</a></li>
<li class="chapter" data-level="7.2.3" data-path="validation.html"><a href="validation.html#estimating-the-map-quality-measures-and-associated-uncertainty"><i class="fa fa-check"></i><b>7.2.3</b> Estimating the Map Quality Measures and Associated Uncertainty</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="validation.html"><a href="validation.html#graphical-map-quality-measures"><i class="fa fa-check"></i><b>7.3</b> Graphical Map Quality Measures</a></li>
<li class="chapter" data-level="7.4" data-path="validation.html"><a href="validation.html#validation-methods-and-statistical-inference"><i class="fa fa-check"></i><b>7.4</b> Validation Methods and Statistical Inference</a><ul>
<li class="chapter" data-level="7.4.1" data-path="validation.html"><a href="validation.html#additional-probability-sampling"><i class="fa fa-check"></i><b>7.4.1</b> Additional Probability Sampling</a></li>
<li class="chapter" data-level="7.4.2" data-path="validation.html"><a href="validation.html#data-splitting"><i class="fa fa-check"></i><b>7.4.2</b> Data-Splitting</a></li>
<li class="chapter" data-level="7.4.3" data-path="validation.html"><a href="validation.html#cross-validation"><i class="fa fa-check"></i><b>7.4.3</b> Cross-Validation</a></li>
<li class="chapter" data-level="7.4.4" data-path="validation.html"><a href="validation.html#technical-steps---validation"><i class="fa fa-check"></i><b>7.4.4</b> Technical steps - Validation</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="uncertainty.html"><a href="uncertainty.html"><i class="fa fa-check"></i><b>8</b> Uncertainty</a><ul>
<li class="chapter" data-level="8.1" data-path="uncertainty.html"><a href="uncertainty.html#sources-of-uncertainty"><i class="fa fa-check"></i><b>8.1</b> Sources of Uncertainty</a><ul>
<li class="chapter" data-level="8.1.1" data-path="uncertainty.html"><a href="uncertainty.html#attribute-uncertainty-of-soil-measurements"><i class="fa fa-check"></i><b>8.1.1</b> Attribute Uncertainty of Soil Measurements</a></li>
<li class="chapter" data-level="8.1.2" data-path="uncertainty.html"><a href="uncertainty.html#positional-uncertainty-of-soil-measurements"><i class="fa fa-check"></i><b>8.1.2</b> Positional Uncertainty of Soil Measurements</a></li>
<li class="chapter" data-level="8.1.3" data-path="uncertainty.html"><a href="uncertainty.html#uncertainty-in-covariates"><i class="fa fa-check"></i><b>8.1.3</b> Uncertainty in Covariates</a></li>
<li class="chapter" data-level="8.1.4" data-path="uncertainty.html"><a href="uncertainty.html#uncertainty-in-models-predicting-soil-properties-from-covariates-and-soil-point-data"><i class="fa fa-check"></i><b>8.1.4</b> Uncertainty in Models Predicting Soil Properties From Covariates and Soil Point Data</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="uncertainty.html"><a href="uncertainty.html#uncertainty-and-spatial-data-quality"><i class="fa fa-check"></i><b>8.2</b> Uncertainty and Spatial Data Quality</a></li>
<li class="chapter" data-level="8.3" data-path="uncertainty.html"><a href="uncertainty.html#quantifying-prediction-uncertainty"><i class="fa fa-check"></i><b>8.3</b> Quantifying Prediction Uncertainty</a><ul>
<li class="chapter" data-level="8.3.1" data-path="uncertainty.html"><a href="uncertainty.html#uncertainty-characterised-by-probability-distributions"><i class="fa fa-check"></i><b>8.3.1</b> Uncertainty Characterised by Probability Distributions</a></li>
<li class="chapter" data-level="8.3.2" data-path="uncertainty.html"><a href="uncertainty.html#propagation-of-model-uncertainty"><i class="fa fa-check"></i><b>8.3.2</b> Propagation of Model Uncertainty</a></li>
<li class="chapter" data-level="8.3.3" data-path="uncertainty.html"><a href="uncertainty.html#propagation-of-attribute-positional-and-covariate-uncertainty"><i class="fa fa-check"></i><b>8.3.3</b> Propagation of Attribute, Positional and Covariate Uncertainty</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="data-sharing.html"><a href="data-sharing.html"><i class="fa fa-check"></i><b>9</b> Data Sharing</a><ul>
<li class="chapter" data-level="9.1" data-path="data-sharing.html"><a href="data-sharing.html#export-formats"><i class="fa fa-check"></i><b>9.1</b> Export Formats</a><ul>
<li class="chapter" data-level="9.1.1" data-path="data-sharing.html"><a href="data-sharing.html#type-of-soil-data-and-their-formatting"><i class="fa fa-check"></i><b>9.1.1</b> Type of Soil Data and Their Formatting</a></li>
<li class="chapter" data-level="9.1.2" data-path="data-sharing.html"><a href="data-sharing.html#general-gis-data-formats-vector-raster-table"><i class="fa fa-check"></i><b>9.1.2</b> General GIS Data Formats: Vector, Raster, Table</a></li>
<li class="chapter" data-level="9.1.3" data-path="data-sharing.html"><a href="data-sharing.html#recommended-gis-data-exchange-formats"><i class="fa fa-check"></i><b>9.1.3</b> Recommended GIS Data Exchange Formats</a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="data-sharing.html"><a href="data-sharing.html#web-services---serving-soil-data-using-web-technology"><i class="fa fa-check"></i><b>9.2</b> Web Services - Serving Soil Data Using Web Technology</a><ul>
<li class="chapter" data-level="9.2.1" data-path="data-sharing.html"><a href="data-sharing.html#third-party-services"><i class="fa fa-check"></i><b>9.2.1</b> Third-Party Services</a></li>
<li class="chapter" data-level="9.2.2" data-path="data-sharing.html"><a href="data-sharing.html#geoserver-web-serving-and-web-processing"><i class="fa fa-check"></i><b>9.2.2</b> GeoServer (Web Serving and Web Processing)</a></li>
<li class="chapter" data-level="9.2.3" data-path="data-sharing.html"><a href="data-sharing.html#visualizing-data-using-leaflet-andor-google-earth"><i class="fa fa-check"></i><b>9.2.3</b> Visualizing Data Using Leaflet and/or Google Earth</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="data-sharing.html"><a href="data-sharing.html#preparing-soil-data-for-distribution"><i class="fa fa-check"></i><b>9.3</b> Preparing Soil Data for Distribution</a><ul>
<li class="chapter" data-level="9.3.1" data-path="data-sharing.html"><a href="data-sharing.html#metadata"><i class="fa fa-check"></i><b>9.3.1</b> Metadata</a></li>
<li class="chapter" data-level="9.3.2" data-path="data-sharing.html"><a href="data-sharing.html#exporting-data-final-tips"><i class="fa fa-check"></i><b>9.3.2</b> Exporting Data — Final Tips</a></li>
</ul></li>
<li class="chapter" data-level="9.4" data-path="data-sharing.html"><a href="data-sharing.html#export-formats-1"><i class="fa fa-check"></i><b>9.4</b> Export Formats</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html"><i class="fa fa-check"></i><b>10</b> Technical Overview and the Checklist</a><ul>
<li class="chapter" data-level="10.1" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html#point-dataset"><i class="fa fa-check"></i><b>10.1</b> Point Dataset</a></li>
<li class="chapter" data-level="10.2" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html#covariates-1"><i class="fa fa-check"></i><b>10.2</b> Covariates</a></li>
<li class="chapter" data-level="10.3" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html#statistical-inference"><i class="fa fa-check"></i><b>10.3</b> Statistical Inference</a></li>
<li class="chapter" data-level="10.4" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html#spatial-interpolation"><i class="fa fa-check"></i><b>10.4</b> Spatial Interpolation</a></li>
<li class="chapter" data-level="10.5" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html#calculation-of-stocks"><i class="fa fa-check"></i><b>10.5</b> Calculation of STOCKS</a></li>
<li class="chapter" data-level="10.6" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html#evaluation-of-output-and-quality-assessment"><i class="fa fa-check"></i><b>10.6</b> Evaluation of Output and Quality Assessment</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="deliverables.html"><a href="deliverables.html"><i class="fa fa-check"></i><b>11</b> Deliverables</a></li>
<li class="chapter" data-level="12" data-path="code-examples.html"><a href="code-examples.html"><i class="fa fa-check"></i><b>12</b> Code examples</a><ul>
<li class="chapter" data-level="12.1" data-path="code-examples.html"><a href="code-examples.html#data-preparation-for-soil-profilesdata-preparation-for-soil-profiles"><i class="fa fa-check"></i><b>12.1</b> Data Preparation for Soil Profiles{#Data Preparation for Soil Profiles}</a></li>
<li class="chapter" data-level="12.2" data-path="code-examples.html"><a href="code-examples.html#data-preparation-for-top-soil-or-auger-samples-data-preparation-for-top-soil-or-auger-samples"><i class="fa fa-check"></i><b>12.2</b> Data Preparation for Top Soil or Auger Samples {#Data Preparation for Top Soil or Auger Samples}</a></li>
<li class="chapter" data-level="12.3" data-path="code-examples.html"><a href="code-examples.html#mixing-covariates-and-soil-points-data"><i class="fa fa-check"></i><b>12.3</b> Mixing Covariates and Soil Points Data</a></li>
<li class="chapter" data-level="12.4" data-path="code-examples.html"><a href="code-examples.html#fitting-a-rk-model-to-predict-the-ocs"><i class="fa fa-check"></i><b>12.4</b> Fitting a RK model to predict the OCS</a></li>
<li class="chapter" data-level="12.5" data-path="code-examples.html"><a href="code-examples.html#fitting-a-random-forest-model-to-predict-the-soc"><i class="fa fa-check"></i><b>12.5</b> Fitting a random forest model to predict the SOC</a></li>
<li class="chapter" data-level="12.6" data-path="code-examples.html"><a href="code-examples.html#fitting-a-svm-model-to-predict-the-soc"><i class="fa fa-check"></i><b>12.6</b> Fitting a svm model to predict the SOC</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Soil Organic Carbon Mapping cookbook</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="mapping-methods" class="section level1">
<h1><span class="header-section-number">Chapter 6</span> Mapping Methods</h1>
<p><em>R Baritz, M Guevara, VL Mulder, GF Olmedo, C Thine, RR Vargas, Y Yigini</em></p>
<p>In this chapter we want to introduce 5 different approaches for obtaining the SOC map for FYROM. The first two methods presented are classified as convetional upscaling. The first one is class-matching. In this approach we derive average SOC stocks per class: soil type for which a national map exists, or combination with other spatial covariates (e.g. land use category, climate type, biome, etc.). This approach is used in the absence of spatial coordinates of the source data. The second one is geo-matching, were upscaling is based on averaged SOC values per mapping unit. Then, we present 3 methods from digital soil mapping. Regression-Kriging is a hybrid model with both, a deterministic and a stochastic component <span class="citation">(Hengl, Heuvelink, and Rossiter <a href="#ref-hengl2007regression">2007</a>)</span>. Next method is called random forest. This one is an ensemble of regression trees based on bagging. This machine learning algorithm uses a different combination of prediction factors to train multiple regression trees <span class="citation">(Breiman <a href="#ref-Breiman1996">1996</a>)</span>. The last method is called support Vector Machines (SVM). This method applies a simple linear method to the data but in a high-dimensional feature space non-linearly related to the input space <span class="citation">(Karatzoglou, Meyer, and Hornik <a href="#ref-Karatzoglou2006">2006</a>)</span>. We present this diversity of methods because there is no best mapping method for digital soil mapping, and testing and selection has to be done for every data scenario <span class="citation">(Guevara et al. <a href="#ref-soil-2017-40">2018</a>)</span>.</p>
<div id="conventional-upscaling-using-soil-maps" class="section level2">
<h2><span class="header-section-number">6.1</span> Conventional Upscaling Using Soil Maps</h2>
<p><em>R Baritz, VL Mulder</em></p>
<div id="overview" class="section level3">
<h3><span class="header-section-number">6.1.1</span> Overview</h3>
<p>The two conventional upscaling methods, in the context of SOC mapping, are described by . Details about weighted averaging can be found in . Different conventional upscaling approaches were applied in many countries (Baritz et al. 1999 (Germany),  (Mexico),  (Denmark), Koelli et al. 2009 (Estonia),  (France),  (Canada)). Because the structure of soil map databases differs between countries (definition of the soil mapping unit, stratification, soil associations, dominating and co-dominating soils, typical and estimate soil properties for different depths), it is difficult to define a generic methodology for the use of these maps for mapping soil property information.</p>
<p>However, the essential principle which is commonly used, is to combine soil property data from local observations with soil maps via class- and geomatching.</p>
<p><strong>Diversity of national soil legacy data sets</strong>
in order to develop a representative and large national soil database, very often, data from different sources (e.g. soil surveys or projects in different parts of the country at different times) are combined. The following case of Belgium demonstrates how available legacy databases could be combined. Three different sources are used to compile an overview of national SOC stocks:</p>
<p><strong>Data source 1</strong>: soil profile database with 13,000 points of genetic horizons; for each site, there is information about the soil series, map coordinates and land use class; for each horizon, there is information about depth and thickness, textural fractions and class, volume percentage of rock fragments; analytically, there is the organic carbon content and inorganic carbon content.</p>
<p><strong>Data source 2</strong>: forest soil data base which includes ectorganic horizons. According to their national definition, the term “ectorganic” designates the surface horizons with an organic matter content of at least <span class="math inline">\(30\%\)</span>, thus, it includes both the litter layer and the organic soil layers. For the calculation of SOC stocks for the ectorganic layer, no fixed-depth was used, instead the measured thickness of the organic layers and litter layers was applied.</p>
<p><strong>Data source 3</strong>: 15,000 soil surface samples were used (upper 20 cm of mineral soil); carbon measurements are available per depth class.</p>
<p>From all data sources, SOC stocks for peat soils were calculated separately.</p>
</div>
<div id="technical-steps-class-matching" class="section level3">
<h3><span class="header-section-number">6.1.2</span> Technical Steps: Class-matching</h3>
<div id="data-preparation" class="section level4">
<h4><span class="header-section-number">6.1.2.1</span> Data Preparation</h4>
<ul>
<li>Separate the data base for forests, peat and other land uses
If only horizons are provided: derive or estimate average depth of horizons per soil type; add upper and lower depth.</li>
<li>Check completeness of parameters per depth using the solum depth to code empty cells</li>
<li>Correction of organic carbon in case total carbon was determined (total carbon minus inorganic carbon concentration)</li>
<li>Correction of Walkley and Black method for incomplete oxidation (1.32)</li>
<li>If BD measured is lacking, select proper pedotransfer functions (PTF) and estimate BD. There are many PTF. At best, publications about the choice of the best suited PTF for specific physio-geographic conditions are available.</li>
<li>If stone content is missing, investigate using other data sources or literature, to which a correction for stones should be applied</li>
<li>if possible, derive the standard average stone content for different soils/horizons/depths, or used published soil profiles, as a simple correction factor.</li>
<li>Calculate SOC stocks for all mineral and peat soils over 0-30 cm, and optionally for forest organic layers and, peat &gt;30 &lt;100 cm.</li>
</ul>
</div>
<div id="preparatory-gis-operations" class="section level4">
<h4><span class="header-section-number">6.1.2.2</span> Preparatory GIS Operations</h4>
<ul>
<li>Prepare Covariates</li>
<li>Identify properties of covariates for each point observation using geo-matching</li>
<li>Mapping using geo-matching of all points: Extract the covariate information to all georeferenced sample sites. The SOC values from all points within the unit are then averaged. It is assumed that the points represent the real variability of soil types within the units</li>
</ul>
</div>
<div id="mapping" class="section level4">
<h4><span class="header-section-number">6.1.2.3</span> Mapping</h4>
<ul>
<li>Mapping using class-matching of points in agreement with classes</li>
</ul>
<p>Through <em>class-matching</em>, only those points or profiles are attributed to a soil or landscape unit if both the soil and the land use class are the same. Class-matching thus can be performed regardless of the profile location. Before averaging, a weighing factor can be introduced according to the area proportions of dominant, co-dominant and associated soils. Each profile needs to be matched to its soil type/landscape type, and the SOC value averaged.
1. Determine a soil or landscape unit (e.g. national soil legend stratified by climate area and main land cover type (forest, grassland, cropland)
2. Calculate average SOC stocks from from all soils which match the soil/landscape unit
3. Present the Soil/landscape map with SOC stocks, do not classify SOC stocks into groups (e.g. &lt; 50, 50-100, &gt; 100).</p>
<p>Note: Pre-classified SOC maps cannot be integrated into a global GSOCmap legend.</p>
<ul>
<li>Mapping using geo-matching</li>
</ul>
<p>Because of its importance, geo-matching is described in more detail.</p>
</div>
</div>
<div id="technical-steps-geo-matching" class="section level3">
<h3><span class="header-section-number">6.1.3</span> Technical Steps: Geo-Matching</h3>
<p>It is important to first prepare the working environment pre-processed all input data. The following section presents different Geo-matching procedures;</p>
<ol style="list-style-type: decimal">
<li>Setting up software and working environment</li>
<li>Geo-matching SOC with WRB Soil map (step-by-step, using the Soil Map of FYROM and the demonstration data presented above)</li>
<li>Geo-matching SOC with other environmental variables: Land use</li>
<li>Finally, the development of Landscape Units (Lettens et al. 2004) is outlined.</li>
</ol>
<p>This example was developed for QGIS and focusses on SOC mapping using vector data. QGIS 2.18 with GRASS 7.05 will be used. For more information, see also:</p>
<ul>
<li><a href="https://gis.stackexchange.com" class="uri">https://gis.stackexchange.com</a></li>
<li><a href="http://www.qgis.org/" class="uri">http://www.qgis.org/</a></li>
<li><a href="http://www.qgisforum.org/" class="uri">http://www.qgisforum.org/</a></li>
</ul>
<div id="setting-up-a-qgis-project" class="section level4">
<h4><span class="header-section-number">6.1.3.1</span> Setting Up a QGIS Project</h4>
<ol style="list-style-type: decimal">
<li>Install QGIS and supporting software; download the software at <a href="http://www.qgis.org/en/site/forusers/download.html" class="uri">http://www.qgis.org/en/site/forusers/download.html</a> (select correct version for Windows, Mac or Linux, 32 or 64 bit).</li>
<li>Create a work folder, e.g. D:\GSOC\practical_matching. Copy the folder with the FYROM demonstration data into this folder.</li>
<li>Start ‘QGIS desktop with GRASS’
Figure 8.1 shows the start screen of QGIS desktop. In the upper left panel there is the browser panel, which lists the geodata used for this example. In the bottom left, the layer information is given for the layers displayed on the right.</li>
</ol>
<div class="figure">
<img src="images/Conv_upscaling1.png" alt="QGIS Desktop with the browser panel on the upper left, the layer information on the bottom left and the display of your layers on the right." />
<p class="caption">QGIS Desktop with the browser panel on the upper left, the layer information on the bottom left and the display of your layers on the right.</p>
</div>
<ol start="4" style="list-style-type: decimal">
<li>Load the FYROM soil map. Right-click the file in the Browser panel and add the map to your project.</li>
<li>Display the soil classes. Right-click on the file in the Layers Panel, properties. Go to Style and change from ‘Single symbol’ to ‘Categorized’ (Fig. 8.2). Select the column ‘WRB’ and press the icon ‘Classify’ and change the colours if you want. Next, apply the change and finish with clicking the OK-button.</li>
</ol>
<div class="figure">
<img src="images/Conv_upscaling2.png" alt="Load the FYROM Soil Map" />
<p class="caption">Load the FYROM Soil Map</p>
</div>
<ol start="6" style="list-style-type: decimal">
<li>Ensure the correct projection for this project. Go to: Project -&gt; Project properties -&gt; CRS
In this case, you automatically use the local projection for FYROM. The EPSG code is 3909 which corresponds to MGI 1901/ Balkans zone 7 (Figure 8.3).</li>
</ol>
<div class="figure">
<img src="images/Conv_upscaling3.png" alt="Project properties and projection settings" />
<p class="caption">Project properties and projection settings</p>
</div>
<ol start="7" style="list-style-type: decimal">
<li>Save the project in the created folder
Load and display the pre-processed SOC point data. If a shapefile already exists, this is done the same way as described in Step 4. If you have the data as a text file, you need to create a vector layer out of that file. Go to Layer -&gt; Add Layer -&gt; Add Delimited Text layer. Select the correct file and proper CRS projection. The layer should be added to your Layers Panel and displayed on top of the Soil Map.</li>
</ol>
</div>
<div id="geo-matching-soc-with-wrb-soil-map" class="section level4">
<h4><span class="header-section-number">6.1.3.2</span> Geo-Matching SOC with WRB Soil Map</h4>
<p>In this section you will make a SOC map, based on the FYROM Soil Map and the SOC values at the sampled points, following 3 steps: 1) Extract the soil map information for the point data, 2) obtain the mean and standard deviation of the SOC stocks per soil class, based on the point data and 3) assign these values to the corresponding soil map units. The steps are detailed below:</p>
<ol style="list-style-type: decimal">
<li>Extract the soil map information to the soil profile data by ‘Join Attributes by location’. Vector -&gt; Data Management Tools -&gt; Join Attributes by location. Here, the target vector layers are the soil point data, and the join vector layer is the FYROM Soil Map. The geometric predicate is ‘intersects’. Specify at the ‘joined table’ to keep only matching records and save the ‘joined layer’ as a new file (Fig. 8.4).</li>
</ol>
<div class="figure">
<img src="images/Conv_upscaling4.png" alt="Join attributes by location" />
<p class="caption">Join attributes by location</p>
</div>
<ol start="2" style="list-style-type: decimal">
<li>Check the newly generated file, open the attribute table. The new file is added to the ‘Layers Panel’ . Right-click on the file and open the attribute table. The information from the FYROM Soil Map is now added to the soil point data.</li>
<li>Most likely, the SOC values in the table are not numeric and thus statistics cannot be calculated. Check the data format, right-click on the file in the ‘Layers Panel’ and check the Type name of the SOC field under the tab ‘Fields’. If they are not integer then change the format.</li>
<li>Change of the data format: Open the attribute table and start editing (the pencil symbol in the upper left corner of your table). Open the field calculator and follow these instructions (Fig. 8.5):</li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>Check box: Create a new field</li>
<li>Output field name: Specify the name of your field</li>
<li>Output field type: Decimal Number (real)</li>
<li>Output field length: 10, precision: 3
<ol style="list-style-type: lower-roman">
<li>Expression: to_real(‘SOC’), the to_real function can be found under ‘conversions’ and the ‘SOC’ field is found under ‘Fields and Values’</li>
</ol></li>
</ol>
<div class="figure">
<img src="images/Conv_upscaling5.png" alt="Example field calculator" />
<p class="caption">Example field calculator</p>
</div>
<ol start="5" style="list-style-type: decimal">
<li>After calculating the field, save edits and leave the editing mode prior to closing the table. If changes are not saved, the added field will be lost.</li>
<li>Calculate the median SOC stock per soil type. Go to the tab ‘Vector’-&gt; group stats. Select the layer from the spatial join you made in Step 2. Add the field ‘SOC’ and median to the box with ‘Values’ and the field ‘WRB’ to the ‘Rows’. Make sure the box with ‘use only selected features’ is not checked. Now calculate the statistics. A table will be given in the left pane (Figure 8.6). Save this file as .csv and repeat the same for the standard deviation.</li>
</ol>
<div class="figure">
<img src="images/Conv_upscaling6.png" alt="Calculate group statistics" />
<p class="caption">Calculate group statistics</p>
</div>
<ol start="7" style="list-style-type: decimal">
<li>Join the mean and standard deviation of SOC to the Soil Map. First add the files generated during step 6 to the Layers Panels. In the Layers Panel, right-click on the FYROM Soil Map. Go to Properties -&gt; Joins and add a new join for both the median and standard deviation of SOC. The Join and Target Field are both ‘WRB’.</li>
<li>Display the SOC maps. Go to the layer properties of the FYROM Soil Map. Go to Style and change the legend to a graduated legend. In the column you indicate the assigned SOC values. Probably this is not a integer number and so you have to convert this number again to a numeric values. You can do this with the box next to the box (Fig. 8.7). Change the number of classes to e.g. 10 classes, change the mode of the legend and change the color scheme if you want and apply the settings. Now you have a map with the median SOC stocks per WRB soil class.</li>
</ol>
<div class="figure">
<img src="images/Conv_upscaling7.png" alt="Change the legend style to display the SOC values" />
<p class="caption">Change the legend style to display the SOC values</p>
</div>
<ol start="9" style="list-style-type: decimal">
<li>In order to generate a proper layout, go to Project -&gt; New Print Composer</li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>Add map using Layout -&gt; Add Map. Define a square on the canvas and the selected map will be displayed.</li>
<li>Similarly, title, scale bar, legend and a north arrow can be added. Specific properties can be changed in the box ‘Item properties’.</li>
<li>When the map is finished, it can be exported as an image or pdf.</li>
</ol>
<div class="figure">
<img src="images/Conv_upscaling8.png" alt="Example of the Map composer" />
<p class="caption">Example of the Map composer</p>
</div>
<ol start="10" style="list-style-type: decimal">
<li>Repeat step 2-8 but now for the standard deviation of the SOC stocks.</li>
<li>Save the file as a new shapefile: Go to ‘Layer Panels -&gt; Save as -&gt; ESRI ShapeFile and make sure that you define the symbology export: Feature Symbology. Now, a shapefile is generated, with both the median and standard deviation SOC stock per soil type. Redundant fields can be removed after the new file is created.</li>
</ol>
</div>
<div id="geo-matching-soc-with-other-environmental-variables-land-use" class="section level4">
<h4><span class="header-section-number">6.1.3.3</span> Geo-Matching SOC with Other Environmental Variables: Land Use</h4>
<ol style="list-style-type: decimal">
<li>Start a new project and add the soil point data and FYROM Soil Map layers from the Browser panel</li>
<li>Add the Land Use raster file to the Layers Panels. This is a raster file with 1 kilometre resolution and projected in lat long degrees (WGS84). For more information about this product see the online information from worldgrids: <a href="http://worldgrids.org/doku.php/wiki:glcesa3" class="uri">http://worldgrids.org/doku.php/wiki:glcesa3</a></li>
<li>Change the projection to the MGI 1901/ Balkans region7. Go to Raster -&gt; Projections -&gt; Warp and select the proper projection and a suitable file name, e.g. LU_projected_1km. Tick the checkbox for the resampling method and choose Near. This is nearest neighbour and most suitable for a transformation of categorical data, such as land use (Fig. 8.9).</li>
</ol>
<div class="figure">
<img src="images/Conv_upscaling9.png" alt="Change the projection of a raster file" />
<p class="caption">Change the projection of a raster file</p>
</div>
<ol start="4" style="list-style-type: decimal">
<li>In order to geomatch the soil point data with Land Use, the raster file needs to be converted into a vector file. Go to Raster -&gt; Conversions -&gt; Polygonize. Set a proper output filename, e.g. LU_polygon_1km, and check the tickbox for Fieldname.</li>
<li>Change the legend style into categories (Step 1-5):
Now, the steps from the previous section need to be repeated, using the land use polygon map instead of using the FYROM Soil Map.</li>
<li>Join attributes by location using the soil point data and the polygon land use map.</li>
<li>Calculate the median and standard deviation of SOC by using the Group Statistics for SOC and the Land Use classes and save the files as .csv.</li>
<li>Add the generated .csv files to the Layers Panel.</li>
<li>Join the files with the LU polygon map, generated at step 3-4.</li>
<li>Change the classes in the legend and inspect the histogram with the median SOC values. Try to find a proper definition of the class boundaries (Step 2-8).</li>
</ol>
</div>
<div id="joining-landscape-units-and-soil-mapping-units-to-support-class--and-geo-matching-optional" class="section level4">
<h4><span class="header-section-number">6.1.3.4</span> Joining Landscape Units and Soil Mapping Units to Support Class- and Geo-Matching (Optional)</h4>
<p>In this section it is outlined how SOC stocks can be mapped following the method outlined by . The general idea is that the landscape is stratified into more or less homogenous units and subsequently, the SOC stocks are obtained following the procedure outlined earlier in this practical.  outlines a method to stratify the landscape into homogeneous strata with respect to Land Use and Soil Type, as was explained earlier. In order to obtain such strata, the Soil Map and the Land Use map need to be combined. This can be done using various types of software, e.g. ArcMap, GRASS, QGIS or R.
When using the GIS software, the only thing that needs to be done is intersecting the vector files and dissolving the newly created polygon features. Depending on the software and the quality of your shapefile you may experience problems with the geometry of your shapefile. Generally, ArcMap and GRASS correct the geometry when the shapefile is loaded, while QGIS does not do this automatically. There are various ways to correct the geometry, however, correcting the geometry falls outside the scope of this training. Therefore, we give some hints on how to correct your geometry prior to using the functions ‘Intersect’ and ‘Dissolve’.</p>
<ol style="list-style-type: decimal">
<li>Change the LU raster map to 5 kilometer resolution: Right-click the Lu_project_1km file and select Save as. Change the resolution to 5000 meters. Scroll down, check the Pyramids box, and change the resampling method to Nearest Neighbour.</li>
<li>Convert the raster map to a polygon map and add the file to the Layers Panel</li>
<li>Check the validity of the Soil Map and Land Use Map: Vector -&gt; Geometry Tools -&gt; Check Validity
Below you find the instructions in case you have no problems with your geometry:</li>
<li>Intersect the Soil Map and the Land Use Map. In ArcGIS and QGIS you can use this function. Go to Vector -&gt; Geoprocessing tools -&gt; Intersection. (In GRASS you have to use the function ‘Overlay’ from the Vector menu)</li>
<li>Dissolve the newly generated polygons. Vector -&gt; Geoprocessing tools -&gt; Dissolve</li>
<li>Next, this layer can be used to continue with the classmatching or geomatching procedures.</li>
</ol>
<p><strong>When encountering problems with the geometry there are at least three ways to correct your geometry:</strong></p>
<ul>
<li>Run the v_clean tool from GRASS within QGIS. Open the Processing ToolBox -&gt; GRASS GIS 5 commands -&gt; Vector -&gt; v.clean</li>
<li>Install the plugin ‘Processing LWGEOM Provider’. Go to the Plugins menu and search for the plugin and install. You can find the newly installed tool in the Processing Toolbox by typing the name in the search function</li>
<li>Manually correct the error nodes of the vector features</li>
</ul>


</div>
</div>
</div>
<div id="regression-kriging" class="section level2">
<h2><span class="header-section-number">6.2</span> Regression-Kriging</h2>
<p><em>GF Olmedo &amp; Y Yigini</em></p>
<div id="overview-1" class="section level3">
<h3><span class="header-section-number">6.2.1</span> Overview</h3>
<p>Regression-kriging is a spatial interpolation technique that combines a regression of the dependent variable (target variable) on predictors (i.e. the environmental covariates) with kriging of the prediction residuals. In other words, Regression-Kriging is a hybrid method that combines either a simple or a multiple-linear regression model with ordinary kriging of the prediction residuals. The Multiple regression analysis models the relationship of multiple predictor variables and one dependent variable, i.e. it models the deterministic trend between the target variable and environmental covariates. The modelled relationship between predictors and target are summarized in regression equation, which can then be applied to a different data set in which the target values are unknown but the predictor variables are known. The regression equation predicts the value of the dependent variable using a linear function of the independent variables.
In this section, we review the regression kriging method. First, the deterministic part of the trend is modelled using a regression model. Next, the prediction residuals are kriged. In the regression phase of a regression-kriging technique, there is a continuous random variable called the dependent variable (target) Y (in our case SOC) and a number of independent variables which are selected covariates, x1, x2,…,xp. Our purpose is to predict the value of the dependent variable using a linear function of the independent variables. The values of the independent variables (environmental covariates) are known quantities for purposes of prediction, the model is:</p>
</div>
<div id="assumptions" class="section level3">
<h3><span class="header-section-number">6.2.2</span> Assumptions</h3>
<p>Standard linear regression models with standard estimation techniques make a number of assumptions about the predictor variables, the response variables and their relationship. One must review the assumptions made when using the model.</p>
<p><em>Linearity</em>: The mean value of Y for each specific combination of the X’s is a linear function of the X’s. In practice this assumption can virtually never be confirmed; fortunately, multiple regression procedures are not greatly affected by minor deviations from this assumption. If curvature in the relationships is evident, one may consider either transforming the variables, or explicitly allowing for nonlinear components.
<em>Normality Assumption</em>: It is assumed in multiple regression that the residuals (predicted minus observed values) are distributed normally (i.e., follow the normal distribution). Again, even though most tests (specifically the F-test) are quite robust with regard to violations of this assumption, it is always a good idea, before drawing final conclusions, to review the distributions of the major variables of interest. You can produce histograms for the residuals as well as normal probability plots, in order to inspect the distribution of the residual values.
<em>Collinearity</em>: There is not perfect collinearity in any combination of the X’s. A higher degree of collinearity, or overlap, among independent variables can cause problems in multiple linear regression models. Collinearity (also multicollinearity) is a phenomenon in which two or more predictors in a multiple regression model are highly correlated. Collinearity causes increase in variances and relatedly increases inaccuracy.
<em>Distribution of the Errors</em>: The error term is normally distributed with a mean of zero and constant variance.
<em>Homoscedasticity</em>: The variance of the error term is constant for all combinations of X’s. The term homoscedasticity means “same scatter.” Its antonym is heteroscedasticity (“different scatter”).</p>
</div>
<div id="pre-processing-of-covariates" class="section level3">
<h3><span class="header-section-number">6.2.3</span> Pre-Processing of Covariates</h3>
<p>Before using the selected predictors, multicollinearity assumption must be reviewed. As an assumption, there is not perfect collinearity in any combination of the X’s. A higher degree of collinearity, or overlap, among independent variables can cause problems in multiple linear regression models. The multicollinearity of number of variables can be assessed using Variance Inflation Factor (VIF). In R, the function vif() from caret package can estimate the VIF. There are several rules of thumb to establish when there is a serious multi-collinearity (e.g. when the VIF square root is over 2). The Principal component analysis can be used to overcome multicollinearity issues.
Principal components analysis can cope with data containing large numbers of covariates that are highly collinear which is the common case in environmental predictors. Often the principal components with higher variances are selected as regressors. However, for the purpose of predicting the outcome, the principal components with low variances may also be important, in some cases even more important.
The PCA + Linear Regression (PCR) method may be coarsely divided into three main steps:
1. Run PCA on the data matrix for the predictors to obtain the principal components, and then select a subset of the principal components for further use.
2. Regress the dependent variable on the selected principal components as covariates, linear regression to get estimated regression coefficients.
3. Transforming the data back to the scale of the actual covariates, using the selected PCA loadings.</p>
</div>
<div id="the-terminology" class="section level3">
<h3><span class="header-section-number">6.2.4</span> The Terminology</h3>
<ul>
<li><strong>Dependent variable (Y)</strong>: What we are trying to predict (e.g. soil organic carbon content).</li>
<li><strong>Independent variables (Predictors) (X)</strong>: Variables that we believe influence or explain the dependent variable (Covariates: environmental covariates - DEM derived covariates, soil maps, land cover maps, climate maps). The data sources for the environmental predictors are provided in Chapter 3.</li>
<li><strong>Coefficients (β)</strong>: values, computed by the multiple regression tool, reflect the relationship and strength of each independent variable to the dependent variable.</li>
<li><strong>Residuals (ε)</strong>: the portion of the dependent variable that cannot be explained by the model; the model under/over predictions.</li>
</ul>
<div class="figure">
<img src="images/RKequation.png" alt="Linear regression model" />
<p class="caption">Linear regression model</p>
</div>
<p>Before we proceed with the regression analysis, it is advisable to inspect the histogram of the dependent/target variable, in order to see if it needs to be transformed before fitting the regression model. The data for the selected soil property is normal when the frequency distribution of the values follow a bell-shaped curve (Gaussian distribution) which is symmetric around its mean. Normality tests may be used to assess normality. If a normality test indicates that data are not normally distributed, it may be necessary to transform the data to meet the normality assumption.</p>
<blockquote>
<p>Both, the normality tests and the data transformation can be easily performed using any commercial or open source statitical tool (R, SPSS, MINITAB…)</p>
</blockquote>
<p>The main steps for the multiple linear regression analysis are shown in the Figure [fig:Workflow for Regression Kriging].</p>
<div class="figure">
<img src="images/RKworkflow.png" alt="Workflow for Regression Kriging" />
<p class="caption">Workflow for Regression Kriging</p>
</div>
<blockquote>
<ol style="list-style-type: decimal">
<li>The first step is to prepare a map showing the spatial distribution of the sample locations and the corresponding soil property information, e.g. soil organic matter and environmental properties. The first can be achieved as outlined in section <a href="covariates.html#overlay-covariates-and-spatial-data">Overlay covariates and spatial data</a>. The overlaying operation can be performed in R, ArcGIS, SAGA GIS or QGIS.</li>
<li>The essential part of multiple regression analysis is to build a regression model by using the environmental predictors. After extracting the values of explanatory maps and target variables into the single table, we can now start fitting multiple regression model using the table that contains data from dependent variable and predictors.</li>
<li>In particular cases, stepwise multiple linear regression (SMLR) can be used to eliminate insignificant predictors. Stepwise multiple linear regression (SMLR) usually selects predictors that have the strongest linear correlations with the target variable, which reflect the highest predictive capacity.</li>
<li>Kriging of the residuals (prediction errors): In the regression-kriging, the regression model detrends the data, produces the residuals which we need to krige and to be added to the regression model predictions.</li>
</ol>
</blockquote>
</div>
<div id="interpret-the-key-results-of-multiple-regression" class="section level3">
<h3><span class="header-section-number">6.2.5</span> Interpret the Key Results of Multiple Regression</h3>
<p>Regression analysis generates an equation to describe the statistical relationship between one or more predictor variables and the response variable. he r-squared, p-values and coefficients that appear in the output for linear regression analysis must also be reviewed. Before accepting the result of a linear regression it is important to evaluate its suitability at explaining the data. One of the many ways to do this is to visually examine the residuals. If the model is appropriate, then the residual errors should be random and normally distributed.</p>
<p><strong>R-sq</strong></p>
<p>R2 is the percentage of variation in the response that is explained by the model. The higher the R2 Value, the better the model fits your data. R-squared is always between <span class="math inline">\(0\%\)</span> and <span class="math inline">\(100\%\)</span>. R2 usually increases when additional predictors are added in the model.</p>
<p><strong>P Values</strong></p>
<p>To determine whether the association between the dependent and each predictor in the model is statistically significant, compare the p-value for the term to your significance level to assess the null hypothesis. Usually, a significance level of 0.05 works well.
P-value ≤ significance level: The relationship is statistically significant. If the p-value is less than or equal to the significance level, we can conclude that there is a statistically significant relationship between the dependent variable and the predictor.
P-value &gt; significance level: The relationship is not statistically significant, If the p-value is greater than the significance level, you cannot conclude that there is a statistically significant relationship between the dependent variable and the predictor. You may want to refit the model without the predictor.</p>
<p><strong>Residuals</strong></p>
<p>We can plot the residuals which can help us determine whether the model is adequate and meets the assumptions of the analysis. If the model is appropriate, then the residual errors should be random and normally distributed. We can plot residuals versus fits to verify the assumption that the residuals are randomly distributed and have constant variance. Ideally, the points should fall randomly on both sides of “0”, with no recognizable patterns in the points.</p>
<p>The diagnostic plots for the model should be evaluated to confirm if all the assumptions of linear regression are met. After the abovementioned assumptions are validated, we can proceed with making the prediction map using the model with significant predictors.</p>
</div>
<div id="using-the-results-of-a-regression-analysis-to-make-predictions" class="section level3">
<h3><span class="header-section-number">6.2.6</span> Using the Results of a Regression Analysis to Make Predictions</h3>
<p>The purpose of a regression analysis, of course, is to develop a model that can be used to make the prediction of a dependent variable. The derived regression equation is to be used to create the prediction map for dependent variable.</p>
<blockquote>
<p>Raster calculation can be easily performed using “raster” Package in R or ArcGIS using the ”Raster Calculator” tool (It’s called Map Algebra in the prior versions).</p>
</blockquote>
</div>
<div id="technical-steps---regression-kriging" class="section level3">
<h3><span class="header-section-number">6.2.7</span> Technical Steps - Regression Kriging</h3>
<p><strong>Requirements</strong>
The following are required to implement Regression Kriging in R</p>
<ul>
<li><p><a href="Latest%20version%20of%20R%20software,%20network%20connection%20and%20sufficient%20RAM,%20storage%20capacity">Setting-up the Software Environment</a></p></li>
<li><p><a href="Latest%20version%20of%20RStudio">Obtaining and Installing R Studio</a></p></li>
<li><p><a href="R%20packages">R Packages</a></p></li>
<li><p><a href="Point%20Dataset">Preparation of local soil property data</a></p></li>
<li><p><a href="Environmental%20predictors">Preparation of spatial covariates</a></p></li>
<li><p><a href="Relief%20(e.g.%20DEM,%20Slope,%20TWI)">DEM-derived covariates</a></p></li>
<li><p><a href="Organism%20map%20(e.g.%20land%20use,%20NDVI,%20land%20cover)">Land cover/Land use</a></p></li>
<li><p><a href="Climate%20Data%20(e.g.%20mean%20precipitation,%20mean%20temperature)">Climate</a></p></li>
<li><p><a href="Parent%20material%20(parent%20material,%20geology)">Parent material</a></p></li>
</ul>
<div id="setting-working-space-and-initial-steps" class="section level4">
<h4><span class="header-section-number">6.2.7.1</span> Setting Working Space and Initial Steps</h4>
<p>One of the first steps should be setting our working directory. If you read/write files from/ to disk, this takes place in the working directory. If we don’t set the working directory we could easily write files to an undesirable file location. The following example shows how to set the working directory in R to our folder which contains data for the study area (point data, covariates).</p>
<p>Note that we must use the forward slash / or double backslash \\ in R! Single backslash \ will not work. Now we can check if the working directory has been correctly set by using the function:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="kw">getwd</span>()</a></code></pre></div>
</div>
<div id="data-preparation-1" class="section level4">
<h4><span class="header-section-number">6.2.7.2</span> Data Preparation</h4>
<p><strong>Point Dataset</strong></p>
<p>We previously applied spline function to produce continuous soil information to a given soil depth (0-30 cm) in the section 2.4. Spline function basically imports soil profile data (including instances where layers are not contiguous), fits it to a mass-preserving spline and outputs attribute means for a given depth. The output file should contain profile id, upper (surface) and lower depth (30cm), estimated value for the selected soil attribute (Value) and tmse (estimated mean squared error of the spline). If you used the Spline Tool V2, the coordinates were not kept in the output file. The coordinates should be added back in the data table. You can use Profile IDs to add the X, Y columns back. Once your point dataset is ready, copy this table into your working directory as a .csv file.</p>
<p><strong>Environmental Predictors (Covariates)</strong></p>
<p>In the Chapter <a href="covariates.html#covariates">5</a>, we presented and prepared several global and continental datasets. In addition to these datasets, numerous covariate layers have been prepared by ISRIC for the GSOC Map project. These are GIS raster layers of various biophysical earth surface properties for each country in the world. Some of these layers will be used as predictors in this section. Please download the covariates for your own study area from GSOCMap Data Repository as explained in Section <a href="covariates.html#GSOC-data-repo">5.6</a>.</p>
<p>In section <a href="covariates.html#overlay-soil-covariates">5.9</a>, a table with the points values after data preparation and the values of our spatial predictors was prepared. This step involves loading this table.</p>
<p>Now we will import our point dataset using <code>read.csv()</code> function. The easiest way to create a data frame is to read in data from a file—this is done using the function read.csv, which works with comma delimited files. Data can be read in from other file formats as well, using different functions, but read.csv is the most commonly used approach. R is very flexible in how it reads in data from text files (<code>read.table</code>, <code>read.csv</code>, <code>read.csv2</code>, <code>read.delim</code>, <code>read.delim2</code>). Please type <code>?read.table()</code> for help.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="co"># load data</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2">dat &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/MKD_RegMatrix.csv&quot;</span>)</a>
<a class="sourceLine" id="cb50-3" data-line-number="3"></a>
<a class="sourceLine" id="cb50-4" data-line-number="4">dat<span class="op">$</span>LCEE10 &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat<span class="op">$</span>LCEE10)</a>
<a class="sourceLine" id="cb50-5" data-line-number="5">dat<span class="op">$</span>soilmap &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat<span class="op">$</span>soilmap)</a>
<a class="sourceLine" id="cb50-6" data-line-number="6"></a>
<a class="sourceLine" id="cb50-7" data-line-number="7"><span class="co"># explore the data structure</span></a>
<a class="sourceLine" id="cb50-8" data-line-number="8"><span class="kw">str</span>(dat)</a></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    2893 obs. of  22 variables:
##  $ id      : Factor w/ 2893 levels &quot;P0003&quot;,&quot;P0004&quot;,..: 1 2 3 4 ..
##  $ Y       : num  42 42 42.1 42 42 ...
##  $ X       : num  20.8 20.8 20.8 20.9 20.9 ...
##  $ SOC     : num  26.38 24.56 3.94 3.26 2.29 ...
##  $ BLD     : num  0.73 0.896 1.296 1.345 1.413 ...
##  $ CRFVOL  : num  8 6.31 31.88 21.71 14.46 ...
##  $ OCSKGM  : num  5.32 6.18 1.04 1.03 0.83 ...
##  $ meaERROR: num  2.16 2.63 2.65 3.16 3.63 2.83 2.94 2.4 2.77 2..
##  $ B04CHE3 : num  574 574 693 743 744 ...
##  $ B07CHE3 : num  38.5 38.5 42.1 43.7 43.7 ...
##  $ B13CHE3 : num  111.6 111.6 99.8 118.1 121 ...
##  $ B14CHE3 : num  59.2 59.2 42.4 39.9 38.7 ...
##  $ DEMENV5 : int  2327 2327 1243 1120 1098 1492 1413 1899 1731 ..
##  $ LCEE10  : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 2 1 2 2 2 ..
##  $ PRSCHE3 : num  998 998 780 839 844 ...
##  $ SLPMRG5 : int  13 13 6 25 30 24 15 25 20 37 ...
##  $ TMDMOD3 : int  282 282 285 288 289 287 286 284 287 281 ...
##  $ TMNMOD3 : int  272 272 277 279 279 277 277 272 274 272 ...
##  $ TWIMRG5 : int  61 61 81 66 65 72 68 60 65 60 ...
##  $ VBFMRG5 : int  0 0 14 0 0 0 0 0 0 0 ...
##  $ VDPMRG5 : int  311 311 10048 1963 -173 -400 -9 -1867 -1139 -..
##  $ soilmap : Factor w/ 20 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 6 6 14 3 3..</code></pre>
<p>Since we will be working with spatial data we need to define the coordinates for the imported data. Using the coordinates() function from the sp package we can define the columns in the data frame to refer to spatial coordinates—here the coordinates are listed in columns X and Y.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="kw">library</span>(sp)</a>
<a class="sourceLine" id="cb52-2" data-line-number="2"></a>
<a class="sourceLine" id="cb52-3" data-line-number="3"><span class="co"># Promote to spatialPointsDataFrame</span></a>
<a class="sourceLine" id="cb52-4" data-line-number="4"><span class="kw">coordinates</span>(dat) &lt;-<span class="st"> </span><span class="er">~</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>Y</a>
<a class="sourceLine" id="cb52-5" data-line-number="5"></a>
<a class="sourceLine" id="cb52-6" data-line-number="6"><span class="kw">class</span>(dat)</a></code></pre></div>
<pre><code>## [1] &quot;SpatialPointsDataFrame&quot;
## attr(,&quot;package&quot;)
## [1] &quot;sp&quot;</code></pre>
<p>SpatialPointsDataFrame structure is essentially the same data frame, except that additional “spatial” elements have been added or partitioned into slots. Some important ones being the bounding box (sort of like the spatial extent of the data), and the coordinate reference system proj4string(), which we need to define for the sample dataset. To define the CRS, we must know where our data are from, and what was the corresponding CRS used when recording the spatial information in the field. For this data set the CRS used was: WGS84 (EPSG:4326).</p>
<p>To clearly tell R this information we define the CRS which describes a reference system in a way understood by the <a href="http://trac.osgeo.org/proj/">PROJ.4 projection library</a>. An interface to the PROJ.4 library is available in the rgdal package. Alternative to using Proj4 character strings, we can use the corresponding yet simpler EPSG code (European Petroleum Survey Group). rgdal also recognizes these codes. If you are unsure of the Proj4 or EPSG code for the spatial data that you have, but know the CRS, you should consult <a href="http://spatialreference.org/" class="uri">http://spatialreference.org/</a> for assistance.</p>
<p>Please also note that, when working with spatial data, it’s very important that the CRS (coordinate reference system) of the point data and covariates are the same.</p>
<p>Now, we will define our CRS:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb54-1" data-line-number="1">dat<span class="op">@</span>proj4string &lt;-<span class="st"> </span><span class="kw">CRS</span>(<span class="dt">projargs =</span> <span class="st">&quot;+init=epsg:4326&quot;</span>)</a>
<a class="sourceLine" id="cb54-2" data-line-number="2"></a>
<a class="sourceLine" id="cb54-3" data-line-number="3">dat<span class="op">@</span>proj4string</a></code></pre></div>
<pre><code>## CRS arguments:
##  +init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs
## +ellps=WGS84 +towgs84=0,0,0</code></pre>
<p>Now we will import the covariates. When the covariate layers are in common resolution and extent, rather than working with individual rasters it is better to stack them all into a single R object. In this example we use 13 covariates from the GSOCMap Data Repository and a rasterized version of the soil type map. The rasterization of vectorial data was covered in <a href="covariates.html#technical-steps---rasterizing-a-vector-layer-in-r">Technical Steps - Rasterizing a vector layer in R</a>. The file containing all the covariates was prepared at the end of chapter <a href="covariates.html#covariates">5</a>.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="kw">load</span>(<span class="dt">file =</span> <span class="st">&quot;covariates.RData&quot;</span>)</a>
<a class="sourceLine" id="cb56-2" data-line-number="2"></a>
<a class="sourceLine" id="cb56-3" data-line-number="3"><span class="kw">names</span>(covs)</a></code></pre></div>
<pre><code>##  [1] &quot;B04CHE3&quot; &quot;B07CHE3&quot; &quot;B13CHE3&quot; &quot;B14CHE3&quot; &quot;DEMENV5&quot; &quot;LCEE10&quot; 
##  [7] &quot;PRSCHE3&quot; &quot;SLPMRG5&quot; &quot;TMDMOD3&quot; &quot;TMNMOD3&quot; &quot;TWIMRG5&quot; &quot;VBFMRG5&quot;
## [13] &quot;VDPMRG5&quot; &quot;soilmap&quot;</code></pre>
</div>
<div id="fitting-the-mlr-model" class="section level4">
<h4><span class="header-section-number">6.2.7.3</span> Fitting the MLR Model</h4>
<p><strong>Fitting the MLR Model</strong></p>
<p>It would be better to progress with a data frame of just the data and covariates required for the modelling. In this case, we will subset the columns SOC, the covariates and the the spatial coordinates (X and Y).</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" data-line-number="1">datdf &lt;-<span class="st"> </span>dat<span class="op">@</span>data</a>
<a class="sourceLine" id="cb58-2" data-line-number="2"></a>
<a class="sourceLine" id="cb58-3" data-line-number="3">datdf &lt;-<span class="st"> </span>datdf[, <span class="kw">c</span>(<span class="st">&quot;OCSKGM&quot;</span>, <span class="kw">names</span>(covs))]</a></code></pre></div>
<p>Let’s fit a linear model using with all available covariates.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="co"># Fit a multiple linear regression model between the log transformed</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2"><span class="co"># values of OCS and the top 20 covariates</span></a>
<a class="sourceLine" id="cb59-3" data-line-number="3">model.MLR &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(OCSKGM) <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> datdf)</a></code></pre></div>
<p>From the summary of our fitted model (model.MLR) above, it seems only a few of the covariates are significant in describing the spatial variation of the target variable. To determine the most predictive model we can run a stepwise regression using the <code>step()</code> function. With this function we can also specify the mode of stepwise search, can be one of “both”, “backward”, or “forward”.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb60-1" data-line-number="1">## stepwise variable selection</a>
<a class="sourceLine" id="cb60-2" data-line-number="2">model.MLR.step &lt;-<span class="st"> </span><span class="kw">step</span>(model.MLR, <span class="dt">direction=</span><span class="st">&quot;both&quot;</span>)</a></code></pre></div>
<p>Comparing the summary of both the full and stepwise linear models, there is very little difference between the models such as the R2. Both models explain about <span class="math inline">\(23\%\)</span> of variation of the target variable. Obviously the “full” model is more complex as it has more parameters than the “step” model.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb61-1" data-line-number="1"><span class="co"># summary and anova of the new model using stepwise covariates</span></a>
<a class="sourceLine" id="cb61-2" data-line-number="2"><span class="co"># selection</span></a>
<a class="sourceLine" id="cb61-3" data-line-number="3"><span class="kw">summary</span>(model.MLR.step)</a>
<a class="sourceLine" id="cb61-4" data-line-number="4"><span class="kw">anova</span>(model.MLR.step)</a></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = log(OCSKGM) ~ B04CHE3 + B07CHE3 + B13CHE3 + LCEE10 + 
##     PRSCHE3 + SLPMRG5 + TMDMOD3 + TMNMOD3 + VBFMRG5 + VDPMRG5 + 
##     soilmap, data = datdf)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -4.3134 -0.2651  0.0307  0.3119  1.9243 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  3.230e+00  2.860e+00   1.129 0.258828    
## B04CHE3     -5.357e-03  1.117e-03  -4.796 1.70e-06 ***
## B07CHE3      9.331e-02  3.387e-02   2.755 0.005912 ** 
## B13CHE3     -6.649e-03  1.657e-03  -4.012 6.17e-05 ***
## LCEE102      1.590e-01  3.397e-02   4.681 2.98e-06 ***
## LCEE103      1.521e-01  5.575e-02   2.728 0.006409 ** 
## LCEE104     -3.032e-04  4.456e-02  -0.007 0.994572    
## PRSCHE3      1.122e-03  3.140e-04   3.574 0.000357 ***
## SLPMRG5     -3.376e-03  1.528e-03  -2.209 0.027248 *  
## TMDMOD3     -4.389e-02  7.352e-03  -5.970 2.66e-09 ***
## TMNMOD3      3.454e-02  9.903e-03   3.488 0.000494 ***
## VBFMRG5      3.882e-04  9.807e-05   3.958 7.74e-05 ***
## VDPMRG5     -2.479e-05  4.103e-06  -6.042 1.72e-09 ***
## soilmap2    -4.129e-01  4.939e-01  -0.836 0.403257    
## soilmap3    -2.649e-01  4.871e-01  -0.544 0.586551    
## soilmap4    -2.539e-01  4.934e-01  -0.514 0.606971    
## soilmap5    -2.766e-01  5.253e-01  -0.527 0.598445    
## soilmap6     1.062e-01  4.890e-01   0.217 0.828124    
## soilmap7     2.526e-01  4.906e-01   0.515 0.606657    
## soilmap8    -2.506e-01  4.897e-01  -0.512 0.608928    
## soilmap9    -3.039e-01  4.864e-01  -0.625 0.532178    
## soilmap10   -1.109e-01  4.879e-01  -0.227 0.820285    
## soilmap11   -4.220e-01  4.922e-01  -0.857 0.391286    
## soilmap12   -2.639e-01  4.869e-01  -0.542 0.587848    
## soilmap13    1.443e-02  5.957e-01   0.024 0.980676    
## soilmap14   -2.802e-01  4.875e-01  -0.575 0.565515    
## soilmap15   -1.722e-01  4.923e-01  -0.350 0.726563    
## soilmap16   -3.712e-01  4.878e-01  -0.761 0.446815    
## soilmap17   -1.595e-01  4.885e-01  -0.327 0.744023    
## soilmap18   -1.048e-01  4.876e-01  -0.215 0.829880    
## soilmap19   -5.366e-01  5.203e-01  -1.031 0.302476    
## soilmap20   -2.760e-01  4.892e-01  -0.564 0.572690    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.4854 on 2861 degrees of freedom
## Multiple R-squared:  0.2371, Adjusted R-squared:  0.2289 
## F-statistic: 28.69 on 31 and 2861 DF,  p-value: &lt; 2.2e-16
## 
## Analysis of Variance Table
## 
## Response: log(OCSKGM)
##             Df Sum Sq Mean Sq  F value    Pr(&gt;F)    
## B04CHE3      1 103.21 103.208 438.1270 &lt; 2.2e-16 ***
## B07CHE3      1   1.50   1.504   6.3837 0.0115705 *  
## B13CHE3      1   0.22   0.218   0.9235 0.3366300    
## LCEE10       3  30.99  10.330  43.8518 &lt; 2.2e-16 ***
## PRSCHE3      1   6.26   6.262  26.5812 2.699e-07 ***
## SLPMRG5      1   2.95   2.948  12.5150 0.0004101 ***
## TMDMOD3      1   2.29   2.293   9.7346 0.0018264 ** 
## TMNMOD3      1   0.89   0.887   3.7674 0.0523590 .  
## VBFMRG5      1   9.63   9.630  40.8803 1.884e-10 ***
## VDPMRG5      1  10.03  10.029  42.5739 8.020e-11 ***
## soilmap     19  41.51   2.185   9.2738 &lt; 2.2e-16 ***
## Residuals 2861 673.95   0.236                       
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>In those two models above, we used all available points. It is important to test the performance of a model based upon an external validation. Lets fit a new model using a random subset of the available data. We will sample <span class="math inline">\(70\%\)</span> of the SOC data for the model calibration data set.</p>
<p>Now we can evaluate the test statistics of the calibration model using the goof() function from the “ithir” package.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb63-1" data-line-number="1"><span class="co"># graphical diagnosis of the regression analysis</span></a>
<a class="sourceLine" id="cb63-2" data-line-number="2"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>))</a>
<a class="sourceLine" id="cb63-3" data-line-number="3"><span class="kw">plot</span>(model.MLR.step)</a></code></pre></div>
<pre><code>## Warning: not plotting observations with leverage one:
##   334

## Warning: not plotting observations with leverage one:
##   334</code></pre>
<p><img src="SOCMapping_files/figure-html4/unnamed-chunk-35-1.png" width="672" /></p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb65-1" data-line-number="1"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</a></code></pre></div>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb66-1" data-line-number="1"><span class="co"># collinearity test using variance inflation factors</span></a>
<a class="sourceLine" id="cb66-2" data-line-number="2"><span class="kw">library</span>(car)</a>
<a class="sourceLine" id="cb66-3" data-line-number="3"><span class="kw">vif</span>(model.MLR.step)</a></code></pre></div>
<pre><code>##              GVIF Df GVIF^(1/(2*Df))
## B04CHE3 16.484781  1        4.060145
## B07CHE3 15.462738  1        3.932269
## B13CHE3 14.401494  1        3.794930
## LCEE10   3.325104  3        1.221708
## PRSCHE3 19.728470  1        4.441674
## SLPMRG5  3.152262  1        1.775461
## TMDMOD3  5.990845  1        2.447620
## TMNMOD3  3.409255  1        1.846417
## VBFMRG5  3.990507  1        1.997625
## VDPMRG5  1.678773  1        1.295675
## soilmap 14.651600 19        1.073201</code></pre>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb68-1" data-line-number="1"><span class="co"># problematic covariates should have sqrt(VIF) &gt; 2</span></a>
<a class="sourceLine" id="cb68-2" data-line-number="2"><span class="kw">sqrt</span>(<span class="kw">vif</span>(model.MLR.step))</a></code></pre></div>
<pre><code>##             GVIF       Df GVIF^(1/(2*Df))
## B04CHE3 4.060145 1.000000        2.014980
## B07CHE3 3.932269 1.000000        1.982995
## B13CHE3 3.794930 1.000000        1.948058
## LCEE10  1.823487 1.732051        1.105309
## PRSCHE3 4.441674 1.000000        2.107528
## SLPMRG5 1.775461 1.000000        1.332464
## TMDMOD3 2.447620 1.000000        1.564487
## TMNMOD3 1.846417 1.000000        1.358829
## VBFMRG5 1.997625 1.000000        1.413374
## VDPMRG5 1.295675 1.000000        1.138277
## soilmap 3.827741 4.358899        1.035954</code></pre>
<p>colinear: Temperature seasonality at 1 km (B04CHE3) and Temperature Annual Range [°C] at 1 km (B07CHE3)</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb70-1" data-line-number="1"><span class="co"># Removing B07CHE3 from the stepwise model:</span></a>
<a class="sourceLine" id="cb70-2" data-line-number="2">model.MLR.step &lt;-<span class="st"> </span><span class="kw">update</span>(model.MLR.step, . <span class="op">~</span><span class="st"> </span>. <span class="op">-</span><span class="st"> </span>B07CHE3)</a>
<a class="sourceLine" id="cb70-3" data-line-number="3"></a>
<a class="sourceLine" id="cb70-4" data-line-number="4"><span class="co"># Test the vif again:</span></a>
<a class="sourceLine" id="cb70-5" data-line-number="5"><span class="kw">sqrt</span>(<span class="kw">vif</span>(model.MLR.step))</a></code></pre></div>
<pre><code>##             GVIF       Df GVIF^(1/(2*Df))
## B04CHE3 2.197901 1.000000        1.482532
## B13CHE3 3.624337 1.000000        1.903769
## LCEE10  1.810078 1.732051        1.103950
## PRSCHE3 4.406953 1.000000        2.099274
## SLPMRG5 1.773036 1.000000        1.331554
## TMDMOD3 2.400873 1.000000        1.549475
## TMNMOD3 1.772071 1.000000        1.331191
## VBFMRG5 1.982233 1.000000        1.407918
## VDPMRG5 1.294899 1.000000        1.137936
## soilmap 3.603391 4.358899        1.034309</code></pre>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb72-1" data-line-number="1"><span class="co"># summary  of the new model using stepwise covariates selection</span></a>
<a class="sourceLine" id="cb72-2" data-line-number="2"><span class="kw">summary</span>(model.MLR.step)</a></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = log(OCSKGM) ~ B04CHE3 + B13CHE3 + LCEE10 + PRSCHE3 + 
##     SLPMRG5 + TMDMOD3 + TMNMOD3 + VBFMRG5 + VDPMRG5 + soilmap, 
##     data = datdf)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -4.3181 -0.2631  0.0306  0.3143  1.9783 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  6.390e+00  2.623e+00   2.436 0.014895 *  
## B04CHE3     -2.770e-03  6.053e-04  -4.576 4.94e-06 ***
## B13CHE3     -8.002e-03  1.585e-03  -5.050 4.69e-07 ***
## LCEE102      1.558e-01  3.399e-02   4.585 4.74e-06 ***
## LCEE103      1.386e-01  5.560e-02   2.493 0.012712 *  
## LCEE104      9.270e-03  4.448e-02   0.208 0.834933    
## PRSCHE3      1.230e-03  3.119e-04   3.944 8.19e-05 ***
## SLPMRG5     -3.156e-03  1.528e-03  -2.066 0.038955 *  
## TMDMOD3     -3.995e-02  7.220e-03  -5.534 3.42e-08 ***
## TMNMOD3      2.688e-02  9.515e-03   2.825 0.004763 ** 
## VBFMRG5      3.547e-04  9.742e-05   3.641 0.000277 ***
## VDPMRG5     -2.440e-05  4.106e-06  -5.943 3.13e-09 ***
## soilmap2    -4.336e-01  4.945e-01  -0.877 0.380640    
## soilmap3    -2.546e-01  4.876e-01  -0.522 0.601552    
## soilmap4    -2.463e-01  4.940e-01  -0.499 0.618138    
## soilmap5    -2.723e-01  5.259e-01  -0.518 0.604665    
## soilmap6     1.027e-01  4.896e-01   0.210 0.833848    
## soilmap7     2.436e-01  4.911e-01   0.496 0.619906    
## soilmap8    -2.507e-01  4.903e-01  -0.511 0.609153    
## soilmap9    -3.106e-01  4.869e-01  -0.638 0.523560    
## soilmap10   -1.115e-01  4.885e-01  -0.228 0.819429    
## soilmap11   -4.243e-01  4.928e-01  -0.861 0.389231    
## soilmap12   -2.610e-01  4.874e-01  -0.535 0.592359    
## soilmap13   -2.647e-02  5.962e-01  -0.044 0.964592    
## soilmap14   -2.923e-01  4.881e-01  -0.599 0.549341    
## soilmap15   -1.552e-01  4.929e-01  -0.315 0.752799    
## soilmap16   -3.813e-01  4.884e-01  -0.781 0.435044    
## soilmap17   -1.622e-01  4.891e-01  -0.332 0.740161    
## soilmap18   -8.361e-02  4.881e-01  -0.171 0.864003    
## soilmap19   -5.348e-01  5.209e-01  -1.027 0.304650    
## soilmap20   -2.693e-01  4.898e-01  -0.550 0.582478    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.4859 on 2862 degrees of freedom
## Multiple R-squared:  0.2351, Adjusted R-squared:  0.2271 
## F-statistic: 29.32 on 30 and 2862 DF,  p-value: &lt; 2.2e-16</code></pre>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb74-1" data-line-number="1"><span class="co"># outlier test using the Bonferroni test</span></a>
<a class="sourceLine" id="cb74-2" data-line-number="2"><span class="kw">outlierTest</span>(model.MLR.step)</a></code></pre></div>
<pre><code>##       rstudent unadjusted p-value Bonferonni p
## 789  -9.022864         3.2803e-19   9.4900e-16
## 1968 -6.956637         4.3022e-12   1.2446e-08
## 697  -6.448336         1.3228e-10   3.8268e-07
## 702  -4.948180         7.9248e-07   2.2926e-03
## 217  -4.750215         2.1322e-06   6.1684e-03</code></pre>
</div>
<div id="prediction-and-residual-kriging" class="section level4">
<h4><span class="header-section-number">6.2.7.4</span> Prediction and Residual Kriging</h4>
<p>Now we can make the predictions and plot the map. We can use either our DSM_data table for covariate values or <code>covs</code> object for making our prediction. Using stack avoids the step of arranging all covariates into table format. If multiple rasters are being used, it is necessary to have them arranged as a rasterStack object. This is useful as it also ensures all the rasters are of the same extent and resolution. Here we can use the raster predict function such as below using the covStack raster stack as we created in the Step 3.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb76-1" data-line-number="1"><span class="co"># Project point data.</span></a>
<a class="sourceLine" id="cb76-2" data-line-number="2">dat &lt;-<span class="st"> </span><span class="kw">spTransform</span>(dat, <span class="kw">CRS</span>(<span class="st">&quot;+init=epsg:6204&quot;</span>))</a>
<a class="sourceLine" id="cb76-3" data-line-number="3"></a>
<a class="sourceLine" id="cb76-4" data-line-number="4"><span class="co"># project covariates to VN-2000 UTM 48N</span></a>
<a class="sourceLine" id="cb76-5" data-line-number="5">covs &lt;-<span class="st"> </span><span class="kw">projectRaster</span>(covs, <span class="dt">crs =</span> <span class="kw">CRS</span>(<span class="st">&quot;+init=epsg:6204&quot;</span>),</a>
<a class="sourceLine" id="cb76-6" data-line-number="6">                      <span class="dt">method=</span><span class="st">&#39;ngb&#39;</span>)</a>
<a class="sourceLine" id="cb76-7" data-line-number="7"></a>
<a class="sourceLine" id="cb76-8" data-line-number="8">covs<span class="op">$</span>LCEE10 &lt;-<span class="st"> </span><span class="kw">as.factor</span>(covs<span class="op">$</span>LCEE10)</a>
<a class="sourceLine" id="cb76-9" data-line-number="9">covs<span class="op">$</span>soilmap &lt;-<span class="st"> </span><span class="kw">as.factor</span>(covs<span class="op">$</span>soilmap)</a></code></pre></div>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb77-1" data-line-number="1"><span class="co"># Promote covariates to spatial grid dataframe. Takes some time and</span></a>
<a class="sourceLine" id="cb77-2" data-line-number="2"><span class="co"># a lot of memory!</span></a>
<a class="sourceLine" id="cb77-3" data-line-number="3">covs.sp &lt;-<span class="st"> </span><span class="kw">as</span>(covs, <span class="st">&quot;SpatialGridDataFrame&quot;</span>)</a>
<a class="sourceLine" id="cb77-4" data-line-number="4">covs.sp<span class="op">$</span>LCEE10 &lt;-<span class="st"> </span><span class="kw">as.factor</span>(covs.sp<span class="op">$</span>LCEE10)</a>
<a class="sourceLine" id="cb77-5" data-line-number="5">covs.sp<span class="op">$</span>soilmap &lt;-<span class="st"> </span><span class="kw">as.factor</span>(covs.sp<span class="op">$</span>soilmap)</a></code></pre></div>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb78-1" data-line-number="1">### RK model</a>
<a class="sourceLine" id="cb78-2" data-line-number="2"><span class="kw">library</span>(automap)</a>
<a class="sourceLine" id="cb78-3" data-line-number="3"></a>
<a class="sourceLine" id="cb78-4" data-line-number="4"></a>
<a class="sourceLine" id="cb78-5" data-line-number="5">## Run regression kriging prediction. This step can take hours...!</a>
<a class="sourceLine" id="cb78-6" data-line-number="6">OCS.krige &lt;-<span class="st"> </span><span class="kw">autoKrige</span>(<span class="dt">formula =</span></a>
<a class="sourceLine" id="cb78-7" data-line-number="7">                         <span class="kw">as.formula</span>(model.MLR.step<span class="op">$</span>call<span class="op">$</span>formula),</a>
<a class="sourceLine" id="cb78-8" data-line-number="8">                       <span class="dt">input_data =</span> dat,</a>
<a class="sourceLine" id="cb78-9" data-line-number="9">                       <span class="dt">new_data =</span> covs.sp,</a>
<a class="sourceLine" id="cb78-10" data-line-number="10">                       <span class="dt">verbose =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb78-11" data-line-number="11">                       <span class="dt">block =</span> <span class="kw">c</span>(<span class="dv">1000</span>, <span class="dv">1000</span>))</a>
<a class="sourceLine" id="cb78-12" data-line-number="12"></a>
<a class="sourceLine" id="cb78-13" data-line-number="13">OCS.krige</a></code></pre></div>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb79-1" data-line-number="1">## Convert prediction and standard deviation to rasters</a>
<a class="sourceLine" id="cb79-2" data-line-number="2">## And back-tansform the vlaues</a>
<a class="sourceLine" id="cb79-3" data-line-number="3">RKprediction &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="kw">raster</span>(OCS.krige<span class="op">$</span>krige_output[<span class="dv">1</span>]))</a>
<a class="sourceLine" id="cb79-4" data-line-number="4">RKpredsd &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="kw">raster</span>(OCS.krige<span class="op">$</span>krige_output[<span class="dv">3</span>]))</a></code></pre></div>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb80-1" data-line-number="1"><span class="kw">plot</span>(RKprediction)</a></code></pre></div>
<p><img src="SOCMapping_files/figure-html4/unnamed-chunk-43-1.png" width="672" /></p>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb81-1" data-line-number="1"><span class="kw">plot</span>(RKpredsd)</a></code></pre></div>
<p><img src="SOCMapping_files/figure-html4/unnamed-chunk-44-1.png" width="672" /></p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb82-1" data-line-number="1">## Save results as tif files</a>
<a class="sourceLine" id="cb82-2" data-line-number="2"><span class="kw">writeRaster</span>(RKprediction, <span class="dt">filename =</span> <span class="st">&quot;results/MKD_OCSKGM_RK.tif&quot;</span>,</a>
<a class="sourceLine" id="cb82-3" data-line-number="3">            <span class="dt">overwrite =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb82-4" data-line-number="4"></a>
<a class="sourceLine" id="cb82-5" data-line-number="5"><span class="kw">writeRaster</span>(RKpredsd, <span class="dt">filename =</span> <span class="st">&quot;results/MKD_OCSKGM_RKpredsd.tif&quot;</span>,</a>
<a class="sourceLine" id="cb82-6" data-line-number="6">            <span class="dt">overwrite =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb83-1" data-line-number="1"><span class="co"># save the model</span></a>
<a class="sourceLine" id="cb83-2" data-line-number="2"><span class="kw">saveRDS</span>(model.MLR.step, <span class="dt">file=</span><span class="st">&quot;results/RKmodel.Rds&quot;</span>)</a></code></pre></div>


</div>
</div>
</div>
<div id="data-mining-random-forest" class="section level2">
<h2><span class="header-section-number">6.3</span> Data mining: Random Forest</h2>
<p><em>M Guevara, C Thine, GF Olmedo, RR Vargas</em></p>
<div id="overview-2" class="section level3">
<h3><span class="header-section-number">6.3.1</span> Overview</h3>
<p>Data mining uses different forms of statistics, such as machine learning, to explore data matrices for a particular situation, from specific information sources and with a specific objective. Data mining is used on digital soil mapping frameworks to generate spatial and temporal predictions of soil properties or classes in places where no information is available. Under a data mining-based digital soil mapping framework, the exploration of statistical relationships (lineal and non-lineal) between soil observational data and soil environmental predictors is generally performed by the means of machine learning. Machine learning methods represent a branch of statistics that can be used to automatically extract information from available data, including the non-linear and hidden relationships of high dimensional spaces or hyper-volumes of information when high performance or distributed computing resources are available. Machine learning methods do not rely on statistical assumptions about the spatial structure of soil variability or the empirical relationship of soil available data and its environmental predictors. Therefore machine learning methods are also suitable for digital soil mapping under limited and sparse scenarios of data availability, although in practice the statistical performance of machine learning (or any statistical method) is reduced by a low representativeness of a soil property or class in the statistical space given available data. Machine learning methods can be used for (supervised and unsupervised) regression (e.g., predicting soil organic carbon) or classification (e.g., predicting soil type classes) on digital soil mapping. Machine learning methods can be roughly divided in four main groups: linear-based (e.g., multiple linear regression), kernel-based (e.g., kernel weighted nearest neighbors or support vector machines), probabilistic-based (e.g., Bayesian statistics) and tree-based (e.g., classification and regression trees).</p>
<p>Random forest is a type of machine learning for uncovering statistical relationship between a dependent variable (e.g. soil property) and its predictors. It belongs to the decision-tree class of models in which the models (also known as classifiers) are like trees with stem, many branches, and leaves. The leaves are the prediction outcomes (final decisions) that flow from the roots through the stem to the branches . The decision tree model recursively splits the data into final uniform groups (classes) or unique values based on a set of rules. In random forest, there are many decision trees and each tree recursively splits randomly selected sub-samples from the data (Figure 6.14). The name random forest originates from the fact that the original data is first randomly split into sub-samples, and many decision trees (or forest) are used to model the sub-samples.</p>
<div class="figure">
<img src="images/randomForestconcept.png" alt="The concept of Random Forest and Decision Trees" />
<p class="caption">The concept of Random Forest and Decision Trees</p>
</div>
<p>Random forest has been tested by many researchers in digital soil mapping (see for example <span class="citation">Poggio, Gimona, and Brewer (<a href="#ref-poggio2013regional">2013</a>)</span>; <span class="citation">Rad et al. (<a href="#ref-rad2014updating">2014</a>)</span>, Hengl et al., 2014; Bonfatti et al., 2016; Hengl et al., 2017; Guevara et al., 2018 and references therein). Specifically in soil carbon mapping, there are authors who have shown that it holds a lot of promises when compared to other prediction models. They have demonstrated that it has a relatively improved accurate spatial prediction, is a better approach to dealing with model over-fitting and data noise, and is capable of handling both dimensionally linear and nonlinear relationships <span class="citation">(Wiesmeier et al. <a href="#ref-wiesmeier2011digital">2011</a>)</span>. Furthermore, with the advent of open-source platforms and freely downloadable ancillary data, the application of random forest and other such models has increasingly become more appealing in digital soil mapping.</p>
</div>
<div id="random-forests" class="section level3">
<h3><span class="header-section-number">6.3.2</span> Random forests</h3>
<p>Random forests consist in a ensemble of regression trees based on bagging, a bootstrapping aggregation technique where each sample is different from the original data set, but resembles it in distribution and variability (Breiman, 1996, 2001). On digital soil mapping, random forests allows uncovering statistical relationship between a dependent variable (e.g. soil property) and its prediction factors (e.g., terrain attributes, remote sensing, climate layers and/or legacy maps). Random forests generates multiple regression trees using different subsets of available data and random combinations of the prediction factors. Each tree is internally evaluated by an out-of-bag cross validation form which allows to assess the relatively importance of the available prediction factors. Thus, higher weight is given to the most accurate trees (which use the most informative prediction factors) and the final prediction to new data is the weigthed average of all generated trees. This method has been used to generate accurate predictions of soil organic carbon from the plot to the global scale and also in a country-specific basis. Random forest can be implemented for digital soil mapping using open source platforms and public sources of environmental information.</p>
</div>
<div id="conceptual-model-and-data-preparation" class="section level3">
<h3><span class="header-section-number">6.3.3</span> Conceptual model and data preparation</h3>
<p>To use Random forest for digital soil organic carbon mapping the SCORPAN (Soils, Climate, Organisms, Relief, Parent material, Age and N space) conceptual model (McBratney et al., 2003; Florinsky, 2012) will have take the following form: <span class="math inline">\(\ \text{SOC}_{x,y~t} \sim \text{randomForest} (E_{x,y~t})\)</span> where soil organic carbon estimates (<em>SOC</em>) for a specific site (<em>x,y</em>) and for a specific period of time (~t) can be modeled as a Random forest (randomForest) function of the soil forming environment (<span class="math inline">\(\ Ex,y~t\)</span>), which is represented by the <em>SOC</em> prediction factors (e.g., terrain attributes, remote sensing, climate layers and/or legacy maps). To feed the right side of the equation, <span class="math inline">\(SOC_{x,y~t}\)</span> is usually represented in a tabular form or a geo-spatial object (e.g., shapefile) with three fundamental columns. Two columns represent the spatial coordinates x and y (e.g., latitude and longitude) that are used to extract the values of the prediction factors for the representative locations of the <em>SOC</em> estimates. <em>SOC</em> estimates are represented in a third column (see previous chapters of this book dealing with the transformation of soil carbon density to mass units). The left side of the equation is generally represented by gridded (raster) files, so all available sources of information should be first harmonized into a common pixel size and coordinate reference system.</p>
</div>
<div id="software" class="section level3">
<h3><span class="header-section-number">6.3.4</span> Software</h3>
<p>For the Random forest implementation we will use the platform for statistical computing R (R Core Team, 2016). This is an open source object oriented software that rely on specific-contributor libraries. There are several implementations for the Random forest algorithm in R as well as several variants that can be used to solve digital soil mapping problems. In this section we will show the use of Random forest using the quantregForest, raster and caret R packages. The quantile regression forest (quantregForest; (Meinshausen, 2006)) has two main advantages. First, it can be used to extract the variance of all the trees generated by Random forest, not just the mean (as in the original randomForest package), and therefore we can calculate the dispersion of the full conditional distribution of SOC as a function of the prediction factors, which given available data, represent the Random forest model uncertainty. Second, the quantile regression forest approach can run in parallel using all available computational resources, in a way that we can predict and estimate the uncertainty of predictions at reasonable time frames with large datasets.</p>
</div>
<div id="tunning-random-forest-parameters" class="section level3">
<h3><span class="header-section-number">6.3.5</span> Tunning Random forest parameters</h3>
<p>Two important parameters of Random forest are mtry and ntree. The mtry parameter controls the number of prediction factors that are randomly used on each tree, while the ntree parameter controls the number of trees generated by Random forest. These two parameters can be selected by the means of cross-validation to maximize the prediction capacity of Random forest. We will use the caret package to select the most appropriate values for these parameters using repeated cross-validation (Kuhn et al. 2017). Tunning the main parameters of Random forest (or any other model) can be time consuming in computational terms, because implies the need to run and internally validate an independent model for each possible combination of parameter values. Thus, tunning the Random forest parameters would be relevant, given available data, to achieve the best possible accuracy of predictions.</p>
</div>
<div id="technical-steps---random-forest" class="section level3">
<h3><span class="header-section-number">6.3.6</span> Technical steps - Random forest</h3>
<p>We will begin this exercise using two previously prepared databases for Macedonia by the Global Soil Parthnership staff (see previous chapters of this book dealing with data preparation). The first dataset contains in a tabular form the <em>OCSKGM</em> values and the values of the prediction factors for the same locations (e.g., x, y, <em>OCSKGM</em>, covariate1, covariate2…) while the second database is represented by a stack of raster files containing prediction factors across all the area of interest at the spatial resolution of 0.0083º (approx. 1km, Fig. 1). Lets import the data sets and load in R all our libraries of interest.</p>
<div id="data-preparation-2" class="section level4">
<h4><span class="header-section-number">6.3.6.1</span> Data Preparation</h4>
<p><strong>Point Dataset</strong></p>
<p>We previously applied spline function to produce continuous soil information to a given soil depth (0-30 cm) in the section 2.4. Spline function basically imports soil profile data (including instances where layers are not contiguous), fits it to a mass-preserving spline and outputs attribute means for a given depth. The output file should contain profile id, upper (surface) and lower depth (30cm), estimated value for the selected soil attribute (Value) and tmse (estimated mean squared error of the spline). If you used the Spline Tool V2, the coordinates were not kept in the output file. The coordinates should be added back in the data table. You can use Profile IDs to add the X, Y columns back. Once your point dataset is ready, copy this table into your working directory as a .csv file.</p>
<p><strong>Environmental Predictors (Covariates)</strong></p>
<p>In the Chapter <a href="covariates.html#covariates">5</a>, we presented and prepared several global and continental datasets. In addition to these datasets, numerous covariate layers have been prepared by ISRIC for the GSOC Map project. These are GIS raster layers of various biophysical earth surface properties for each country in the world. Some of these layers will be used as predictors in this section. Please download the covariates for your own study area from GSOCMap Data Repository as explained in Section <a href="covariates.html#GSOC-data-repo">5.6</a>.</p>
<p>In section <a href="covariates.html#overlay-soil-covariates">5.9</a>, a table with the points values after data preparation and the values of our spatial predictors was prepared. This step involves loading this table.</p>
<p>Now we will import our point dataset using <code>read.csv()</code> function. The easiest way to create a data frame is to read in data from a file—this is done using the function read.csv, which works with comma delimited files. Data can be read in from other file formats as well, using different functions, but read.csv is the most commonly used approach. R is very flexible in how it reads in data from text files (<code>read.table</code>, <code>read.csv</code>, <code>read.csv2</code>, <code>read.delim</code>, <code>read.delim2</code>). Please type <code>?read.table()</code> for help.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb84-1" data-line-number="1"><span class="co"># load data</span></a>
<a class="sourceLine" id="cb84-2" data-line-number="2">dat &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/MKD_RegMatrix.csv&quot;</span>)</a>
<a class="sourceLine" id="cb84-3" data-line-number="3"></a>
<a class="sourceLine" id="cb84-4" data-line-number="4">dat<span class="op">$</span>LCEE10 &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat<span class="op">$</span>LCEE10)</a>
<a class="sourceLine" id="cb84-5" data-line-number="5">dat<span class="op">$</span>soilmap &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat<span class="op">$</span>soilmap)</a>
<a class="sourceLine" id="cb84-6" data-line-number="6"></a>
<a class="sourceLine" id="cb84-7" data-line-number="7"><span class="co"># explore the data structure</span></a>
<a class="sourceLine" id="cb84-8" data-line-number="8"><span class="kw">str</span>(dat)</a></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    2893 obs. of  22 variables:
##  $ id      : Factor w/ 2893 levels &quot;P0003&quot;,&quot;P0004&quot;,..: 1 2 3 4 ..
##  $ Y       : num  42 42 42.1 42 42 ...
##  $ X       : num  20.8 20.8 20.8 20.9 20.9 ...
##  $ SOC     : num  26.38 24.56 3.94 3.26 2.29 ...
##  $ BLD     : num  0.73 0.896 1.296 1.345 1.413 ...
##  $ CRFVOL  : num  8 6.31 31.88 21.71 14.46 ...
##  $ OCSKGM  : num  5.32 6.18 1.04 1.03 0.83 ...
##  $ meaERROR: num  2.16 2.63 2.65 3.16 3.63 2.83 2.94 2.4 2.77 2..
##  $ B04CHE3 : num  574 574 693 743 744 ...
##  $ B07CHE3 : num  38.5 38.5 42.1 43.7 43.7 ...
##  $ B13CHE3 : num  111.6 111.6 99.8 118.1 121 ...
##  $ B14CHE3 : num  59.2 59.2 42.4 39.9 38.7 ...
##  $ DEMENV5 : int  2327 2327 1243 1120 1098 1492 1413 1899 1731 ..
##  $ LCEE10  : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 2 1 2 2 2 ..
##  $ PRSCHE3 : num  998 998 780 839 844 ...
##  $ SLPMRG5 : int  13 13 6 25 30 24 15 25 20 37 ...
##  $ TMDMOD3 : int  282 282 285 288 289 287 286 284 287 281 ...
##  $ TMNMOD3 : int  272 272 277 279 279 277 277 272 274 272 ...
##  $ TWIMRG5 : int  61 61 81 66 65 72 68 60 65 60 ...
##  $ VBFMRG5 : int  0 0 14 0 0 0 0 0 0 0 ...
##  $ VDPMRG5 : int  311 311 10048 1963 -173 -400 -9 -1867 -1139 -..
##  $ soilmap : Factor w/ 20 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 6 6 14 3 3..</code></pre>
<p>Since we will be working with spatial data we need to define the coordinates for the imported data. Using the coordinates() function from the sp package we can define the columns in the data frame to refer to spatial coordinates—here the coordinates are listed in columns X and Y.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb86-1" data-line-number="1"><span class="kw">library</span>(sp)</a>
<a class="sourceLine" id="cb86-2" data-line-number="2"></a>
<a class="sourceLine" id="cb86-3" data-line-number="3"><span class="co"># Promote to spatialPointsDataFrame</span></a>
<a class="sourceLine" id="cb86-4" data-line-number="4"><span class="kw">coordinates</span>(dat) &lt;-<span class="st"> </span><span class="er">~</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>Y</a>
<a class="sourceLine" id="cb86-5" data-line-number="5"></a>
<a class="sourceLine" id="cb86-6" data-line-number="6"><span class="kw">class</span>(dat)</a></code></pre></div>
<pre><code>## [1] &quot;SpatialPointsDataFrame&quot;
## attr(,&quot;package&quot;)
## [1] &quot;sp&quot;</code></pre>
<p>SpatialPointsDataFrame structure is essentially the same data frame, except that additional “spatial” elements have been added or partitioned into slots. Some important ones being the bounding box (sort of like the spatial extent of the data), and the coordinate reference system proj4string(), which we need to define for the sample dataset. To define the CRS, we must know where our data are from, and what was the corresponding CRS used when recording the spatial information in the field. For this data set the CRS used was: WGS84 (EPSG:4326).</p>
<p>To clearly tell R this information we define the CRS which describes a reference system in a way understood by the <a href="http://trac.osgeo.org/proj/">PROJ.4 projection library</a>. An interface to the PROJ.4 library is available in the rgdal package. Alternative to using Proj4 character strings, we can use the corresponding yet simpler EPSG code (European Petroleum Survey Group). rgdal also recognizes these codes. If you are unsure of the Proj4 or EPSG code for the spatial data that you have, but know the CRS, you should consult <a href="http://spatialreference.org/" class="uri">http://spatialreference.org/</a> for assistance.</p>
<p>Please also note that, when working with spatial data, it’s very important that the CRS (coordinate reference system) of the point data and covariates are the same.</p>
<p>Now, we will define our CRS:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb88-1" data-line-number="1">dat<span class="op">@</span>proj4string &lt;-<span class="st"> </span><span class="kw">CRS</span>(<span class="dt">projargs =</span> <span class="st">&quot;+init=epsg:4326&quot;</span>)</a>
<a class="sourceLine" id="cb88-2" data-line-number="2"></a>
<a class="sourceLine" id="cb88-3" data-line-number="3">dat<span class="op">@</span>proj4string</a></code></pre></div>
<pre><code>## CRS arguments:
##  +init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs
## +ellps=WGS84 +towgs84=0,0,0</code></pre>
<p>Now we will import the covariates. When the covariate layers are in common resolution and extent, rather than working with individual rasters it is better to stack them all into a single R object. In this example we use 13 covariates from the GSOCMap Data Repository and a rasterized version of the soil type map. The rasterization of vectorial data was covered in <a href="covariates.html#technical-steps---rasterizing-a-vector-layer-in-r">Technical Steps - Rasterizing a vector layer in R</a>. The file containing all the covariates was prepared at the end of chapter <a href="covariates.html#covariates">5</a>.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb90-1" data-line-number="1"><span class="kw">load</span>(<span class="dt">file =</span> <span class="st">&quot;covariates.RData&quot;</span>)</a>
<a class="sourceLine" id="cb90-2" data-line-number="2"></a>
<a class="sourceLine" id="cb90-3" data-line-number="3"><span class="kw">names</span>(covs)</a></code></pre></div>
<pre><code>##  [1] &quot;B04CHE3&quot; &quot;B07CHE3&quot; &quot;B13CHE3&quot; &quot;B14CHE3&quot; &quot;DEMENV5&quot; &quot;LCEE10&quot; 
##  [7] &quot;PRSCHE3&quot; &quot;SLPMRG5&quot; &quot;TMDMOD3&quot; &quot;TMNMOD3&quot; &quot;TWIMRG5&quot; &quot;VBFMRG5&quot;
## [13] &quot;VDPMRG5&quot; &quot;soilmap&quot;</code></pre>
<p>Random forest does not have assumptions about the statistical distribution of the response variable, but it is a good practice prior to model building to analyze the statistical distribution of the response variable (e.g., if is normal or not) and its relationships with the prediction factors. Soil organic carbon tends to have a log-normal distribution with a right-skew, and transforming the original values to its natural logarithm would generate a normal distribution of soil organic carbon values. Here we will test if the log transformation of the response variable (<em>SOC</em>) tends to normality and 2) if this transformation increases the simple correlation of <em>SOC</em> and its prediction factors.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb92-1" data-line-number="1"><span class="co">#Best correlated variables with OCSKGM</span></a>
<a class="sourceLine" id="cb92-2" data-line-number="2">d_cor &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">cor</span>(dat[<span class="op">-</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">15</span>)]))</a>
<a class="sourceLine" id="cb92-3" data-line-number="3">d_cor_melt &lt;-<span class="st"> </span><span class="kw">arrange</span>(<span class="kw">melt</span>(d_cor), <span class="op">-</span><span class="kw">abs</span>(value))</a>
<a class="sourceLine" id="cb92-4" data-line-number="4">d_cor_melt[d_cor_melt<span class="op">$</span>Var2<span class="op">==</span><span class="st">&#39;OCSKGMlog&#39;</span>,]</a>
<a class="sourceLine" id="cb92-5" data-line-number="5"></a>
<a class="sourceLine" id="cb92-6" data-line-number="6"><span class="co"># Note that the main effects are not the same. </span></a>
<a class="sourceLine" id="cb92-7" data-line-number="7"><span class="co"># This results can be used to interpret the drivers of OCSKGM </span></a>
<a class="sourceLine" id="cb92-8" data-line-number="8"><span class="co"># spatial variability.</span></a></code></pre></div>
<p>From the previous plots, we can say that the statistical distribution of <em>OCSKGM</em> tends to normality after the natural logarithm transformation and also increases the correlation with the prediction factors. Therefore for further analysis we will use the dataset transformed to its natural logarithm (OCSKGMlog). We will build a working hypothesis from our conceptual model, using all the continous prediction factors for <em>OCSKGMlog</em>:</p>
<p><em>OCSKGMlog</em> ~ randomForest <em>B04CHE3 + B07CHE3 + B13CHE3 + B14CHE3 + DEMENV5 + LCEE10 + PRSCHE3 + SLPMRG5 + TMDMOD3 + TMNMOD3 + TWIMRG5 + VBFMRG5 + VDPMRG5</em></p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb93-1" data-line-number="1"><span class="co"># For its use on R we need to define a model formula</span></a>
<a class="sourceLine" id="cb93-2" data-line-number="2"></a>
<a class="sourceLine" id="cb93-3" data-line-number="3">fm =<span class="st"> </span><span class="kw">as.formula</span>(<span class="kw">paste</span>(<span class="st">&quot;OCSKGMlog ~&quot;</span>, <span class="kw">paste0</span>(<span class="kw">names</span>(covariates[[<span class="op">-</span><span class="dv">14</span>]]),</a>
<a class="sourceLine" id="cb93-4" data-line-number="4">                                            <span class="dt">collapse =</span> <span class="st">&quot;+&quot;</span>))) </a></code></pre></div>
<p>This is the R syntax to define a model formula required for the model structure, where soil organic carbon transformed to its natural logarithm (<em>OCSKGMlog</em>) can be predicted as a function of the available prediction factors (each explained in previous chapters of this book, e.g., B04CHE3, B07CHE3, B13CHE3, B14CHE3, DEMENV5 , LCEE10, PRSCHE3, SLPMRG5, TMDMOD3, TMNMOD3, TWIMRG5, VBFMRG5, VDPMRG5).</p>
<p>Note that the variable soilmap is categorical, so is not included in the correlation analysis. In fact, although soil type polygon maps are in theory powerful predictors for <em>OCSKGM</em> we will not use this map for modeling, because not all categories in the map are represented by available <em>OCSKGM</em> estimations, therefore this map requires a generalization of soil type units in function of the classes represented by the sites of <em>OCSKGM</em> estimates, which is beyond the scope of this chapter. Ideally the number of observations across all the categories of soil type or any other factorial variable should be balanced.</p>
<p>Keep in mind that selecting the most appropriate prediction factors is required to generate an interpretable model and high accuracy of prediction in places where no information is available. Variable selection ideally should incorporate expert soil knowledge about the study area and a statistical criteria (e.g., just to use the best correlated predictors). Multivariate analysis (e.g., principal component analysis) are a widely used approach to select the most informative predictors. Here we use this combination of prediction factors to be consistent with other book chapters and because they were previously prepared for this exercise using expert knowledge about the spatial variability of OCSKGM estimates.</p>
<p><strong>Step - Tuning parameters</strong></p>
<p>Now we will use the cross-validation strategy implemented in the train function of the caret package (Kuhn et al. 2017), which default is 10-fold. The result of this function includes information to select the best mtry parameter and to decide the appropriate number of trees. The out-of-bag root mean squared error (rmse) will be used to select the optimal mtry model. To analyze the ntree parameter we will plot the number of trees against the out-of-bag rmse, an optimal ntree can be selected with the number of trees when this relationships stabilizes. Reduncing the number of trees will reduce the computational demand, which is specially important when dealing with large databases. In the presence of multidimensional and highly correlated prediction factors, avoiding an excessive number of trees will also reduce the risk of overfitting.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb94-1" data-line-number="1"><span class="co">#Default 10-fold cross-validation</span></a>
<a class="sourceLine" id="cb94-2" data-line-number="2">ctrl &lt;-<span class="st"> </span><span class="kw">trainControl</span>(<span class="dt">method =</span> <span class="st">&quot;cv&quot;</span>, <span class="dt">savePred=</span>T)</a>
<a class="sourceLine" id="cb94-3" data-line-number="3"><span class="co">#Search for the best mtry parameter</span></a>
<a class="sourceLine" id="cb94-4" data-line-number="4">mod &lt;-<span class="st"> </span><span class="kw">train</span>(fm, <span class="dt">data=</span>train, <span class="dt">method =</span> <span class="st">&quot;rf&quot;</span>, <span class="dt">trControl =</span> ctrl, </a>
<a class="sourceLine" id="cb94-5" data-line-number="5">             <span class="dt">importance=</span><span class="ot">TRUE</span>)</a></code></pre></div>
<p>The object derived from the train function can be used to generate predictions of OCSKGMlog at the spatial resolution of the prediction factors. Before generating predictions, we will plot the most important predictors sorted in decreasing order of importance. From the variable importance plot, %IncMSE represent an informative measure for variable selection. It is the increase in error (mean squared error, MSE) of predictions which was estimated with out-of-bag-cross validation as a result of prediction factor being permuted with values randomly shuffled. This is one of the strategies that Random forest uses to reduce overfitting.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb95-1" data-line-number="1"><span class="co">#Variable importance plot, compare with the correlation matrix</span></a>
<a class="sourceLine" id="cb95-2" data-line-number="2"><span class="co">#Select the best prediction factors and repeat  </span></a>
<a class="sourceLine" id="cb95-3" data-line-number="3"><span class="kw">varImpPlot</span>(mod[<span class="dv">11</span>][[<span class="dv">1</span>]], <span class="dt">main=</span><span class="st">&#39;model decreasing error and node purity&#39;</span>)</a>
<a class="sourceLine" id="cb95-4" data-line-number="4"><span class="co">#Check if the error stabilizes </span></a>
<a class="sourceLine" id="cb95-5" data-line-number="5"><span class="kw">plot</span>(mod[<span class="dv">11</span>][[<span class="dv">1</span>]], <span class="dt">main=</span><span class="st">&#39;select ntree&#39;</span>)</a>
<a class="sourceLine" id="cb95-6" data-line-number="6"><span class="co">#Make a prediction across all Macedonia</span></a>
<a class="sourceLine" id="cb95-7" data-line-number="7"><span class="co">#Note that the units are still in log</span></a>
<a class="sourceLine" id="cb95-8" data-line-number="8">pred &lt;-<span class="st"> </span><span class="kw">predict</span>(covariates, mod)</a>
<a class="sourceLine" id="cb95-9" data-line-number="9"></a>
<a class="sourceLine" id="cb95-10" data-line-number="10"><span class="kw">plot</span>(pred, <span class="st">&#39;prediction of log transformed values&#39;</span>)</a></code></pre></div>
<p>Random forest users are encouraged to compare and test the prediction capacity of different combinations of prediction factors in order to reduce the complexity of the model and the statistical redundancy of environmental information on further applications of predicted OCSKGM maps (e.g., quantifying the carbon dynamics). The resulting map of our Random forest model needs to be validated using the independent dataset to complement the results of the cross validation (e.g., rmse and explained variance) derived using the train function and to have a more comprehensive interpretation of accuracy and bias. Note how the rmse and the explained variance derived from the independent validations are slightly lower than the values obtained using cross validation.</p>
</div>
</div>
<div id="modelling-uncertainty-using-random-forest" class="section level3">
<h3><span class="header-section-number">6.3.7</span> Modelling Uncertainty Using Random Forest</h3>
<p>Ideally a digital soil map should include a spatial explicit metric of uncertainty. The uncertainty can be roughly divided on four main components, uncertainty in soil data, uncertainty in soil covariates, uncertainty in the model and uncertainty in variations of available data. Here, we show an approach to estimate the sensitivity of the model to available data and the uncertainty of the model. The first two are beyond of the aim of this chapter. For the third and fourth we will generate a reproducible example.</p>
<p>To analyze the sensitivity of the model to available data we just need to random split the data several times (e.g., 10 or more) in training and testing subsets. A run separate construction of the model and final prediction, in a way that the dispersion of the predicted values at the pixel level will represent sensitivity of the model to variations in available data. This process will take much more computational time and memory since it will repeat n times (10 in this example) the model and the prediction using each time a different random combination of data for training and testing the models. As larger the sample and the number of realizations the more robust our validation strategy. For this example we will use only 10 realizations and random splits of 25% of available data. The validation plot shows the regression line between observed and predicted of a model that uses 75% (black line) and the regression lines of 10 model realization each with a different random combination of data for training and validating the models. The rmse and the explained variance of the models is stored in the object validation (type <code>summary(validation)</code>). The standard deviation of all the ten predictions allows to generate a map of model sensitivity to available data.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb96-1" data-line-number="1"><span class="co">#Plot the observed vs modeled including a regression line</span></a>
<a class="sourceLine" id="cb96-2" data-line-number="2"><span class="co">#This model was generated with the 75% of all data</span></a>
<a class="sourceLine" id="cb96-3" data-line-number="3"><span class="kw">plot</span>(test<span class="op">$</span>OCSKGMlog, test<span class="op">$</span>pred, <span class="dt">main=</span><span class="st">&#39;validation plot&#39;</span> )</a>
<a class="sourceLine" id="cb96-4" data-line-number="4"><span class="kw">abline</span>(<span class="kw">lm</span>(test<span class="op">$</span>pred<span class="op">~</span>test<span class="op">$</span>OCSKGMlog), <span class="dt">col=</span><span class="st">&#39;black&#39;</span>, <span class="dt">xlab=</span><span class="st">&#39;observed&#39;</span>, </a>
<a class="sourceLine" id="cb96-5" data-line-number="5">       <span class="dt">ylab=</span><span class="st">&#39;modeled&#39;</span>)</a>
<a class="sourceLine" id="cb96-6" data-line-number="6"></a>
<a class="sourceLine" id="cb96-7" data-line-number="7"><span class="co">#Generate an empty dataframe</span></a>
<a class="sourceLine" id="cb96-8" data-line-number="8">validation &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">rmse=</span><span class="kw">numeric</span>(), <span class="dt">r2=</span><span class="kw">numeric</span>())</a>
<a class="sourceLine" id="cb96-9" data-line-number="9"><span class="co">#Sensitivity to the dataset</span></a>
<a class="sourceLine" id="cb96-10" data-line-number="10"><span class="co">#Start a loop with 10 model realizations</span></a>
<a class="sourceLine" id="cb96-11" data-line-number="11"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>){</a>
<a class="sourceLine" id="cb96-12" data-line-number="12"><span class="co">#We will build 10 models using random samples of 25%  </span></a>
<a class="sourceLine" id="cb96-13" data-line-number="13">smp_size &lt;-<span class="st"> </span><span class="kw">floor</span>(<span class="fl">0.25</span> <span class="op">*</span><span class="st"> </span><span class="kw">nrow</span>(dat))</a>
<a class="sourceLine" id="cb96-14" data-line-number="14">train_ind &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">seq_len</span>(<span class="kw">nrow</span>(dat)), <span class="dt">size =</span> smp_size)</a>
<a class="sourceLine" id="cb96-15" data-line-number="15">train &lt;-<span class="st"> </span>dat[train_ind, ]</a>
<a class="sourceLine" id="cb96-16" data-line-number="16">test &lt;-<span class="st"> </span>dat[<span class="op">-</span>train_ind, ]</a>
<a class="sourceLine" id="cb96-17" data-line-number="17"><span class="co">#cross validate and make predictions for each model</span></a>
<a class="sourceLine" id="cb96-18" data-line-number="18">modn &lt;-<span class="st"> </span><span class="kw">train</span>(fm, <span class="dt">data=</span>train, <span class="dt">method =</span> <span class="st">&quot;rf&quot;</span>, <span class="dt">trControl =</span> ctrl)</a>
<a class="sourceLine" id="cb96-19" data-line-number="19">pred &lt;-<span class="st"> </span><span class="kw">stack</span>(pred, <span class="kw">predict</span>(covariates, modn))</a>
<a class="sourceLine" id="cb96-20" data-line-number="20">test<span class="op">$</span>pred &lt;-<span class="st"> </span><span class="kw">predict</span>(modn[<span class="dv">11</span>][[<span class="dv">1</span>]], test)</a>
<a class="sourceLine" id="cb96-21" data-line-number="21"><span class="co">#Store the results in a dataframe</span></a>
<a class="sourceLine" id="cb96-22" data-line-number="22">validation[i, <span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">rmse</span>(test<span class="op">$</span>OCSKGMlog, test<span class="op">$</span>pred)</a>
<a class="sourceLine" id="cb96-23" data-line-number="23">validation[i, <span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">cor</span>(test<span class="op">$</span>OCSKGMlog, test<span class="op">$</span>pred)<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb96-24" data-line-number="24"><span class="co">#Plot the regression line of each model </span></a>
<a class="sourceLine" id="cb96-25" data-line-number="25"><span class="kw">abline</span>(<span class="kw">lm</span>(test<span class="op">$</span>pred<span class="op">~</span>test<span class="op">$</span>OCSKGMlog), <span class="dt">col=</span><span class="st">&#39;gray&#39;</span>)</a>
<a class="sourceLine" id="cb96-26" data-line-number="26"><span class="kw">print</span>(i)</a>
<a class="sourceLine" id="cb96-27" data-line-number="27">}</a>
<a class="sourceLine" id="cb96-28" data-line-number="28"><span class="co">#The sensitivity map is the dispersion of all individual models</span></a>
<a class="sourceLine" id="cb96-29" data-line-number="29">sensitivity &lt;-<span class="st"> </span><span class="kw">calc</span>(pred[[<span class="op">-</span><span class="dv">1</span>]], sd)</a>
<a class="sourceLine" id="cb96-30" data-line-number="30"><span class="co">#Sensitivity of validation metrics</span></a>
<a class="sourceLine" id="cb96-31" data-line-number="31"><span class="kw">summary</span>(validation)</a>
<a class="sourceLine" id="cb96-32" data-line-number="32"><span class="co">#Plot of the map based on 75% of data and the sensitivity to data variations</span></a>
<a class="sourceLine" id="cb96-33" data-line-number="33">prediction75 &lt;-<span class="st"> </span><span class="kw">exp</span>(pred[[<span class="dv">1</span>]])</a>
<a class="sourceLine" id="cb96-34" data-line-number="34"><span class="kw">plot</span>(prediction75, <span class="dt">main=</span><span class="st">&#39;OCSKGM prediction based on 75% of data&#39;</span>, </a>
<a class="sourceLine" id="cb96-35" data-line-number="35">     <span class="dt">col=</span><span class="kw">rev</span>(<span class="kw">topo.colors</span>(<span class="dv">10</span>)))</a>
<a class="sourceLine" id="cb96-36" data-line-number="36"><span class="kw">plot</span>(sensitivity, <span class="dt">col=</span><span class="kw">rev</span>(<span class="kw">topo.colors</span>(<span class="dv">10</span>)), </a>
<a class="sourceLine" id="cb96-37" data-line-number="37">     <span class="dt">main=</span><span class="st">&#39;Sensitivity based on 10 realizations using 25% samples&#39;</span>)</a></code></pre></div>
<p>Finally we are going to estimate the model uncertainty, represented by the full conditional distribution of the response variable (OCSKGM) as a function of the selected prediction factors using the quantile regression forest package of R. This approach has proven to be efficient for digital soil mapping across large areas (Vaysse &amp; Lagacherie, 2017). This method will calculate a probability distribution function for each pixel and therefore can be time consuming. Therefore we will run it using parallel computing. Note that the code to run in parallel this analysis can also be passed to the previous predictions (predict function). The result will be a map of the standard deviation of the distribution calculated for each pixel, which represent the extreme values that a prediction can take for a specific site (e.g., pixel) given available data and predictors. Note that this analysis is performed using all available data and a second map of OCSKGM is created. Our final prediction uses all available data, while the total uncertainty (in percent) is represented by the sum of the quantile regression forest standard deviation and the sensitivity map from the previous section. The total uncertainty is then divided by the prediction to obtain a percent map, which is easier to interpret. Finally, the predicted OCSKGM and the total uncertainty can be saved in the working directory in a generic (*.tif) raster format.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb97-1" data-line-number="1"><span class="co"># Use quantile regression forest to estimate the full conditional </span></a>
<a class="sourceLine" id="cb97-2" data-line-number="2"><span class="co"># distribution of OCSKGMlog</span></a>
<a class="sourceLine" id="cb97-3" data-line-number="3">model &lt;-<span class="st"> </span><span class="kw">quantregForest</span>(<span class="dt">y=</span>dat<span class="op">$</span>OCSKGMlog, <span class="dt">x=</span>dat[,<span class="dv">1</span><span class="op">:</span><span class="dv">13</span>], <span class="dt">ntree=</span><span class="dv">500</span>, </a>
<a class="sourceLine" id="cb97-4" data-line-number="4">                        <span class="dt">keep.inbag=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb97-5" data-line-number="5"><span class="co"># The argument nthread allows to run this line in parallel</span></a>
<a class="sourceLine" id="cb97-6" data-line-number="6"></a>
<a class="sourceLine" id="cb97-7" data-line-number="7"><span class="co"># Estimate model uncertainty at the pixel level using parallel </span></a>
<a class="sourceLine" id="cb97-8" data-line-number="8"><span class="co"># computing, using 3 cores</span></a>
<a class="sourceLine" id="cb97-9" data-line-number="9"><span class="kw">beginCluster</span>(<span class="dv">3</span>,<span class="dt">type=</span><span class="st">&quot;SOCK&quot;</span>)</a>
<a class="sourceLine" id="cb97-10" data-line-number="10"><span class="co">#Estimate model uncertainty</span></a>
<a class="sourceLine" id="cb97-11" data-line-number="11">unc &lt;-<span class="st"> </span><span class="kw">clusterR</span>(covariates, predict, <span class="dt">args=</span><span class="kw">list</span>(<span class="dt">model=</span>model,<span class="dt">what=</span>sd))</a>
<a class="sourceLine" id="cb97-12" data-line-number="12"><span class="co">#OCSKGMlog prediction based in all available data</span></a>
<a class="sourceLine" id="cb97-13" data-line-number="13">mean &lt;-<span class="st"> </span><span class="kw">clusterR</span>(covariates, predict, <span class="dt">args=</span><span class="kw">list</span>(<span class="dt">model=</span>model,<span class="dt">what=</span>mean))</a>
<a class="sourceLine" id="cb97-14" data-line-number="14"><span class="co">#The total uncertainty is the sum of sensitivity and model uncertainty</span></a>
<a class="sourceLine" id="cb97-15" data-line-number="15">unc &lt;-<span class="st"> </span>unc <span class="op">+</span><span class="st"> </span>sensitivity</a>
<a class="sourceLine" id="cb97-16" data-line-number="16"><span class="co">#Express the uncertainty in percent (divide by the mean)</span></a>
<a class="sourceLine" id="cb97-17" data-line-number="17">Total_unc_Percent &lt;-<span class="st"> </span><span class="kw">exp</span>(unc)<span class="op">/</span><span class="kw">exp</span>(mean)</a>
<a class="sourceLine" id="cb97-18" data-line-number="18"><span class="co">#Plot both maps (the predicted OCSKGM and its associated uncertainty)</span></a>
<a class="sourceLine" id="cb97-19" data-line-number="19"><span class="kw">plot</span>(<span class="kw">exp</span>(mean), <span class="dt">main=</span><span class="st">&#39;OCSKGM based in all data&#39;</span>, </a>
<a class="sourceLine" id="cb97-20" data-line-number="20">     <span class="dt">col=</span><span class="kw">rev</span>(<span class="kw">topo.colors</span>(<span class="dv">10</span>)))</a>
<a class="sourceLine" id="cb97-21" data-line-number="21"><span class="kw">plot</span>(Total_unc_Percent, <span class="dt">col=</span><span class="kw">rev</span>(<span class="kw">heat.colors</span>(<span class="dv">100</span>)), <span class="dt">zlim=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">5</span>), </a>
<a class="sourceLine" id="cb97-22" data-line-number="22">     <span class="dt">main=</span><span class="st">&#39;Total uncertainty&#39;</span>)</a>
<a class="sourceLine" id="cb97-23" data-line-number="23"><span class="co">#Save the resulting maps in separated *.tif files</span></a>
<a class="sourceLine" id="cb97-24" data-line-number="24"><span class="kw">endCluster</span>()</a></code></pre></div>
<p>We have created two maps in the working directory, one represent the predicted OCSKGM and the second one its uncertainty, which is the sum of the model sensitivity to data variations and the full conditional distribution of the response variable as a function of available prediction factors. The following chapters of this book will show you how to prepare a stock report based on this soil carbon digital soil maps.</p>
<p>##References</p>
<p>-Bonfatti BR, Hartemink AE, Giasson E, Tornquist CG, Adhikari K (2016) Digital mapping of soil carbon in a viticultural region of Southern Brazil. Geoderma, 261, 204–221.</p>
<p>-Breiman L (1996) Bagging Predictors. Machine Learning, 24, 123–140.</p>
<p>-Breiman L (2001) Random Forests. Machine Learning, 45, 5–32.</p>
<p>-Florinsky IV (2012) The Dokuchaev hypothesis as a basis for predictive digital soil mapping (on the 125th anniversary of its publication). Eurasian Soil Science, 45, 445–451.</p>
<p>-Guevara M, Olmedo GF, Stell E et al. (2018) No Silver Bullet for Digital Soil Mapping: Country-specific Soil Organic Carbon Estimates across Latin America. SOIL Discussions, 1–20.</p>
<p>-Hengl T, de Jesus JM, MacMillan RA et al. (2014) SoilGrids1km — Global Soil Information Based on Automated Mapping (ed Bond-Lamberty B). PLoS ONE, 9, e105992.</p>
<p>-Hengl T, Mendes de Jesus J, Heuvelink GBM et al. (2017) SoilGrids250m: Global gridded soil information based on machine learning (ed Bond-Lamberty B). PLOS ONE, 12, e0169748.</p>
<p>-Kuhn M. Contributions from Jed Wing, Steve Weston, Andre Williams, Chris Keefer, Allan Engelhardt, Tony Cooper, Zachary Mayer, Brenton Kenkel, the R Core Team, Michael Benesty, Reynald Lescarbeau, Andrew Ziem, Luca Scrucca, Yuan Tang, Can Candan and Tyler Hunt. (2017). caret: Classification and Regression Training. R package version 6.0-78. <a href="https://CRAN.R-project.org/package=caret" class="uri">https://CRAN.R-project.org/package=caret</a></p>
<p>-McBratney A., Mendonça Santos M., Minasny B (2003) On digital soil mapping. Geoderma, 117, 3–52.</p>
<p>-Meinshausen N., (2006) Quantile Regression Forests. J. Mach. Learn. Res., 7, 983–999.</p>
<p>-R Core Team (2016). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL <a href="https://www.R-project.org/" class="uri">https://www.R-project.org/</a>.</p>
<p>-Vaysse K, Lagacherie P (2017) Using quantile regression forest to estimate uncertainty of digital soil mapping products. Geoderma, 291, 55–64.</p>


</div>
</div>
<div id="data-minning-support-vector-machines" class="section level2">
<h2><span class="header-section-number">6.4</span> Data minning: Support Vector Machines</h2>
<p><em>GF Olmedo &amp; M Guevara</em></p>
<p>Support vector machines (svm) is a machine learning technique used for classification and regresion analysis. According to <span class="citation">Pedregosa et al. (<a href="#ref-scikit-learn">2011</a>)</span> the advantages of svm are:</p>
<ul>
<li>Effective in high dimensional spaces.</li>
<li>Still effective in cases where number of dimensions is greater than the number of samples.</li>
<li>Uses a subset of training points in the decision function (called support vectors), so it is also memory efficient.</li>
<li>Versatile: different Kernel functions can be specified for the decision function. Common kernels are provided, but it is also possible to specify custom kernels.</li>
</ul>
<p>And the disadvantages of support vector machines include:</p>
<ul>
<li>If the number of features is much greater than the number of samples, avoid over-fitting in choosing Kernel functions and regularization term is crucial.</li>
<li>SVMs do not directly provide probability estimates, these are calculated using an expensive five-fold cross-validation (see Scores and probabilities, below).</li>
</ul>
<p>In digital soil mapping, the problems usually involve working in high dimensional spaces (were the dimesions are the covariates) with a limited number of samples. svm is a technique mostly used in classification problems, but it can be used to solve regression problems, like the modelling of SOC using enviromental covariates. When svm is used to solve regression problem is called support vector regression.</p>
<p>For doing support vector regression, svm applies a simple linear method to the data but in a high-dimensional feature space non-linearly related to the input space. Then, it creates a hyperplane through n-dimensional spectral-space. And separates numerical data based on a kernel function and parameters (e.g. gamma and cost) that maximize the margin from the closest point to the hyperplane that divides data with the largest possible margin, being the support vectors the points which fall within. Then, linear models are fitted to the support vectors.</p>
<p>In the example below we will use the implementation of svm in the R package <code>e1071</code> <span class="citation">(Meyer et al. <a href="#ref-e1071">2017</a>)</span>. The package e1071 offers an interface to the award-winning C++ implementation by Chih-Chung Chang and Chih-Jen Lin, libsvm (current version: 2.6). For further implementation details on libsvm, see <span class="citation">Chang and Lin (<a href="#ref-chang2001libsvm">2001</a>)</span>.</p>
<p>svm is a huge area of study, we can recommend the following books: <span class="citation">Vapnik (<a href="#ref-vapnik2013nature">2013</a>)</span>, <span class="citation">Friedman, Hastie, and Tibshirani (<a href="#ref-friedman2001elements">2001</a>)</span> and <span class="citation">James et al. (<a href="#ref-james2013introduction">2013</a>)</span>.</p>
<div id="technical-steps---fitting-a-svm-model-to-predict-the-soc" class="section level3">
<h3><span class="header-section-number">6.4.1</span> Technical Steps - Fitting a SVM Model to Predict the SOC</h3>
<div id="setting-working-space-and-initial-steps-1" class="section level4">
<h4><span class="header-section-number">6.4.1.1</span> Setting Working Space and Initial Steps</h4>
<p>One of the first steps should be setting our working directory. If you read/write files from/ to disk, this takes place in the working directory. If we don’t set the working directory we could easily write files to an undesirable file location. The following example shows how to set the working directory in R to our folder which contains data for the study area (point data, covariates).</p>
<p>Note that we must use the forward slash / or double backslash \\ in R! Single backslash \ will not work. Now we can check if the working directory has been correctly set by using the function:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb98-1" data-line-number="1"><span class="kw">getwd</span>()</a></code></pre></div>
</div>
<div id="data-preparation-3" class="section level4">
<h4><span class="header-section-number">6.4.1.2</span> Data Preparation</h4>
<p><strong>Point Dataset</strong></p>
<p>We previously applied spline function to produce continuous soil information to a given soil depth (0-30 cm) in the section 2.4. Spline function basically imports soil profile data (including instances where layers are not contiguous), fits it to a mass-preserving spline and outputs attribute means for a given depth. The output file should contain profile id, upper (surface) and lower depth (30cm), estimated value for the selected soil attribute (Value) and tmse (estimated mean squared error of the spline). If you used the Spline Tool V2, the coordinates were not kept in the output file. The coordinates should be added back in the data table. You can use Profile IDs to add the X, Y columns back. Once your point dataset is ready, copy this table into your working directory as a .csv file.</p>
<p><strong>Environmental Predictors (Covariates)</strong></p>
<p>In the Chapter <a href="covariates.html#covariates">5</a>, we presented and prepared several global and continental datasets. In addition to these datasets, numerous covariate layers have been prepared by ISRIC for the GSOC Map project. These are GIS raster layers of various biophysical earth surface properties for each country in the world. Some of these layers will be used as predictors in this section. Please download the covariates for your own study area from GSOCMap Data Repository as explained in Section <a href="covariates.html#GSOC-data-repo">5.6</a>.</p>
<p>In section <a href="covariates.html#overlay-soil-covariates">5.9</a>, a table with the points values after data preparation and the values of our spatial predictors was prepared. This step involves loading this table.</p>
<p>Now we will import our point dataset using <code>read.csv()</code> function. The easiest way to create a data frame is to read in data from a file—this is done using the function read.csv, which works with comma delimited files. Data can be read in from other file formats as well, using different functions, but read.csv is the most commonly used approach. R is very flexible in how it reads in data from text files (<code>read.table</code>, <code>read.csv</code>, <code>read.csv2</code>, <code>read.delim</code>, <code>read.delim2</code>). Please type <code>?read.table()</code> for help.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb99-1" data-line-number="1"><span class="co"># load data</span></a>
<a class="sourceLine" id="cb99-2" data-line-number="2">dat &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/MKD_RegMatrix.csv&quot;</span>)</a>
<a class="sourceLine" id="cb99-3" data-line-number="3"></a>
<a class="sourceLine" id="cb99-4" data-line-number="4">dat<span class="op">$</span>LCEE10 &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat<span class="op">$</span>LCEE10)</a>
<a class="sourceLine" id="cb99-5" data-line-number="5">dat<span class="op">$</span>soilmap &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat<span class="op">$</span>soilmap)</a>
<a class="sourceLine" id="cb99-6" data-line-number="6"></a>
<a class="sourceLine" id="cb99-7" data-line-number="7"><span class="co"># explore the data structure</span></a>
<a class="sourceLine" id="cb99-8" data-line-number="8"><span class="kw">str</span>(dat)</a></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    2893 obs. of  22 variables:
##  $ id      : Factor w/ 2893 levels &quot;P0003&quot;,&quot;P0004&quot;,..: 1 2 3 4 ..
##  $ Y       : num  42 42 42.1 42 42 ...
##  $ X       : num  20.8 20.8 20.8 20.9 20.9 ...
##  $ SOC     : num  26.38 24.56 3.94 3.26 2.29 ...
##  $ BLD     : num  0.73 0.896 1.296 1.345 1.413 ...
##  $ CRFVOL  : num  8 6.31 31.88 21.71 14.46 ...
##  $ OCSKGM  : num  5.32 6.18 1.04 1.03 0.83 ...
##  $ meaERROR: num  2.16 2.63 2.65 3.16 3.63 2.83 2.94 2.4 2.77 2..
##  $ B04CHE3 : num  574 574 693 743 744 ...
##  $ B07CHE3 : num  38.5 38.5 42.1 43.7 43.7 ...
##  $ B13CHE3 : num  111.6 111.6 99.8 118.1 121 ...
##  $ B14CHE3 : num  59.2 59.2 42.4 39.9 38.7 ...
##  $ DEMENV5 : int  2327 2327 1243 1120 1098 1492 1413 1899 1731 ..
##  $ LCEE10  : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 2 1 2 2 2 ..
##  $ PRSCHE3 : num  998 998 780 839 844 ...
##  $ SLPMRG5 : int  13 13 6 25 30 24 15 25 20 37 ...
##  $ TMDMOD3 : int  282 282 285 288 289 287 286 284 287 281 ...
##  $ TMNMOD3 : int  272 272 277 279 279 277 277 272 274 272 ...
##  $ TWIMRG5 : int  61 61 81 66 65 72 68 60 65 60 ...
##  $ VBFMRG5 : int  0 0 14 0 0 0 0 0 0 0 ...
##  $ VDPMRG5 : int  311 311 10048 1963 -173 -400 -9 -1867 -1139 -..
##  $ soilmap : Factor w/ 20 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 6 6 14 3 3..</code></pre>
<p>Since we will be working with spatial data we need to define the coordinates for the imported data. Using the coordinates() function from the sp package we can define the columns in the data frame to refer to spatial coordinates—here the coordinates are listed in columns X and Y.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb101-1" data-line-number="1"><span class="kw">library</span>(sp)</a>
<a class="sourceLine" id="cb101-2" data-line-number="2"></a>
<a class="sourceLine" id="cb101-3" data-line-number="3"><span class="co"># Promote to spatialPointsDataFrame</span></a>
<a class="sourceLine" id="cb101-4" data-line-number="4"><span class="kw">coordinates</span>(dat) &lt;-<span class="st"> </span><span class="er">~</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>Y</a>
<a class="sourceLine" id="cb101-5" data-line-number="5"></a>
<a class="sourceLine" id="cb101-6" data-line-number="6"><span class="kw">class</span>(dat)</a></code></pre></div>
<pre><code>## [1] &quot;SpatialPointsDataFrame&quot;
## attr(,&quot;package&quot;)
## [1] &quot;sp&quot;</code></pre>
<p>SpatialPointsDataFrame structure is essentially the same data frame, except that additional “spatial” elements have been added or partitioned into slots. Some important ones being the bounding box (sort of like the spatial extent of the data), and the coordinate reference system proj4string(), which we need to define for the sample dataset. To define the CRS, we must know where our data are from, and what was the corresponding CRS used when recording the spatial information in the field. For this data set the CRS used was: WGS84 (EPSG:4326).</p>
<p>To clearly tell R this information we define the CRS which describes a reference system in a way understood by the <a href="http://trac.osgeo.org/proj/">PROJ.4 projection library</a>. An interface to the PROJ.4 library is available in the rgdal package. Alternative to using Proj4 character strings, we can use the corresponding yet simpler EPSG code (European Petroleum Survey Group). rgdal also recognizes these codes. If you are unsure of the Proj4 or EPSG code for the spatial data that you have, but know the CRS, you should consult <a href="http://spatialreference.org/" class="uri">http://spatialreference.org/</a> for assistance.</p>
<p>Please also note that, when working with spatial data, it’s very important that the CRS (coordinate reference system) of the point data and covariates are the same.</p>
<p>Now, we will define our CRS:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb103-1" data-line-number="1">dat<span class="op">@</span>proj4string &lt;-<span class="st"> </span><span class="kw">CRS</span>(<span class="dt">projargs =</span> <span class="st">&quot;+init=epsg:4326&quot;</span>)</a>
<a class="sourceLine" id="cb103-2" data-line-number="2"></a>
<a class="sourceLine" id="cb103-3" data-line-number="3">dat<span class="op">@</span>proj4string</a></code></pre></div>
<pre><code>## CRS arguments:
##  +init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs
## +ellps=WGS84 +towgs84=0,0,0</code></pre>
<p>Now we will import the covariates. When the covariate layers are in common resolution and extent, rather than working with individual rasters it is better to stack them all into a single R object. In this example we use 13 covariates from the GSOCMap Data Repository and a rasterized version of the soil type map. The rasterization of vectorial data was covered in <a href="covariates.html#technical-steps---rasterizing-a-vector-layer-in-r">Technical Steps - Rasterizing a vector layer in R</a>. The file containing all the covariates was prepared at the end of chapter <a href="covariates.html#covariates">5</a>.</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb105-1" data-line-number="1"><span class="kw">load</span>(<span class="dt">file =</span> <span class="st">&quot;covariates.RData&quot;</span>)</a>
<a class="sourceLine" id="cb105-2" data-line-number="2"></a>
<a class="sourceLine" id="cb105-3" data-line-number="3"><span class="kw">names</span>(covs)</a></code></pre></div>
<pre><code>##  [1] &quot;B04CHE3&quot; &quot;B07CHE3&quot; &quot;B13CHE3&quot; &quot;B14CHE3&quot; &quot;DEMENV5&quot; &quot;LCEE10&quot; 
##  [7] &quot;PRSCHE3&quot; &quot;SLPMRG5&quot; &quot;TMDMOD3&quot; &quot;TMNMOD3&quot; &quot;TWIMRG5&quot; &quot;VBFMRG5&quot;
## [13] &quot;VDPMRG5&quot; &quot;soilmap&quot;</code></pre>
</div>
<div id="variable-selection-using-correlation-analysis" class="section level4">
<h4><span class="header-section-number">6.4.1.3</span> Variable selection using correlation analysis</h4>
<div class="sourceCode" id="cb107"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb107-1" data-line-number="1"><span class="co"># plot the names of the covariates</span></a>
<a class="sourceLine" id="cb107-2" data-line-number="2"><span class="kw">names</span>(dat<span class="op">@</span>data)</a></code></pre></div>
<pre><code>##  [1] &quot;id&quot;       &quot;SOC&quot;      &quot;BLD&quot;      &quot;CRFVOL&quot;   &quot;OCSKGM&quot;  
##  [6] &quot;meaERROR&quot; &quot;B04CHE3&quot;  &quot;B07CHE3&quot;  &quot;B13CHE3&quot;  &quot;B14CHE3&quot; 
## [11] &quot;DEMENV5&quot;  &quot;LCEE10&quot;   &quot;PRSCHE3&quot;  &quot;SLPMRG5&quot;  &quot;TMDMOD3&quot; 
## [16] &quot;TMNMOD3&quot;  &quot;TWIMRG5&quot;  &quot;VBFMRG5&quot;  &quot;VDPMRG5&quot;  &quot;soilmap&quot;</code></pre>
<p>For the variable selection we will use <code>cor()</code> function. <code>x</code> must be a table including only the column with the response variable, and <code>y</code> must be a table including ONLY the covariates. Besides, remember <code>dat@data</code> in the <code>data.frame</code> included in the <code>spatialPointsDataFrame</code>. For <code>y</code>, columns 1 to 7 are out, because they are not covariates. At the same time, correlation analysis cannot be applied to categorical covariates, this means that columns 13 and 21 have to be removed too.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb109-1" data-line-number="1">selectedCovs &lt;-<span class="st"> </span><span class="kw">cor</span>(<span class="dt">x =</span> <span class="kw">as.matrix</span>(dat<span class="op">@</span>data[,<span class="dv">5</span>]),</a>
<a class="sourceLine" id="cb109-2" data-line-number="2">           <span class="dt">y =</span> <span class="kw">as.matrix</span>(dat<span class="op">@</span>data[,<span class="op">-</span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>,<span class="dv">12</span>,<span class="dv">20</span>)]))</a>
<a class="sourceLine" id="cb109-3" data-line-number="3"></a>
<a class="sourceLine" id="cb109-4" data-line-number="4"><span class="co"># print correlation results</span></a>
<a class="sourceLine" id="cb109-5" data-line-number="5">selectedCovs</a></code></pre></div>
<pre><code>##         B04CHE3    B07CHE3   B13CHE3   B14CHE3   DEMENV5
## [1,] -0.4113384 -0.3853442 0.3011529 0.3603028 0.3882269
##        PRSCHE3   SLPMRG5    TMDMOD3    TMNMOD3    TWIMRG5
## [1,] 0.3752721 0.2433723 -0.4000728 -0.2857867 -0.2470064
##         VBFMRG5   VDPMRG5
## [1,] -0.1174933 -0.294465</code></pre>
<p>Now we used the correlation results to select the top five covariates.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb111-1" data-line-number="1"><span class="kw">library</span>(reshape)</a>
<a class="sourceLine" id="cb111-2" data-line-number="2">x &lt;-<span class="st"> </span><span class="kw">subset</span>(<span class="kw">melt</span>(selectedCovs), value <span class="op">!=</span><span class="st"> </span><span class="dv">1</span> <span class="op">|</span><span class="st"> </span>value <span class="op">!=</span><span class="st"> </span><span class="ot">NA</span>)</a>
<a class="sourceLine" id="cb111-3" data-line-number="3">x &lt;-<span class="st"> </span>x[<span class="kw">with</span>(x, <span class="kw">order</span>(<span class="op">-</span><span class="kw">abs</span>(x<span class="op">$</span>value))),]</a>
<a class="sourceLine" id="cb111-4" data-line-number="4"></a>
<a class="sourceLine" id="cb111-5" data-line-number="5">idx &lt;-<span class="st"> </span><span class="kw">as.character</span>(x<span class="op">$</span>X2[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>])</a>
<a class="sourceLine" id="cb111-6" data-line-number="6"></a>
<a class="sourceLine" id="cb111-7" data-line-number="7">dat2 &lt;-<span class="st"> </span>dat[<span class="kw">c</span>(<span class="st">&#39;OCSKGM&#39;</span>, idx)]</a>
<a class="sourceLine" id="cb111-8" data-line-number="8"><span class="kw">names</span>(dat2)</a></code></pre></div>
<pre><code>## [1] &quot;OCSKGM&quot;  &quot;B04CHE3&quot; &quot;TMDMOD3&quot; &quot;DEMENV5&quot; &quot;B07CHE3&quot; &quot;PRSCHE3&quot;</code></pre>
<div class="sourceCode" id="cb113"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb113-1" data-line-number="1">COV &lt;-<span class="st"> </span>covs[[idx]]</a>
<a class="sourceLine" id="cb113-2" data-line-number="2"></a>
<a class="sourceLine" id="cb113-3" data-line-number="3"><span class="co"># Selected covariates</span></a>
<a class="sourceLine" id="cb113-4" data-line-number="4"><span class="kw">names</span>(COV)</a></code></pre></div>
<pre><code>## [1] &quot;B04CHE3&quot; &quot;TMDMOD3&quot; &quot;DEMENV5&quot; &quot;B07CHE3&quot; &quot;PRSCHE3&quot;</code></pre>
</div>
<div id="categorical-variables-in-svm-models" class="section level4">
<h4><span class="header-section-number">6.4.1.4</span> Categorical variables in svm models</h4>
<p>According to <span class="citation">Hsu et al. (<a href="#ref-hsu2003practical">2003</a>)</span>, svm requieres each variable to be represented by a vector of real number. This means that factor variables, like <code>covs$LCEE10</code> and <code>covs$soilmap</code>has to be converted into numeric data. In statistics this kind of variables are called boolean indicators or dummy variables. Dummy variables take a value of 0 or 1 indicating the presence of ausence of an specific value/category in our factor covariate, i.e. if we have 5 categories like in <code>covs$LCEE10</code>, we will have 5 dummy variables indicating the presence/ausence of every category. For converting our covariates to dummies we will have to create a new function that returns the dummy rasterStack from the factor version of the rasterLayer.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb115-1" data-line-number="1">dummyRaster &lt;-<span class="st"> </span><span class="cf">function</span>(rast){</a>
<a class="sourceLine" id="cb115-2" data-line-number="2">  rast &lt;-<span class="st"> </span><span class="kw">as.factor</span>(rast)</a>
<a class="sourceLine" id="cb115-3" data-line-number="3">  result &lt;-<span class="st"> </span><span class="kw">list</span>()</a>
<a class="sourceLine" id="cb115-4" data-line-number="4">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(<span class="kw">levels</span>(rast)[[<span class="dv">1</span>]][[<span class="dv">1</span>]])){</a>
<a class="sourceLine" id="cb115-5" data-line-number="5">    result[[i]] &lt;-<span class="st"> </span>rast <span class="op">==</span><span class="st"> </span><span class="kw">levels</span>(rast)[[<span class="dv">1</span>]][[<span class="dv">1</span>]][i]</a>
<a class="sourceLine" id="cb115-6" data-line-number="6">    <span class="kw">names</span>(result[[i]]) &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="kw">names</span>(rast), </a>
<a class="sourceLine" id="cb115-7" data-line-number="7">                                 <span class="kw">levels</span>(rast)[[<span class="dv">1</span>]][[<span class="dv">1</span>]][i])</a>
<a class="sourceLine" id="cb115-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb115-9" data-line-number="9">  <span class="kw">return</span>(<span class="kw">stack</span>(result))</a>
<a class="sourceLine" id="cb115-10" data-line-number="10">}</a></code></pre></div>
<p>We can use the function we just created to convert our categorical covariates to dummies and then stack all the layers together.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb116-1" data-line-number="1"><span class="co"># convert soilmap from factor to dummy</span></a>
<a class="sourceLine" id="cb116-2" data-line-number="2">soilmap_dummy &lt;-<span class="st"> </span><span class="kw">dummyRaster</span>(covs<span class="op">$</span>soilmap)</a>
<a class="sourceLine" id="cb116-3" data-line-number="3"></a>
<a class="sourceLine" id="cb116-4" data-line-number="4"><span class="co"># convert LCEE10 from factor to dummy</span></a>
<a class="sourceLine" id="cb116-5" data-line-number="5">LCEE10_dummy &lt;-<span class="st"> </span><span class="kw">dummyRaster</span>(covs<span class="op">$</span>LCEE10)</a>
<a class="sourceLine" id="cb116-6" data-line-number="6"></a>
<a class="sourceLine" id="cb116-7" data-line-number="7"><span class="co"># Stack the 5 COV layers with the 2 dummies</span></a>
<a class="sourceLine" id="cb116-8" data-line-number="8">COV &lt;-<span class="st"> </span><span class="kw">stack</span>(COV, soilmap_dummy, LCEE10_dummy)</a>
<a class="sourceLine" id="cb116-9" data-line-number="9"></a>
<a class="sourceLine" id="cb116-10" data-line-number="10"><span class="co"># print the final layer names</span></a>
<a class="sourceLine" id="cb116-11" data-line-number="11"><span class="kw">names</span>(COV)</a></code></pre></div>
<pre><code>##  [1] &quot;B04CHE3&quot;   &quot;TMDMOD3&quot;   &quot;DEMENV5&quot;   &quot;B07CHE3&quot;   &quot;PRSCHE3&quot;  
##  [6] &quot;soilmap1&quot;  &quot;soilmap2&quot;  &quot;soilmap3&quot;  &quot;soilmap4&quot;  &quot;soilmap5&quot; 
## [11] &quot;soilmap6&quot;  &quot;soilmap7&quot;  &quot;soilmap8&quot;  &quot;soilmap9&quot;  &quot;soilmap10&quot;
## [16] &quot;soilmap11&quot; &quot;soilmap12&quot; &quot;soilmap13&quot; &quot;soilmap14&quot; &quot;soilmap15&quot;
## [21] &quot;soilmap16&quot; &quot;soilmap17&quot; &quot;soilmap18&quot; &quot;soilmap19&quot; &quot;soilmap20&quot;
## [26] &quot;LCEE101&quot;   &quot;LCEE102&quot;   &quot;LCEE103&quot;   &quot;LCEE104&quot;</code></pre>
<p>We have to convert the collumns with categorical variables in the soil samples <code>data.frame</code> to dummies as well. For doing this we can use function <code>model.matrix()</code>. After this, we use <code>cbind()</code> to merge the resulting <code>data.frame</code>.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb118-1" data-line-number="1"><span class="co"># convert soilmap column to dummy, the result is a matrix</span></a>
<a class="sourceLine" id="cb118-2" data-line-number="2"><span class="co"># to have one column per category we had to add -1 to the formula</span></a>
<a class="sourceLine" id="cb118-3" data-line-number="3">dat_soilmap_dummy &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span>soilmap <span class="dv">-1</span>, <span class="dt">data =</span> dat<span class="op">@</span>data)</a>
<a class="sourceLine" id="cb118-4" data-line-number="4"><span class="co"># convert the matrix to a data.frame</span></a>
<a class="sourceLine" id="cb118-5" data-line-number="5">dat_soilmap_dummy &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(dat_soilmap_dummy)</a>
<a class="sourceLine" id="cb118-6" data-line-number="6"></a>
<a class="sourceLine" id="cb118-7" data-line-number="7"></a>
<a class="sourceLine" id="cb118-8" data-line-number="8"><span class="co"># convert LCEE10 column to dummy, the result is a matrix</span></a>
<a class="sourceLine" id="cb118-9" data-line-number="9"><span class="co"># to have one column per category we had to add -1 to the formula</span></a>
<a class="sourceLine" id="cb118-10" data-line-number="10">dat_LCEE10_dummy &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span>LCEE10 <span class="dv">-1</span>, <span class="dt">data =</span> dat<span class="op">@</span>data)</a>
<a class="sourceLine" id="cb118-11" data-line-number="11"><span class="co"># convert the matrix to a data.frame</span></a>
<a class="sourceLine" id="cb118-12" data-line-number="12">dat_LCEE10_dummy &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(dat_LCEE10_dummy)</a>
<a class="sourceLine" id="cb118-13" data-line-number="13"></a>
<a class="sourceLine" id="cb118-14" data-line-number="14">dat<span class="op">@</span>data &lt;-<span class="st"> </span><span class="kw">cbind</span>(dat<span class="op">@</span>data, dat_LCEE10_dummy, dat_soilmap_dummy)</a>
<a class="sourceLine" id="cb118-15" data-line-number="15"></a>
<a class="sourceLine" id="cb118-16" data-line-number="16"><span class="kw">names</span>(dat<span class="op">@</span>data)</a></code></pre></div>
<pre><code>##  [1] &quot;id&quot;        &quot;SOC&quot;       &quot;BLD&quot;       &quot;CRFVOL&quot;    &quot;OCSKGM&quot;   
##  [6] &quot;meaERROR&quot;  &quot;B04CHE3&quot;   &quot;B07CHE3&quot;   &quot;B13CHE3&quot;   &quot;B14CHE3&quot;  
## [11] &quot;DEMENV5&quot;   &quot;LCEE10&quot;    &quot;PRSCHE3&quot;   &quot;SLPMRG5&quot;   &quot;TMDMOD3&quot;  
## [16] &quot;TMNMOD3&quot;   &quot;TWIMRG5&quot;   &quot;VBFMRG5&quot;   &quot;VDPMRG5&quot;   &quot;soilmap&quot;  
## [21] &quot;LCEE101&quot;   &quot;LCEE102&quot;   &quot;LCEE103&quot;   &quot;LCEE104&quot;   &quot;soilmap1&quot; 
## [26] &quot;soilmap2&quot;  &quot;soilmap3&quot;  &quot;soilmap4&quot;  &quot;soilmap5&quot;  &quot;soilmap6&quot; 
## [31] &quot;soilmap7&quot;  &quot;soilmap8&quot;  &quot;soilmap9&quot;  &quot;soilmap10&quot; &quot;soilmap11&quot;
## [36] &quot;soilmap12&quot; &quot;soilmap13&quot; &quot;soilmap14&quot; &quot;soilmap15&quot; &quot;soilmap16&quot;
## [41] &quot;soilmap17&quot; &quot;soilmap18&quot; &quot;soilmap19&quot; &quot;soilmap20&quot;</code></pre>
</div>
<div id="fitting-a-svm-model" class="section level4">
<h4><span class="header-section-number">6.4.1.5</span> Fitting a svm model</h4>
<p>To improve the model performance the parameters of the svm can be tuned. In this example, we will show how to tune 2 paramenters using a grid search for hyperparameter optimization using the function <code>tune()</code>. The first parameter is epsilon wich is the insensitive-loss function. The default value for epsilon is 0.1, and we will try 11 different value from 0.05 to 0.12 in 0.1 increments. the second parameter is the cost wich is the cost of constraints violation – it is the ‘C’-constant of the regularization term in the Lagrange formulation. The default value for this parameter is 1, and we will try values from 1 to 20 in 5 increments. The value of cost helps us to avoid overfitting. this is a very heavy step in computational terms and can take a lot of time, because we will have to try a lot of different model.</p>
<pre><code>## 
## Attaching package: &#39;e1071&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:raster&#39;:
## 
##     interpolate</code></pre>
<pre><code>## Loading required package: lattice</code></pre>
<pre><code>## Loading required package: ggplot2</code></pre>
<div class="sourceCode" id="cb124"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb124-1" data-line-number="1"><span class="kw">library</span>(e1071)</a>
<a class="sourceLine" id="cb124-2" data-line-number="2"><span class="kw">library</span>(caret)</a>
<a class="sourceLine" id="cb124-3" data-line-number="3"></a>
<a class="sourceLine" id="cb124-4" data-line-number="4"><span class="co">#  Test different values of epsilon and cost</span></a>
<a class="sourceLine" id="cb124-5" data-line-number="5">  tuneResult &lt;-<span class="st"> </span><span class="kw">tune</span>(svm, OCSKGM <span class="op">~</span>.,  <span class="dt">data =</span> dat<span class="op">@</span>data[,<span class="kw">c</span>(<span class="st">&quot;OCSKGM&quot;</span>,</a>
<a class="sourceLine" id="cb124-6" data-line-number="6">                                                         <span class="kw">names</span>(COV))],</a>
<a class="sourceLine" id="cb124-7" data-line-number="7">                     <span class="dt">ranges =</span> <span class="kw">list</span>(<span class="dt">epsilon =</span> <span class="kw">seq</span>(<span class="fl">0.08</span>,<span class="fl">0.16</span>,<span class="fl">0.02</span>),</a>
<a class="sourceLine" id="cb124-8" data-line-number="8">                                   <span class="dt">cost =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>)))</a></code></pre></div>
<p>We can plot the performance of the different models. When the region is darker, the RMSE is closer to zero.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb125-1" data-line-number="1"><span class="kw">plot</span>(tuneResult)</a></code></pre></div>
<div class="figure"><span id="fig:unnamed-chunk-66"></span>
<img src="SOCMapping_files/figure-html4/unnamed-chunk-66-1.png" alt="Performance of the different svm models in the parameter tuning procedure" width="672" />
<p class="caption">
Figure 6.1: Performance of the different svm models in the parameter tuning procedure
</p>
</div>
</div>
<div id="select-the-model-with-the-best-combination-of-epsilon-and-cost" class="section level4">
<h4><span class="header-section-number">6.4.1.6</span> Select the model with the best combination of epsilon and cost</h4>
<p>The best model is chosen as the one with the lowest mean squared error using cross validation. The parameters for the cross validation can be defined in the <code>tune.control()</code> function. By default it uses cross-validation using 10 partitions.</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb126-1" data-line-number="1"><span class="co"># Choose the model with the best combination of epsilon and cost</span></a>
<a class="sourceLine" id="cb126-2" data-line-number="2">tunedModel &lt;-<span class="st"> </span>tuneResult<span class="op">$</span>best.model</a>
<a class="sourceLine" id="cb126-3" data-line-number="3"></a>
<a class="sourceLine" id="cb126-4" data-line-number="4"><span class="kw">print</span>(tunedModel)</a></code></pre></div>
<pre><code>## 
## Call:
## best.tune(method = svm, train.x = OCSKGM ~ ., data = dat@data[, 
##     c(&quot;OCSKGM&quot;, names(COV))], ranges = list(epsilon = seq(0.08, 
##     0.16, 0.02), cost = c(1, 3, 5, 7)))
## 
## 
## Parameters:
##    SVM-Type:  eps-regression 
##  SVM-Kernel:  radial 
##        cost:  7 
##       gamma:  0.03448276 
##     epsilon:  0.16 
## 
## 
## Number of Support Vectors:  2021</code></pre>
</div>
<div id="predict-the-ocs-using-the-model" class="section level4">
<h4><span class="header-section-number">6.4.1.7</span> Predict the OCS using the model</h4>
<div class="sourceCode" id="cb128"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb128-1" data-line-number="1"><span class="co"># Use the model to predict the SOC in the covariates space</span></a>
<a class="sourceLine" id="cb128-2" data-line-number="2">OCSsvm &lt;-<span class="st"> </span><span class="kw">predict</span>(COV, tunedModel)</a>
<a class="sourceLine" id="cb128-3" data-line-number="3"></a>
<a class="sourceLine" id="cb128-4" data-line-number="4"><span class="co"># Save the result</span></a>
<a class="sourceLine" id="cb128-5" data-line-number="5"><span class="kw">writeRaster</span>(OCSsvm, <span class="dt">filename =</span> <span class="st">&quot;MKD_OCSKGM_svm.tif&quot;</span>,</a>
<a class="sourceLine" id="cb128-6" data-line-number="6">            <span class="dt">overwrite=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb128-7" data-line-number="7"></a>
<a class="sourceLine" id="cb128-8" data-line-number="8"><span class="kw">plot</span>(OCSsvm)</a></code></pre></div>
<div class="figure"><span id="fig:unnamed-chunk-68"></span>
<img src="SOCMapping_files/figure-html4/unnamed-chunk-68-1.png" alt="SOC prediction using a support vector machines model" width="672" />
<p class="caption">
Figure 6.2: SOC prediction using a support vector machines model
</p>
</div>
<p>Finally, we can evaluate the contribution of each covariate to the model <span class="citation">(Guyon and Elisseeff <a href="#ref-guyon2003introduction">2003</a>)</span>:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb129-1" data-line-number="1"><span class="co"># Variable importance in svm. Code by:</span></a>
<a class="sourceLine" id="cb129-2" data-line-number="2"><span class="co"># stackoverflow.com/questions/34781495/how-to-find-important-factors-</span></a>
<a class="sourceLine" id="cb129-3" data-line-number="3"><span class="co"># in-support-vector-machine</span></a>
<a class="sourceLine" id="cb129-4" data-line-number="4"></a>
<a class="sourceLine" id="cb129-5" data-line-number="5">w &lt;-<span class="st"> </span><span class="kw">t</span>(tunedModel<span class="op">$</span>coefs) <span class="op">%*%</span><span class="st"> </span>tunedModel<span class="op">$</span>SV     <span class="co"># weight vectors</span></a>
<a class="sourceLine" id="cb129-6" data-line-number="6">w &lt;-<span class="st"> </span><span class="kw">apply</span>(w, <span class="dv">2</span>, <span class="cf">function</span>(v){<span class="kw">sqrt</span>(<span class="kw">sum</span>(v<span class="op">^</span><span class="dv">2</span>))})  <span class="co"># weight</span></a>
<a class="sourceLine" id="cb129-7" data-line-number="7"></a>
<a class="sourceLine" id="cb129-8" data-line-number="8">w &lt;-<span class="st"> </span><span class="kw">sort</span>(w, <span class="dt">decreasing =</span> T)</a>
<a class="sourceLine" id="cb129-9" data-line-number="9"><span class="kw">print</span>(w)</a></code></pre></div>
<pre><code>##    B04CHE3   soilmap6   soilmap5    TMDMOD3    B07CHE3 
## 48.5181779 36.6351274 36.0449325 34.0485122 32.3378609 
##   soilmap1    DEMENV5   soilmap7  soilmap19    PRSCHE3 
## 32.1809132 25.6401090 23.4305524 17.8992281 17.3393922 
##   soilmap2    LCEE103  soilmap16    LCEE104  soilmap17 
## 17.0009036 15.5788471 12.1196627  9.0520670  8.4425467 
##  soilmap20   soilmap4  soilmap13   soilmap3    LCEE101 
##  7.7500310  7.1397809  6.4807586  5.7363280  5.6756611 
##  soilmap15    LCEE102   soilmap8  soilmap10  soilmap18 
##  5.3182848  5.1112395  3.9278181  3.7970340  3.3031788 
##   soilmap9  soilmap12  soilmap14  soilmap11 
##  3.2918996  3.2883060  0.7698098  0.1110606</code></pre>

</div>
</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-hengl2007regression">
<p>Hengl, Tomislav, Gerard BM Heuvelink, and David G Rossiter. 2007. “About Regression-Kriging: From Equations to Case Studies.” <em>Computers &amp; Geosciences</em> 33 (10). Elsevier:1301–15.</p>
</div>
<div id="ref-Breiman1996">
<p>Breiman, Leo. 1996. “Bagging Predictors.” <em>Machine Learning</em> 24 (2):123–40. <a href="https://doi.org/10.1023/A:1018054314350" class="uri">https://doi.org/10.1023/A:1018054314350</a>.</p>
</div>
<div id="ref-Karatzoglou2006">
<p>Karatzoglou, Alexandros, David Meyer, and Kurt Hornik. 2006. “Support Vector Algorithm in R.” <em>Journal of Statistical Software</em> 15 (9):1–28.</p>
</div>
<div id="ref-soil-2017-40">
<p>Guevara, M., G. F. Olmedo, E. Stell, Y. Yigini, Y. Aguilar Duarte, C. Arellano Hernández, G. E. Arévalo, et al. 2018. “No Silver Bullet for Digital Soil Mapping: Country-Specific Soil Organic Carbon Estimates Across Latin America.” <em>SOIL Discussions</em> 2018:1–20. <a href="https://doi.org/10.5194/soil-2017-40" class="uri">https://doi.org/10.5194/soil-2017-40</a>.</p>
</div>
<div id="ref-poggio2013regional">
<p>Poggio, Laura, Alessandro Gimona, and Mark J Brewer. 2013. “Regional Scale Mapping of Soil Properties and Their Uncertainty with a Large Number of Satellite-Derived Covariates.” <em>Geoderma</em> 209. Elsevier:1–14.</p>
</div>
<div id="ref-rad2014updating">
<p>Rad, Mohammad Reza Pahlavan, Norair Toomanian, Farhad Khormali, Colby W Brungard, Chooghi Bayram Komaki, and Patrick Bogaert. 2014. “Updating Soil Survey Maps Using Random Forest and Conditioned Latin Hypercube Sampling in the Loess Derived Soils of Northern Iran.” <em>Geoderma</em> 232. Elsevier:97–106.</p>
</div>
<div id="ref-wiesmeier2011digital">
<p>Wiesmeier, Martin, Frauke Barthold, Benjamin Blank, and Ingrid Kögel-Knabner. 2011. “Digital Mapping of Soil Organic Matter Stocks Using Random Forest Modeling in a Semi-Arid Steppe Ecosystem.” <em>Plant and Soil</em> 340 (1-2). Springer:7–24.</p>
</div>
<div id="ref-scikit-learn">
<p>Pedregosa, F., G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, et al. 2011. “Scikit-Learn: Machine Learning in Python.” <em>Journal of Machine Learning Research</em> 12:2825–30.</p>
</div>
<div id="ref-e1071">
<p>Meyer, David, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel, and Friedrich Leisch. 2017. <em>E1071: Misc Functions of the Department of Statistics, Probability Theory Group (Formerly: E1071), Tu Wien</em>. <a href="https://CRAN.R-project.org/package=e1071" class="uri">https://CRAN.R-project.org/package=e1071</a>.</p>
</div>
<div id="ref-chang2001libsvm">
<p>Chang, Chih-Chung, and Chih-Jen Lin. 2001. “LIBSVM: A Library for Support Vector Machines [Eb/Ol].”</p>
</div>
<div id="ref-vapnik2013nature">
<p>Vapnik, Vladimir. 2013. <em>The Nature of Statistical Learning Theory</em>. Springer science &amp; business media.</p>
</div>
<div id="ref-friedman2001elements">
<p>Friedman, Jerome, Trevor Hastie, and Robert Tibshirani. 2001. <em>The Elements of Statistical Learning</em>. Vol. 1. Springer series in statistics New York.</p>
</div>
<div id="ref-james2013introduction">
<p>James, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2013. <em>An Introduction to Statistical Learning</em>. Vol. 112. Springer.</p>
</div>
<div id="ref-hsu2003practical">
<p>Hsu, Chih-Wei, Chih-Chung Chang, Chih-Jen Lin, and others. 2003. “A Practical Guide to Support Vector Classification.” Taipei.</p>
</div>
<div id="ref-guyon2003introduction">
<p>Guyon, Isabelle, and André Elisseeff. 2003. “An Introduction to Variable and Feature Selection.” <em>Journal of Machine Learning Research</em> 3 (Mar):1157–82.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="covariates.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="validation.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/061-mapping.Rmd",
"text": "Edit"
},
"download": ["SOCMapping.pdf", "SOCMapping.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
