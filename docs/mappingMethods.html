<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Soil Organic Carbon Mapping cookbook</title>
  <meta name="description" content="The soilll cookbook.">
  <meta name="generator" content="bookdown 0.5.15 and GitBook 2.6.7">

  <meta property="og:title" content="Soil Organic Carbon Mapping cookbook" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="images/cover.png" />
  <meta property="og:description" content="The soilll cookbook." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Soil Organic Carbon Mapping cookbook" />
  
  <meta name="twitter:description" content="The soilll cookbook." />
  <meta name="twitter:image" content="images/cover.png" />

<meta name="author" content="">


<meta name="date" content="2018-02-20">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="covariates.html">
<link rel="next" href="chvalidation.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Copyright and disclaimer</a></li>
<li class="chapter" data-level="" data-path="foreword.html"><a href="foreword.html"><i class="fa fa-check"></i>Foreword</a><ul>
<li class="chapter" data-level="" data-path="foreword.html"><a href="foreword.html#editorial-board"><i class="fa fa-check"></i>Editorial Board</a></li>
<li class="chapter" data-level="" data-path="foreword.html"><a href="foreword.html#contributing-authors"><i class="fa fa-check"></i>Contributing Authors</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="presentation.html"><a href="presentation.html"><i class="fa fa-check"></i><b>1</b> Presentation</a></li>
<li class="chapter" data-level="2" data-path="soil-property-maps.html"><a href="soil-property-maps.html"><i class="fa fa-check"></i><b>2</b> Soil Property Maps</a><ul>
<li class="chapter" data-level="2.1" data-path="soil-property-maps.html"><a href="soil-property-maps.html#definitions-and-objectives"><i class="fa fa-check"></i><b>2.1</b> Definitions and Objectives</a></li>
<li class="chapter" data-level="2.2" data-path="soil-property-maps.html"><a href="soil-property-maps.html#generic-mapping-of-soil-grids-upscaling-of-plot-level-measurements-and-estimates"><i class="fa fa-check"></i><b>2.2</b> Generic Mapping of Soil Grids: Upscaling of Plot-Level Measurements and Estimates</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="preparation.html"><a href="preparation.html"><i class="fa fa-check"></i><b>3</b> Preparation of Local Soil Data</a><ul>
<li class="chapter" data-level="3.1" data-path="preparation.html"><a href="preparation.html#soil-profiles-and-soil-augers"><i class="fa fa-check"></i><b>3.1</b> Soil Profiles and Soil Augers</a></li>
<li class="chapter" data-level="3.2" data-path="preparation.html"><a href="preparation.html#soil-database"><i class="fa fa-check"></i><b>3.2</b> Soil Database</a><ul>
<li class="chapter" data-level="3.2.1" data-path="preparation.html"><a href="preparation.html#technical-steps---loading-data-from-tables-in-r"><i class="fa fa-check"></i><b>3.2.1</b> Technical Steps - Loading Data from Tables in R</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="preparation.html"><a href="preparation.html#completeness-of-measurements-and-estimates"><i class="fa fa-check"></i><b>3.3</b> Completeness of Measurements and Estimates</a><ul>
<li class="chapter" data-level="3.3.1" data-path="preparation.html"><a href="preparation.html#stones"><i class="fa fa-check"></i><b>3.3.1</b> Stones</a></li>
<li class="chapter" data-level="3.3.2" data-path="preparation.html"><a href="preparation.html#bulk-density"><i class="fa fa-check"></i><b>3.3.2</b> Bulk density</a></li>
<li class="chapter" data-level="3.3.3" data-path="preparation.html"><a href="preparation.html#soil-carbon-analysis"><i class="fa fa-check"></i><b>3.3.3</b> Soil Carbon Analysis</a></li>
<li class="chapter" data-level="3.3.4" data-path="preparation.html"><a href="preparation.html#carbonates"><i class="fa fa-check"></i><b>3.3.4</b> Carbonates</a></li>
<li class="chapter" data-level="3.3.5" data-path="preparation.html"><a href="preparation.html#depth"><i class="fa fa-check"></i><b>3.3.5</b> Depth</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="preparation.html"><a href="preparation.html#completeness-of-depth-estimate"><i class="fa fa-check"></i><b>3.4</b> Completeness of Depth Estimate</a><ul>
<li class="chapter" data-level="3.4.1" data-path="preparation.html"><a href="preparation.html#EqualAreaSplines"><i class="fa fa-check"></i><b>3.4.1</b> Technical Steps - Equal-Area Splines Using R</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html"><i class="fa fa-check"></i><b>4</b> Setting-Up the Software Environment</a><ul>
<li class="chapter" data-level="4.1" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#use-of-r-rstudio-and-r-packages"><i class="fa fa-check"></i><b>4.1</b> Use of R, RStudio and R Packages</a><ul>
<li class="chapter" data-level="4.1.1" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#obtaining-and-installing-r"><i class="fa fa-check"></i><b>4.1.1</b> Obtaining and Installing R</a></li>
<li class="chapter" data-level="4.1.2" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#obtaining-and-installing-r-studio"><i class="fa fa-check"></i><b>4.1.2</b> Obtaining and Installing R Studio</a></li>
<li class="chapter" data-level="4.1.3" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#getting-started-with-r"><i class="fa fa-check"></i><b>4.1.3</b> Getting Started with R</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#r-packages"><i class="fa fa-check"></i><b>4.2</b> R Packages</a><ul>
<li class="chapter" data-level="4.2.1" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#finding-r-packages"><i class="fa fa-check"></i><b>4.2.1</b> Finding R Packages</a></li>
<li class="chapter" data-level="4.2.2" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#most-used-r-packages-for-digital-soil-mapping"><i class="fa fa-check"></i><b>4.2.2</b> Most Used R Packages for Digital Soil Mapping</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#r-and-spatial-data"><i class="fa fa-check"></i><b>4.3</b> R and Spatial Data</a><ul>
<li class="chapter" data-level="4.3.1" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#reading-shapefiles"><i class="fa fa-check"></i><b>4.3.1</b> Reading Shapefiles</a></li>
<li class="chapter" data-level="4.3.2" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#coordinate-reference-systems-crs-in-r"><i class="fa fa-check"></i><b>4.3.2</b> Coordinate Reference Systems (CRS) in R</a></li>
<li class="chapter" data-level="4.3.3" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#working-with-rasters"><i class="fa fa-check"></i><b>4.3.3</b> Working with Rasters</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="setting-up-the-software-environment.html"><a href="setting-up-the-software-environment.html#other-dsm-related-software-and-tools"><i class="fa fa-check"></i><b>4.4</b> Other DSM Related Software and Tools</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="covariates.html"><a href="covariates.html"><i class="fa fa-check"></i><b>5</b> Preparation of Spatial covariates</a><ul>
<li class="chapter" data-level="5.1" data-path="covariates.html"><a href="covariates.html#dem-derived-covariates"><i class="fa fa-check"></i><b>5.1</b> DEM-Derived Covariates</a><ul>
<li class="chapter" data-level="5.1.1" data-path="covariates.html"><a href="covariates.html#dem-source-data-sets"><i class="fa fa-check"></i><b>5.1.1</b> DEM Source Data Sets</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="covariates.html"><a href="covariates.html#parent-material"><i class="fa fa-check"></i><b>5.2</b> Parent Material</a></li>
<li class="chapter" data-level="5.3" data-path="covariates.html"><a href="covariates.html#soil-maps"><i class="fa fa-check"></i><b>5.3</b> Soil Maps</a><ul>
<li class="chapter" data-level="5.3.1" data-path="covariates.html"><a href="covariates.html#technical-steps---rasterizing-a-vector-layer-in-r"><i class="fa fa-check"></i><b>5.3.1</b> Technical Steps - Rasterizing a Vector Layer in R</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="covariates.html"><a href="covariates.html#land-cover-and-land-use"><i class="fa fa-check"></i><b>5.4</b> Land Cover and Land use</a><ul>
<li class="chapter" data-level="5.4.1" data-path="covariates.html"><a href="covariates.html#globcover-global"><i class="fa fa-check"></i><b>5.4.1</b> GlobCover (Global)</a></li>
<li class="chapter" data-level="5.4.2" data-path="covariates.html"><a href="covariates.html#landsat-geocover-global"><i class="fa fa-check"></i><b>5.4.2</b> Landsat GeoCover (Global)</a></li>
<li class="chapter" data-level="5.4.3" data-path="covariates.html"><a href="covariates.html#globeland30-global"><i class="fa fa-check"></i><b>5.4.3</b> Globeland30 (Global)</a></li>
<li class="chapter" data-level="5.4.4" data-path="covariates.html"><a href="covariates.html#corine-land-cover-europe-only"><i class="fa fa-check"></i><b>5.4.4</b> CORINE Land Cover (Europe Only)</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="covariates.html"><a href="covariates.html#climate"><i class="fa fa-check"></i><b>5.5</b> Climate</a><ul>
<li class="chapter" data-level="5.5.1" data-path="covariates.html"><a href="covariates.html#worldclim-v1.4-and-v2-global"><i class="fa fa-check"></i><b>5.5.1</b> WorldClim V1.4 and V2 (Global)</a></li>
<li class="chapter" data-level="5.5.2" data-path="covariates.html"><a href="covariates.html#gridded-agro-meteorological-data-in-europe-europe"><i class="fa fa-check"></i><b>5.5.2</b> Gridded Agro-Meteorological Data in Europe (Europe)</a></li>
</ul></li>
<li class="chapter" data-level="5.6" data-path="covariates.html"><a href="covariates.html#GSOCDataRepo"><i class="fa fa-check"></i><b>5.6</b> GSOCMap - Data Repository (ISRIC, 2017)</a><ul>
<li class="chapter" data-level="5.6.1" data-path="covariates.html"><a href="covariates.html#covariates-and-empty-mask"><i class="fa fa-check"></i><b>5.6.1</b> Covariates and Empty Mask</a></li>
<li class="chapter" data-level="5.6.2" data-path="covariates.html"><a href="covariates.html#data-specifications"><i class="fa fa-check"></i><b>5.6.2</b> Data Specifications</a></li>
<li class="chapter" data-level="5.6.3" data-path="covariates.html"><a href="covariates.html#data-access"><i class="fa fa-check"></i><b>5.6.3</b> Data Access</a></li>
</ul></li>
<li class="chapter" data-level="5.7" data-path="covariates.html"><a href="covariates.html#extending-the-soil-property-table-for-spatial-statistics"><i class="fa fa-check"></i><b>5.7</b> Extending the Soil Property Table for Spatial Statistics</a></li>
<li class="chapter" data-level="5.8" data-path="covariates.html"><a href="covariates.html#preparation-of-a-soil-property-table-for-spatial-statistics"><i class="fa fa-check"></i><b>5.8</b> Preparation of a Soil Property Table for Spatial Statistics</a></li>
<li class="chapter" data-level="5.9" data-path="covariates.html"><a href="covariates.html#overlay-soil-covariates"><i class="fa fa-check"></i><b>5.9</b> Technical Steps - Overlay Covariates and Soil Points Data</a><ul>
<li class="chapter" data-level="5.9.1" data-path="covariates.html"><a href="covariates.html#load-soil-sample-data-and-covariates"><i class="fa fa-check"></i><b>5.9.1</b> Load soil sample data and covariates</a></li>
<li class="chapter" data-level="5.9.2" data-path="covariates.html"><a href="covariates.html#combine-the-covariates-provided-with-the-raster-version-of-the-soil-map"><i class="fa fa-check"></i><b>5.9.2</b> Combine the covariates provided with the raster version of the soil map</a></li>
<li class="chapter" data-level="5.9.3" data-path="covariates.html"><a href="covariates.html#overlay-covariates-and-spatial-data"><i class="fa fa-check"></i><b>5.9.3</b> Overlay Covariates and Spatial Data</a></li>
<li class="chapter" data-level="5.9.4" data-path="covariates.html"><a href="covariates.html#convert-result-to-data.frame-and-save-as-a-csv-table"><i class="fa fa-check"></i><b>5.9.4</b> Convert result to data.frame and save as a csv table</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="mappingMethods.html"><a href="mappingMethods.html"><i class="fa fa-check"></i><b>6</b> Mapping Methods</a><ul>
<li class="chapter" data-level="6.1" data-path="mappingMethods.html"><a href="mappingMethods.html#conventional-upscaling-using-soil-maps"><i class="fa fa-check"></i><b>6.1</b> Conventional Upscaling Using Soil Maps</a><ul>
<li class="chapter" data-level="6.1.1" data-path="mappingMethods.html"><a href="mappingMethods.html#overview"><i class="fa fa-check"></i><b>6.1.1</b> Overview</a></li>
<li class="chapter" data-level="6.1.2" data-path="mappingMethods.html"><a href="mappingMethods.html#technical-steps-class-matching"><i class="fa fa-check"></i><b>6.1.2</b> Technical Steps: Class-matching</a></li>
<li class="chapter" data-level="6.1.3" data-path="mappingMethods.html"><a href="mappingMethods.html#technical-steps-geo-matching"><i class="fa fa-check"></i><b>6.1.3</b> Technical Steps: Geo-Matching</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="mappingMethods.html"><a href="mappingMethods.html#RK"><i class="fa fa-check"></i><b>6.2</b> Regression-Kriging</a><ul>
<li class="chapter" data-level="6.2.1" data-path="mappingMethods.html"><a href="mappingMethods.html#overview-1"><i class="fa fa-check"></i><b>6.2.1</b> Overview</a></li>
<li class="chapter" data-level="6.2.2" data-path="mappingMethods.html"><a href="mappingMethods.html#assumptions"><i class="fa fa-check"></i><b>6.2.2</b> Assumptions</a></li>
<li class="chapter" data-level="6.2.3" data-path="mappingMethods.html"><a href="mappingMethods.html#pre-processing-of-covariates"><i class="fa fa-check"></i><b>6.2.3</b> Pre-Processing of Covariates</a></li>
<li class="chapter" data-level="6.2.4" data-path="mappingMethods.html"><a href="mappingMethods.html#the-terminology"><i class="fa fa-check"></i><b>6.2.4</b> The Terminology</a></li>
<li class="chapter" data-level="6.2.5" data-path="mappingMethods.html"><a href="mappingMethods.html#interpret-the-key-results-of-multiple-regression"><i class="fa fa-check"></i><b>6.2.5</b> Interpret the Key Results of Multiple Regression</a></li>
<li class="chapter" data-level="6.2.6" data-path="mappingMethods.html"><a href="mappingMethods.html#using-the-results-of-a-regression-analysis-to-make-predictions"><i class="fa fa-check"></i><b>6.2.6</b> Using the Results of a Regression Analysis to Make Predictions</a></li>
<li class="chapter" data-level="6.2.7" data-path="mappingMethods.html"><a href="mappingMethods.html#technical-steps---regression-kriging"><i class="fa fa-check"></i><b>6.2.7</b> Technical Steps - Regression Kriging</a></li>
<li class="chapter" data-level="6.2.8" data-path="mappingMethods.html"><a href="mappingMethods.html#technical-steps---cross-validation-of-regression-kriging-models"><i class="fa fa-check"></i><b>6.2.8</b> Technical Steps - Cross-validation of Regression Kriging models</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="mappingMethods.html"><a href="mappingMethods.html#rf"><i class="fa fa-check"></i><b>6.3</b> Data mining: Random Forest</a><ul>
<li class="chapter" data-level="6.3.1" data-path="mappingMethods.html"><a href="mappingMethods.html#overview-2"><i class="fa fa-check"></i><b>6.3.1</b> Overview</a></li>
<li class="chapter" data-level="6.3.2" data-path="mappingMethods.html"><a href="mappingMethods.html#random-forests"><i class="fa fa-check"></i><b>6.3.2</b> Random forests</a></li>
<li class="chapter" data-level="6.3.3" data-path="mappingMethods.html"><a href="mappingMethods.html#conceptual-model-and-data-preparation"><i class="fa fa-check"></i><b>6.3.3</b> Conceptual model and data preparation</a></li>
<li class="chapter" data-level="6.3.4" data-path="mappingMethods.html"><a href="mappingMethods.html#software"><i class="fa fa-check"></i><b>6.3.4</b> Software</a></li>
<li class="chapter" data-level="6.3.5" data-path="mappingMethods.html"><a href="mappingMethods.html#tunning-random-forest-parameters"><i class="fa fa-check"></i><b>6.3.5</b> Tunning Random forest parameters</a></li>
<li class="chapter" data-level="6.3.6" data-path="mappingMethods.html"><a href="mappingMethods.html#technical-steps---random-forest"><i class="fa fa-check"></i><b>6.3.6</b> Technical steps - Random forest</a></li>
<li class="chapter" data-level="6.3.7" data-path="mappingMethods.html"><a href="mappingMethods.html#modelling-uncertainty-using-random-forest"><i class="fa fa-check"></i><b>6.3.7</b> Modelling Uncertainty Using Random Forest</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="mappingMethods.html"><a href="mappingMethods.html#svm"><i class="fa fa-check"></i><b>6.4</b> Data mining: Support Vector Machines</a><ul>
<li class="chapter" data-level="6.4.1" data-path="mappingMethods.html"><a href="mappingMethods.html#overview-3"><i class="fa fa-check"></i><b>6.4.1</b> Overview</a></li>
<li class="chapter" data-level="6.4.2" data-path="mappingMethods.html"><a href="mappingMethods.html#technical-steps---fitting-an-svm-model-to-predict-the-soc"><i class="fa fa-check"></i><b>6.4.2</b> Technical Steps - Fitting an SVM Model to Predict the SOC</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="chvalidation.html"><a href="chvalidation.html"><i class="fa fa-check"></i><b>7</b> Validation</a><ul>
<li class="chapter" data-level="7.1" data-path="chvalidation.html"><a href="chvalidation.html#what-is-validation"><i class="fa fa-check"></i><b>7.1</b> What is Validation?</a></li>
<li class="chapter" data-level="7.2" data-path="chvalidation.html"><a href="chvalidation.html#map-quality-measures"><i class="fa fa-check"></i><b>7.2</b> Map Quality Measures</a><ul>
<li class="chapter" data-level="7.2.1" data-path="chvalidation.html"><a href="chvalidation.html#quality-measures-for-quantitative-soil-maps"><i class="fa fa-check"></i><b>7.2.1</b> Quality Measures for Quantitative Soil Maps</a></li>
<li class="chapter" data-level="7.2.2" data-path="chvalidation.html"><a href="chvalidation.html#quality-measures-for-qualitative-soil-maps"><i class="fa fa-check"></i><b>7.2.2</b> Quality Measures for Qualitative Soil Maps</a></li>
<li class="chapter" data-level="7.2.3" data-path="chvalidation.html"><a href="chvalidation.html#estimating-the-map-quality-measures-and-associated-uncertainty"><i class="fa fa-check"></i><b>7.2.3</b> Estimating the Map Quality Measures and Associated Uncertainty</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="chvalidation.html"><a href="chvalidation.html#graphical-map-quality-measures"><i class="fa fa-check"></i><b>7.3</b> Graphical Map Quality Measures</a></li>
<li class="chapter" data-level="7.4" data-path="chvalidation.html"><a href="chvalidation.html#validation-methods-and-statistical-inference"><i class="fa fa-check"></i><b>7.4</b> Validation Methods and Statistical Inference</a><ul>
<li class="chapter" data-level="7.4.1" data-path="chvalidation.html"><a href="chvalidation.html#additional-probability-sampling"><i class="fa fa-check"></i><b>7.4.1</b> Additional Probability Sampling</a></li>
<li class="chapter" data-level="7.4.2" data-path="chvalidation.html"><a href="chvalidation.html#data-splitting"><i class="fa fa-check"></i><b>7.4.2</b> Data-Splitting</a></li>
<li class="chapter" data-level="7.4.3" data-path="chvalidation.html"><a href="chvalidation.html#xval"><i class="fa fa-check"></i><b>7.4.3</b> Cross-Validation</a></li>
</ul></li>
<li class="chapter" data-level="7.5" data-path="chvalidation.html"><a href="chvalidation.html#TS:validation"><i class="fa fa-check"></i><b>7.5</b> Technical steps - Validation</a><ul>
<li class="chapter" data-level="7.5.1" data-path="chvalidation.html"><a href="chvalidation.html#prediction-error"><i class="fa fa-check"></i><b>7.5.1</b> Prediction error</a></li>
<li class="chapter" data-level="7.5.2" data-path="chvalidation.html"><a href="chvalidation.html#estimating-the-map-quality-measures"><i class="fa fa-check"></i><b>7.5.2</b> Estimating the Map Quality Measures</a></li>
<li class="chapter" data-level="7.5.3" data-path="chvalidation.html"><a href="chvalidation.html#graphical-map-quality-measures-1"><i class="fa fa-check"></i><b>7.5.3</b> Graphical Map Quality Measures</a></li>
<li class="chapter" data-level="7.5.4" data-path="chvalidation.html"><a href="chvalidation.html#dataSplit"><i class="fa fa-check"></i><b>7.5.4</b> Data-Splitting</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="model-evaluation-in-digital-soil-mapping.html"><a href="model-evaluation-in-digital-soil-mapping.html"><i class="fa fa-check"></i><b>8</b> Model Evaluation in Digital Soil Mapping</a><ul>
<li class="chapter" data-level="8.1" data-path="model-evaluation-in-digital-soil-mapping.html"><a href="model-evaluation-in-digital-soil-mapping.html#technical-steps---model-correlations-and-spatial-differences"><i class="fa fa-check"></i><b>8.1</b> Technical steps - Model correlations and spatial differences</a></li>
<li class="chapter" data-level="8.2" data-path="model-evaluation-in-digital-soil-mapping.html"><a href="model-evaluation-in-digital-soil-mapping.html#technical-steps---model-evaluation"><i class="fa fa-check"></i><b>8.2</b> Technical steps - Model evaluation</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="uncertainty.html"><a href="uncertainty.html"><i class="fa fa-check"></i><b>9</b> Uncertainty</a><ul>
<li class="chapter" data-level="9.1" data-path="uncertainty.html"><a href="uncertainty.html#sources-of-uncertainty"><i class="fa fa-check"></i><b>9.1</b> Sources of Uncertainty</a><ul>
<li class="chapter" data-level="9.1.1" data-path="uncertainty.html"><a href="uncertainty.html#attribute-uncertainty-of-soil-measurements"><i class="fa fa-check"></i><b>9.1.1</b> Attribute Uncertainty of Soil Measurements</a></li>
<li class="chapter" data-level="9.1.2" data-path="uncertainty.html"><a href="uncertainty.html#positional-uncertainty-of-soil-measurements"><i class="fa fa-check"></i><b>9.1.2</b> Positional Uncertainty of Soil Measurements</a></li>
<li class="chapter" data-level="9.1.3" data-path="uncertainty.html"><a href="uncertainty.html#uncertainty-in-covariates"><i class="fa fa-check"></i><b>9.1.3</b> Uncertainty in Covariates</a></li>
<li class="chapter" data-level="9.1.4" data-path="uncertainty.html"><a href="uncertainty.html#uncertainty-in-models-predicting-soil-properties-from-covariates-and-soil-point-data"><i class="fa fa-check"></i><b>9.1.4</b> Uncertainty in Models Predicting Soil Properties From Covariates and Soil Point Data</a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="uncertainty.html"><a href="uncertainty.html#uncertainty-and-spatial-data-quality"><i class="fa fa-check"></i><b>9.2</b> Uncertainty and Spatial Data Quality</a></li>
<li class="chapter" data-level="9.3" data-path="uncertainty.html"><a href="uncertainty.html#quantifying-prediction-uncertainty"><i class="fa fa-check"></i><b>9.3</b> Quantifying Prediction Uncertainty</a><ul>
<li class="chapter" data-level="9.3.1" data-path="uncertainty.html"><a href="uncertainty.html#uncertainty-characterised-by-probability-distributions"><i class="fa fa-check"></i><b>9.3.1</b> Uncertainty Characterised by Probability Distributions</a></li>
<li class="chapter" data-level="9.3.2" data-path="uncertainty.html"><a href="uncertainty.html#propagation-of-model-uncertainty"><i class="fa fa-check"></i><b>9.3.2</b> Propagation of Model Uncertainty</a></li>
<li class="chapter" data-level="9.3.3" data-path="uncertainty.html"><a href="uncertainty.html#propagation-of-attribute-positional-and-covariate-uncertainty"><i class="fa fa-check"></i><b>9.3.3</b> Propagation of Attribute, Positional and Covariate Uncertainty</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="data-sharing.html"><a href="data-sharing.html"><i class="fa fa-check"></i><b>10</b> Data Sharing</a><ul>
<li class="chapter" data-level="10.1" data-path="data-sharing.html"><a href="data-sharing.html#export-formats"><i class="fa fa-check"></i><b>10.1</b> Export Formats</a><ul>
<li class="chapter" data-level="10.1.1" data-path="data-sharing.html"><a href="data-sharing.html#type-of-soil-data-and-their-formatting"><i class="fa fa-check"></i><b>10.1.1</b> Type of Soil Data and Their Formatting</a></li>
<li class="chapter" data-level="10.1.2" data-path="data-sharing.html"><a href="data-sharing.html#general-gis-data-formats-vector-raster-table"><i class="fa fa-check"></i><b>10.1.2</b> General GIS Data Formats: Vector, Raster, Table</a></li>
<li class="chapter" data-level="10.1.3" data-path="data-sharing.html"><a href="data-sharing.html#recommended-gis-data-exchange-formats"><i class="fa fa-check"></i><b>10.1.3</b> Recommended GIS Data Exchange Formats</a></li>
</ul></li>
<li class="chapter" data-level="10.2" data-path="data-sharing.html"><a href="data-sharing.html#web-services---serving-soil-data-using-web-technology"><i class="fa fa-check"></i><b>10.2</b> Web Services - Serving Soil Data Using Web Technology</a><ul>
<li class="chapter" data-level="10.2.1" data-path="data-sharing.html"><a href="data-sharing.html#third-party-services"><i class="fa fa-check"></i><b>10.2.1</b> Third-Party Services</a></li>
<li class="chapter" data-level="10.2.2" data-path="data-sharing.html"><a href="data-sharing.html#geoserver-web-serving-and-web-processing"><i class="fa fa-check"></i><b>10.2.2</b> GeoServer (Web Serving and Web Processing)</a></li>
<li class="chapter" data-level="10.2.3" data-path="data-sharing.html"><a href="data-sharing.html#visualizing-data-using-leaflet-andor-google-earth"><i class="fa fa-check"></i><b>10.2.3</b> Visualizing Data Using Leaflet and/or Google Earth</a></li>
</ul></li>
<li class="chapter" data-level="10.3" data-path="data-sharing.html"><a href="data-sharing.html#preparing-soil-data-for-distribution"><i class="fa fa-check"></i><b>10.3</b> Preparing Soil Data for Distribution</a><ul>
<li class="chapter" data-level="10.3.1" data-path="data-sharing.html"><a href="data-sharing.html#metadata"><i class="fa fa-check"></i><b>10.3.1</b> Metadata</a></li>
<li class="chapter" data-level="10.3.2" data-path="data-sharing.html"><a href="data-sharing.html#exporting-data-final-tips"><i class="fa fa-check"></i><b>10.3.2</b> Exporting Data — Final Tips</a></li>
</ul></li>
<li class="chapter" data-level="10.4" data-path="data-sharing.html"><a href="data-sharing.html#export-formats-1"><i class="fa fa-check"></i><b>10.4</b> Export Formats</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html"><i class="fa fa-check"></i><b>11</b> Technical Overview and the Checklist</a><ul>
<li class="chapter" data-level="11.1" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html#point-dataset"><i class="fa fa-check"></i><b>11.1</b> Point Dataset</a></li>
<li class="chapter" data-level="11.2" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html#covariates-1"><i class="fa fa-check"></i><b>11.2</b> Covariates</a></li>
<li class="chapter" data-level="11.3" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html#statistical-inference"><i class="fa fa-check"></i><b>11.3</b> Statistical Inference</a></li>
<li class="chapter" data-level="11.4" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html#spatial-interpolation"><i class="fa fa-check"></i><b>11.4</b> Spatial Interpolation</a></li>
<li class="chapter" data-level="11.5" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html#calculation-of-stocks"><i class="fa fa-check"></i><b>11.5</b> Calculation of Stocks</a></li>
<li class="chapter" data-level="11.6" data-path="technical-overview-and-the-checklist.html"><a href="technical-overview-and-the-checklist.html#evaluation-of-output-and-quality-assessment"><i class="fa fa-check"></i><b>11.6</b> Evaluation of Output and Quality Assessment</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="deliverables.html"><a href="deliverables.html"><i class="fa fa-check"></i><b>12</b> Deliverables</a></li>
<li class="chapter" data-level="13" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html"><i class="fa fa-check"></i><b>13</b> Compendium of the code examples included in the cookbook</a><ul>
<li class="chapter" data-level="13.1" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#overview-4"><i class="fa fa-check"></i><b>13.1</b> Overview</a></li>
<li class="chapter" data-level="13.2" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:PreparationProfiles"><i class="fa fa-check"></i><b>13.2</b> Data Preparation for Soil Profiles</a></li>
<li class="chapter" data-level="13.3" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:PreparationAuger"><i class="fa fa-check"></i><b>13.3</b> Data Preparation for Top Soil or Auger Samples</a></li>
<li class="chapter" data-level="13.4" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:merging"><i class="fa fa-check"></i><b>13.4</b> Merging Top Soil and Soil Profiles Databases</a></li>
<li class="chapter" data-level="13.5" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:data-splitting"><i class="fa fa-check"></i><b>13.5</b> Data-Splitting</a></li>
<li class="chapter" data-level="13.6" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:Rasterizing"><i class="fa fa-check"></i><b>13.6</b> Rasterizing a Vector Layer in R</a></li>
<li class="chapter" data-level="13.7" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:Overlay"><i class="fa fa-check"></i><b>13.7</b> Overlay Covariates and Soil Points Data</a></li>
<li class="chapter" data-level="13.8" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:RK"><i class="fa fa-check"></i><b>13.8</b> Fitting a Regression-Kriging model to predict the OCS</a><ul>
<li class="chapter" data-level="13.8.1" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:xvalRK"><i class="fa fa-check"></i><b>13.8.1</b> Cross-validation of Regression Kriging models</a></li>
</ul></li>
<li class="chapter" data-level="13.9" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:rf"><i class="fa fa-check"></i><b>13.9</b> Fitting a random forest model to predict the SOC</a></li>
<li class="chapter" data-level="13.10" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:quantreg"><i class="fa fa-check"></i><b>13.10</b> Using Quantile Regression Forest to estimate uncertainty</a></li>
<li class="chapter" data-level="13.11" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:svm"><i class="fa fa-check"></i><b>13.11</b> Fitting a svm model to predict the SOC</a></li>
<li class="chapter" data-level="13.12" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:Validation"><i class="fa fa-check"></i><b>13.12</b> Validation</a></li>
<li class="chapter" data-level="13.13" data-path="compendium-of-the-code-examples-included-in-the-cookbook.html"><a href="compendium-of-the-code-examples-included-in-the-cookbook.html#cd:Graphs"><i class="fa fa-check"></i><b>13.13</b> Graphical Map Quality Measures</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Soil Organic Carbon Mapping cookbook</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="mappingMethods" class="section level1">
<h1><span class="header-section-number">Chapter 6</span> Mapping Methods</h1>
<p><em>R Baritz, M Guevara, VL Mulder, GF Olmedo, C Thine, RR Vargas, Y Yigini</em></p>
<p>In this chapter, we want to introduce 5 different approaches for obtaining the SOC map for FYROM. The first two methods presented are classified as conventional upscaling. The first one is class-matching. In this approach, we derive average SOC stocks per class: soil type for which a national map exists, or combination with other spatial covariates (e.g. land use category, climate type, biome, etc.). This approach is used in the absence of spatial coordinates of the source data. The second one is geo-matching, were upscaling is based on averaged SOC values per mapping unit. Then, we present 3 methods from digital soil mapping. Regression-Kriging is a hybrid model with both, a deterministic and a stochastic component <span class="citation">(Hengl, Heuvelink, and Rossiter <a href="#ref-hengl2007regression">2007</a>)</span>. Next method is called random forest. This one is an ensemble of regression trees based on bagging. This machine learning algorithm uses a different combination of prediction factors to train multiple regression trees <span class="citation">(Breiman <a href="#ref-Breiman1996">1996</a>)</span>. The last method is called Support Vector Machines (SVM). This method applies a simple linear method to the data but in a high-dimensional feature space non-linearly related to the input space <span class="citation">(Karatzoglou, Meyer, and Hornik <a href="#ref-Karatzoglou2006">2006</a>)</span>. We present this diversity of methods because there is no best mapping method for digital soil mapping, and testing and selection has to be done for every data scenario <span class="citation">(Guevara et al. <a href="#ref-soil-2017-40">2018</a>)</span>.</p>
<div id="conventional-upscaling-using-soil-maps" class="section level2">
<h2><span class="header-section-number">6.1</span> Conventional Upscaling Using Soil Maps</h2>
<p><em>R Baritz, VL Mulder</em></p>
<div id="overview" class="section level3">
<h3><span class="header-section-number">6.1.1</span> Overview</h3>
<p>The two conventional upscaling methods, in the context of SOC mapping, are described by . Details about weighted averaging can be found in . Different conventional upscaling approaches were applied in many countries (Baritz et al. 1999 (Germany),  (Mexico),  (Denmark), Koelli et al. 2009 (Estonia),  (France),  (Canada)). Because the structure of soil map databases differs between countries (definition of the soil mapping unit, stratification, soil associations, dominating and co-dominating soils, typical and estimate soil properties for different depths), it is difficult to define a generic methodology for the use of these maps for mapping soil property information.</p>
<p>However, the essential principle which is commonly used is to combine soil property data from local observations with soil maps via class- and geomatching.</p>
<p><strong>Diversity of national soil legacy data sets</strong>
in order to develop a representative and large national soil database, very often, data from different sources (e.g. soil surveys or projects in different parts of the country at different times) are combined. The following case of Belgium demonstrates how available legacy databases could be combined. Three different sources are used to compile an overview of national SOC stocks:</p>
<p><strong>Data source 1</strong>: soil profile database with 13,000 points of genetic horizons; for each site, there is information about the soil series, map coordinates, and land use class; for each horizon, there is information about depth and thickness, textural fractions and class, volume percentage of rock fragments; analytically, there is the organic carbon content and inorganic carbon content.</p>
<p><strong>Data source 2</strong>: forest soil data base which includes ectorganic horizons. According to their national definition, the term “ectorganic” designates the surface horizons with an organic matter content of at least <span class="math inline">\(30\%\)</span>, thus, it includes both the litter layer and the organic soil layers. For the calculation of SOC stocks for the ectorganic layer, no fixed-depth was used, instead, the measured thickness of the organic layers and litter layers was applied.</p>
<p><strong>Data source 3</strong>: 15,000 soil surface samples were used (upper 20 cm of mineral soil); carbon measurements are available per depth class.</p>
<p>From all data sources, SOC stocks for peat soils were calculated separately.</p>
</div>
<div id="technical-steps-class-matching" class="section level3">
<h3><span class="header-section-number">6.1.2</span> Technical Steps: Class-matching</h3>
<div id="data-preparation" class="section level4">
<h4><span class="header-section-number">6.1.2.1</span> Data Preparation</h4>
<ul>
<li>Separate the database for forests, peat, and other land uses
If only horizons are provided: derive or estimate average depth of horizons per soil type; add upper and lower depth.</li>
<li>Check completeness of parameters per depth using the solum depth to code empty cells</li>
<li>Correction of organic carbon in case total carbon was determined (total carbon minus inorganic carbon concentration)</li>
<li>Correction of Walkley and Black method for incomplete oxidation (1.32)</li>
<li>If BD measured is lacking, select proper pedotransfer functions (PTF) and estimate BD. There are many PTF. At best, publications about the choice of the best suited PTF for specific physio-geographic conditions are available.</li>
<li>If the stone content is missing, investigate using other data sources or literature, to which a correction for stones should be applied</li>
<li>if possible, derive the standard average stone content for different soils/horizons/depths, or used published soil profiles, as a simple correction factor.</li>
<li>Calculate SOC stocks for all mineral and peat soils over 0-30 cm, and optionally for forest organic layers and, peat &gt;30 &lt;100 cm.</li>
</ul>
</div>
<div id="preparatory-gis-operations" class="section level4">
<h4><span class="header-section-number">6.1.2.2</span> Preparatory GIS Operations</h4>
<ul>
<li>Prepare Covariates</li>
<li>Identify properties of covariates for each point observation using geo-matching</li>
<li>Mapping using geo-matching of all points: Extract the covariate information to all georeferenced sample sites. The SOC values from all points within the unit are then averaged. It is assumed that the points represent the real variability of soil types within the units</li>
</ul>
</div>
<div id="mapping" class="section level4">
<h4><span class="header-section-number">6.1.2.3</span> Mapping</h4>
<ul>
<li>Mapping using class-matching of points in agreement with classes</li>
</ul>
<p>Through <em>class-matching</em>, only those points or profiles are attributed to a soil or landscape unit if both the soil and the land use class are the same. Class-matching thus can be performed regardless of the profile location. Before averaging, a weighing factor can be introduced according to the area proportions of dominant, co-dominant and associated soils. Each profile needs to be matched to its soil type/landscape type, and the SOC value averaged.
1. Determine a soil or landscape unit (e.g. national soil legend stratified by climate area and mainland cover type (forest, grassland, cropland)
2. Calculate average SOC stocks from all soils which match the soil/landscape unit
3. Present the Soil/landscape map with SOC stocks, do not classify SOC stocks into groups (e.g. &lt; 50, 50-100, &gt; 100).</p>
<p>Note: Pre-classified SOC maps cannot be integrated into a global GSOCmap legend.</p>
<ul>
<li>Mapping using geo-matching</li>
</ul>
<p>Because of its importance, geo-matching is described in more detail.</p>
</div>
</div>
<div id="technical-steps-geo-matching" class="section level3">
<h3><span class="header-section-number">6.1.3</span> Technical Steps: Geo-Matching</h3>
<p>It is important to first prepare the working environment pre-processed all input data. The following section presents different Geo-matching procedures;</p>
<ol style="list-style-type: decimal">
<li>Setting up software and working environment</li>
<li>Geo-matching SOC with WRB Soil map (step-by-step, using the Soil Map of FYROM and the demonstration data presented above)</li>
<li>Geo-matching SOC with other environmental variables: Land use</li>
<li>Finally, the development of Landscape Units (Lettens et al. 2004) is outlined.</li>
</ol>
<p>This example was developed for QGIS and focusses on SOC mapping using vector data. QGIS 2.18 with GRASS 7.05 will be used. For more information, see also:</p>
<ul>
<li><a href="https://gis.stackexchange.com" class="uri">https://gis.stackexchange.com</a></li>
<li><a href="http://www.qgis.org/" class="uri">http://www.qgis.org/</a></li>
<li><a href="http://www.qgisforum.org/" class="uri">http://www.qgisforum.org/</a></li>
</ul>
<div id="setting-up-a-qgis-project" class="section level4">
<h4><span class="header-section-number">6.1.3.1</span> Setting Up a QGIS Project</h4>
<ol style="list-style-type: decimal">
<li>Install QGIS and supporting software; download the software at <a href="http://www.qgis.org/en/site/forusers/download.html" class="uri">http://www.qgis.org/en/site/forusers/download.html</a> (select correct version for Windows, Mac or Linux, 32 or 64 bit).</li>
<li>Create a work folder, e.g. D:\GSOC\practical_matching. Copy the folder with the FYROM demonstration data into this folder.</li>
<li>Start ‘QGIS desktop with GRASS’. Fig. <a href="mappingMethods.html#fig:qgis">6.1</a> shows the start screen of QGIS desktop. In the upper left panel, there is the browser panel, which lists the geodata used for this example. In the bottom left, the layer information is given for the layers displayed on the right.</li>
</ol>
<div class="figure" style="text-align: center"><span id="fig:qgis"></span>
<img src="images/Conv_upscaling1.png" alt="QGIS Desktop with the browser panel on the upper left, the layer information on the bottom left and the display of your layers on the right" width="80%" />
<p class="caption">
Figure 6.1: QGIS Desktop with the browser panel on the upper left, the layer information on the bottom left and the display of your layers on the right
</p>
</div>
<ol start="4" style="list-style-type: decimal">
<li>Load the FYROM soil map. Right-click the file in the Browser panel and add the map to your project.</li>
<li>Display the soil classes. Right-click on the file in the Layers Panel, properties. Go to Style and change from ‘Single symbol’ to ‘Categorized’ (Fig. <a href="mappingMethods.html#fig:layerprop">6.2</a>). Select the column ‘WRB’ and press the icon ‘Classify’ and change the colors if you want. Next, apply the change and finish by clicking the OK-button.</li>
</ol>
<div class="figure" style="text-align: center"><span id="fig:layerprop"></span>
<img src="images/Conv_upscaling2.png" alt="Changing layer properties for the FYROM Soil Map" width="80%" />
<p class="caption">
Figure 6.2: Changing layer properties for the FYROM Soil Map
</p>
</div>
<ol start="6" style="list-style-type: decimal">
<li>Ensure the correct projection for this project. Go to: Project -&gt; Project properties -&gt; CRS
In this case, you automatically use the local projection for FYROM. The EPSG code is 3909 which corresponds to MGI 1901/ Balkans zone 7 (Fig. <a href="mappingMethods.html#fig:qgisepsg">6.3</a>).</li>
</ol>
<div class="figure" style="text-align: center"><span id="fig:qgisepsg"></span>
<img src="images/Conv_upscaling3.png" alt="Project properties and projection settings" width="80%" />
<p class="caption">
Figure 6.3: Project properties and projection settings
</p>
</div>
<ol start="7" style="list-style-type: decimal">
<li>Save the project in the created folder
Load and display the pre-processed SOC point data. If a shapefile already exists, this is done the same way as described in Step 4. If you have the data as a text file, you need to create a vector layer out of that file. Go to Layer -&gt; Add Layer -&gt; Add Delimited Text layer. Select the correct file and proper CRS projection. The layer should be added to your Layers Panel and displayed on top of the Soil Map.</li>
</ol>
</div>
<div id="geo-matching-soc-with-wrb-soil-map" class="section level4">
<h4><span class="header-section-number">6.1.3.2</span> Geo-Matching SOC with WRB Soil Map</h4>
<p>In this section you will make a SOC map, based on the FYROM Soil Map and the SOC values at the sampled points, following 3 steps: 1) Extract the soil map information for the point data, 2) obtain the mean and standard deviation of the SOC stocks per soil class, based on the point data and 3) assign these values to the corresponding soil map units. The steps are detailed below:</p>
<ol style="list-style-type: decimal">
<li>Extract the soil map information to the soil profile data by ‘Join Attributes by location’. Vector -&gt; Data Management Tools -&gt; Join Attributes by location. Here, the target vector layers are the soil point data, and the join vector layer is the FYROM Soil Map. The geometric predicate is ‘intersects’. Specify at the ‘joined table’ to keep only matching records and save the ‘joined layer’ as a new file (Fig. 8.4).</li>
</ol>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-26"></span>
<img src="images/Conv_upscaling4.png" alt="Join attributes by location" width="80%" />
<p class="caption">
Figure 6.4: Join attributes by location
</p>
</div>
<ol start="2" style="list-style-type: decimal">
<li>Check the newly generated file, open the attribute table. The new file is added to the ‘Layers Panel’ . Right-click on the file and open the attribute table. The information from the FYROM Soil Map is now added to the soil point data.</li>
<li>Most likely, the SOC values in the table are not numeric and thus statistics cannot be calculated. Check the data format, right-click on the file in the ‘Layers Panel’ and check the Type name of the SOC field under the tab ‘Fields’. If they are not integer then change the format.</li>
<li>Change of the data format: Open the attribute table and start editing (the pencil symbol in the upper left corner of your table). Open the field calculator and follow these instructions (Fig. 8.5):</li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>Checkbox: Create a new field</li>
<li>Output field name: Specify the name of your field</li>
<li>Output field type: Decimal Number (real)</li>
<li>Output field length: 10, precision: 3
<ol style="list-style-type: lower-roman">
<li>Expression: to_real(‘SOC’), the to_real function can be found under ‘conversions’ and the ‘SOC’ field is found under ‘Fields and Values’</li>
</ol></li>
</ol>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-27"></span>
<img src="images/Conv_upscaling5.png" alt="Example field calculator" width="80%" />
<p class="caption">
Figure 6.5: Example field calculator
</p>
</div>
<ol start="5" style="list-style-type: decimal">
<li>After calculating the field, save edits and leave the editing mode prior to closing the table. If changes are not saved, the added field will be lost.</li>
<li>Calculate the median SOC stock per soil type. Go to the tab ‘Vector’-&gt; group stats. Select the layer from the spatial join you made in Step 2. Add the field ‘SOC’ and median to the box with ‘Values’ and the field ‘WRB’ to the ‘Rows’. Make sure the box with ‘use only selected features’ is not checked. Now calculate the statistics. A table will be given in the left pane (Figure 8.6). Save this file as .csv and repeat the same for the standard deviation.</li>
</ol>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-28"></span>
<img src="images/Conv_upscaling6.png" alt="Calculate group statistics" width="80%" />
<p class="caption">
Figure 6.6: Calculate group statistics
</p>
</div>
<ol start="7" style="list-style-type: decimal">
<li>Join the mean and standard deviation of SOC to the Soil Map. First, add the files generated during step 6 to the Layers Panels. In the Layers Panel, right-click on the FYROM Soil Map. Go to Properties -&gt; Joins and add a new join for both the median and standard deviation of SOC. The Join and Target Field are both ‘WRB’.</li>
<li>Display the SOC maps. Go to the layer properties of the FYROM Soil Map. Go to Style and change the legend to a graduated legend. In the column, you indicate the assigned SOC values. Probably this is not a integer number and so you have to convert this number again to a numeric values. You can do this with the box next to the box (Fig. 8.7). Change the number of classes to e.g. 10 classes, change the mode of the legend and change the color scheme if you want and apply the settings. Now you have a map with the median SOC stocks per WRB soil class.</li>
</ol>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-29"></span>
<img src="images/Conv_upscaling7.png" alt="Change the legend style to display the SOC values" width="80%" />
<p class="caption">
Figure 6.7: Change the legend style to display the SOC values
</p>
</div>
<ol start="9" style="list-style-type: decimal">
<li>In order to generate a proper layout, go to Project -&gt; New Print Composer</li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>Add map using Layout -&gt; Add Map. Define a square on the canvas and the selected map will be displayed.</li>
<li>Similarly, title, scale bar, legend and a north arrow can be added. Specific properties can be changed in the box ‘Item properties’.</li>
<li>When the map is finished, it can be exported as an image or pdf.</li>
</ol>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-30"></span>
<img src="images/Conv_upscaling8.png" alt="Example of the Map composer" width="80%" />
<p class="caption">
Figure 6.8: Example of the Map composer
</p>
</div>
<ol start="10" style="list-style-type: decimal">
<li>Repeat step 2-8 but now for the standard deviation of the SOC stocks.</li>
<li>Save the file as a new shapefile: Go to ‘Layer Panels -&gt; Save as -&gt; ESRI ShapeFile and make sure that you define the symbology export: Feature Symbology. Now, a shapefile is generated, with both the median and standard deviation SOC stock per soil type. Redundant fields can be removed after the new file is created.</li>
</ol>
</div>
<div id="geo-matching-soc-with-other-environmental-variables-land-use" class="section level4">
<h4><span class="header-section-number">6.1.3.3</span> Geo-Matching SOC with Other Environmental Variables: Land Use</h4>
<ol style="list-style-type: decimal">
<li>Start a new project and add the soil point data and FYROM Soil Map layers from the Browser panel</li>
<li>Add the Land Use raster file to the Layers Panels. This is a raster file with 1-kilometer resolution and projected in lat-long degrees (WGS84). For more information about this product see the online information from worldgrids: <a href="http://worldgrids.org/doku.php/wiki:glcesa3" class="uri">http://worldgrids.org/doku.php/wiki:glcesa3</a></li>
<li>Change the projection to the MGI 1901/ Balkans region7. Go to Raster -&gt; Projections -&gt; Warp and select the proper projection and a suitable file name, e.g. LU_projected_1km. Tick the checkbox for the resampling method and choose Near. This is the nearest neighbor and most suitable for a transformation of categorical data, such as land use (Fig. 8.9).</li>
</ol>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-31"></span>
<img src="images/Conv_upscaling9.png" alt="Change the projection of a raster file" width="80%" />
<p class="caption">
Figure 6.9: Change the projection of a raster file
</p>
</div>
<ol start="4" style="list-style-type: decimal">
<li>In order to geomatch the soil point data with Land Use, the raster file needs to be converted into a vector file. Go to Raster -&gt; Conversions -&gt; Polygonize. Set a proper output filename, e.g. LU_polygon_1km, and check the tickbox for Fieldname.</li>
<li>Change the legend style into categories (Step 1-5):
Now, the steps from the previous section need to be repeated, using the land use polygon map instead of using the FYROM Soil Map.</li>
<li>Join attributes by location using the soil point data and the polygon land use map.</li>
<li>Calculate the median and standard deviation of SOC by using the Group Statistics for SOC and the Land Use classes and save the files as .csv.</li>
<li>Add the generated .csv files to the Layers Panel.</li>
<li>Join the files with the LU polygon map, generated at step 3-4.</li>
<li>Change the classes in the legend and inspect the histogram with the median SOC values. Try to find a proper definition of the class boundaries (Step 2-8).</li>
</ol>
</div>
<div id="joining-landscape-units-and-soil-mapping-units-to-support-class--and-geo-matching-optional" class="section level4">
<h4><span class="header-section-number">6.1.3.4</span> Joining Landscape Units and Soil Mapping Units to Support Class- and Geo-Matching (Optional)</h4>
<p>In this section, it is outlined how SOC stocks can be mapped following the method outlined by . The general idea is that the landscape is stratified into more or less homogenous units and subsequently, the SOC stocks are obtained following the procedure outlined earlier in this practical.  outlines a method to stratify the landscape into homogeneous strata with respect to Land Use and Soil Type, as was explained earlier. In order to obtain such strata, the Soil Map and the Land Use map need to be combined. This can be done using various types of software, e.g. ArcMap, GRASS, QGIS or R.
When using the GIS software, the only thing that needs to be done is intersecting the vector files and dissolving the newly created polygon features. Depending on the software and the quality of your shapefile you may experience problems with the geometry of your shapefile. Generally, ArcMap and GRASS correct the geometry when the shapefile is loaded, while QGIS does not do this automatically. There are various ways to correct the geometry, however, correcting the geometry falls outside the scope of this training. Therefore, we give some hints on how to correct your geometry prior to using the functions ‘Intersect’ and ‘Dissolve’.</p>
<ol style="list-style-type: decimal">
<li>Change the LU raster map to 5-kilometer resolution: Right-click the Lu_project_1km file and select Save as. Change the resolution to 5000 meters. Scroll down, check the Pyramids box, and change the resampling method to Nearest Neighbour.</li>
<li>Convert the raster map to a polygon map and add the file to the Layers Panel</li>
<li>Check the validity of the Soil Map and Land Use Map: Vector -&gt; Geometry Tools -&gt; Check Validity
Below you find the instructions in case you have no problems with your geometry:</li>
<li>Intersect the Soil Map and the Land Use Map. In ArcGIS and QGIS you can use this function. Go to Vector -&gt; Geoprocessing tools -&gt; Intersection. (In GRASS you have to use the function ‘Overlay’ from the Vector menu)</li>
<li>Dissolve the newly generated polygons. Vector -&gt; Geoprocessing tools -&gt; Dissolve</li>
<li>Next, this layer can be used to continue with the class matching or geomatching procedures.</li>
</ol>
<p><strong>When encountering problems with the geometry there are at least three ways to correct your geometry:</strong></p>
<ul>
<li>Run the v_clean tool from GRASS within QGIS. Open the Processing ToolBox -&gt; GRASS GIS 5 commands -&gt; Vector -&gt; v.clean</li>
<li>Install the plugin ‘Processing LWGEOM Provider’. Go to the Plugins menu and search for the plugin and install. You can find the newly installed tool in the Processing Toolbox by typing the name in the search function</li>
<li>Manually correct the error nodes of the vector features</li>
</ul>


</div>
</div>
</div>
<div id="RK" class="section level2">
<h2><span class="header-section-number">6.2</span> Regression-Kriging</h2>
<p><em>GF Olmedo &amp; Y Yigini</em></p>
<div id="overview-1" class="section level3">
<h3><span class="header-section-number">6.2.1</span> Overview</h3>
<p>Regression-kriging is a spatial interpolation technique that combines a regression of the dependent variable (target variable) on predictors (i.e. the environmental covariates) with kriging of the prediction residuals. In other words, Regression-Kriging is a hybrid method that combines either a simple or a multiple-linear regression model with ordinary kriging of the prediction residuals. The Multiple regression analysis models the relationship of multiple predictor variables and one dependent variable, i.e. it models the deterministic trend between the target variable and environmental covariates. The modeled relationship between predictors and target are summarized in the regression equation, which can then be applied to a different data set in which the target values are unknown but the predictor variables are known. The regression equation predicts the value of the dependent variable using a linear function of the independent variables.
In this section, we review the regression kriging method. First, the deterministic part of the trend is modeled using a regression model. Next, the prediction residuals are kriged. In the regression phase of a regression-kriging technique, there is a continuous random variable called the dependent variable (target) Y (in our case SOC) and a number of independent variables which are selected covariates, x1, x2,…,xp. Our purpose is to predict the value of the dependent variable using a linear function of the independent variables. The values of the independent variables (environmental covariates) are known quantities for purposes of prediction, the model is:</p>
</div>
<div id="assumptions" class="section level3">
<h3><span class="header-section-number">6.2.2</span> Assumptions</h3>
<p>Standard linear regression models with standard estimation techniques make a number of assumptions about the predictor variables, the response variables, and their relationship. One must review the assumptions made when using the model.</p>
<p><em>Linearity</em>: The mean value of Y for each specific combination of the X’s is a linear function of the X’s. In practice this assumption can virtually never be confirmed; fortunately, multiple regression procedures are not greatly affected by minor deviations from this assumption. If curvature in the relationships is evident, one may consider either transforming the variables or explicitly allowing for nonlinear components.
<em>Normality Assumption</em>: It is assumed in multiple regression that the residuals (predicted minus observed values) are distributed normally (i.e., follow the normal distribution). Again, even though most tests (specifically the F-test) are quite robust with regard to violations of this assumption, it is always a good idea, before drawing final conclusions, to review the distributions of the major variables of interest. You can produce histograms of the residuals as well as normal probability plots, in order to inspect the distribution of the residual values.
<em>Collinearity</em>: There is not perfect collinearity in any combination of the X’s. A higher degree of collinearity, or overlap, among independent variables, can cause problems in multiple linear regression models. Collinearity (also multicollinearity) is a phenomenon in which two or more predictors in a multiple regression models are highly correlated. Collinearity causes increase in variances and relatedly increases inaccuracy.
<em>Distribution of the Errors</em>: The error term is normally distributed with a mean of zero and constant variance.
<em>Homoscedasticity</em>: The variance of the error term is constant for all combinations of X’s. The term homoscedasticity means “same scatter.” Its antonym is heteroscedasticity (“different scatter”).</p>
</div>
<div id="pre-processing-of-covariates" class="section level3">
<h3><span class="header-section-number">6.2.3</span> Pre-Processing of Covariates</h3>
<p>Before using the selected predictors, multicollinearity assumption must be reviewed. As an assumption, there is not perfect collinearity in any combination of the X’s. A higher degree of collinearity, or overlap, among independent variables, can cause problems in multiple linear regression models. The multicollinearity of a number of variables can be assessed using Variance Inflation Factor (VIF). In R, the function vif() from caret package can estimate the VIF. There are several rules of thumb to establish when there is a serious multi-collinearity (e.g. when the VIF square root is over 2). The Principal component analysis can be used to overcome multicollinearity issues.
Principal components analysis can cope with data containing large numbers of covariates that are highly collinear which is the common case in environmental predictors. Often the principal components with higher variances are selected as regressors. However, for the purpose of predicting the outcome, the principal components with low variances may also be important, in some cases even more important.
The PCA + Linear Regression (PCR) method may be coarsely divided into three main steps:
1. Run PCA on the data matrix for the predictors to obtain the principal components, and then select a subset of the principal components for further use.
2. Regress the dependent variable on the selected principal components as covariates, linear regression to get estimated regression coefficients.
3. Transforming the data back to the scale of the actual covariates, using the selected PCA loadings.</p>
</div>
<div id="the-terminology" class="section level3">
<h3><span class="header-section-number">6.2.4</span> The Terminology</h3>
<ul>
<li><strong>Dependent variable (Y)</strong>: What we are trying to predict (e.g. soil organic carbon content).</li>
<li><strong>Independent variables (Predictors) (X)</strong>: Variables that we believe influence or explain the dependent variable (Covariates: environmental covariates - DEM derived covariates, soil maps, land cover maps, climate maps). The data sources for the environmental predictors are provided in chapter <a href="covariates.html#covariates">5</a>.</li>
<li><strong>Coefficients (β)</strong>: values, computed by the multiple regression tool, reflect the relationship and strength of each independent variable to the dependent variable.</li>
<li><strong>Residuals (ε)</strong>: the portion of the dependent variable that cannot be explained by the model; the model under/over predictions.</li>
</ul>
<div class="figure">
<img src="images/RKequation.png" alt="Linear regression model" />
<p class="caption">Linear regression model</p>
</div>
<p>Before we proceed with the regression analysis, it is advisable to inspect the histogram of the dependent/target variable, in order to see if it needs to be transformed before fitting the regression model. The data for the selected soil property is normal when the frequency distribution of the values follow a bell-shaped curve (Gaussian distribution) which is symmetric around its mean. Normality tests may be used to assess normality. If a normality test indicates that data are not normally distributed, it may be necessary to transform the data to meet the normality assumption.</p>
<blockquote>
<p>Both, the normality tests and the data transformation can be easily performed using any commercial or open source statistical tool (R, SPSS, MINITAB…)</p>
</blockquote>
<p>The main steps for the multiple linear regression analysis are shown in the Figure <a href="mappingMethods.html#fig:workflowRK">6.10</a>.</p>
<div class="figure" style="text-align: center"><span id="fig:workflowRK"></span>
<img src="images/RKworkflow.png" alt="Workflow for Regression Kriging" width="80%" />
<p class="caption">
Figure 6.10: Workflow for Regression Kriging
</p>
</div>
<blockquote>
<ol style="list-style-type: decimal">
<li>The first step is to prepare a map showing the spatial distribution of the sample locations and the corresponding soil property information, e.g. soil organic matter and environmental properties. The first can be achieved as outlined in section <a href="covariates.html#overlay-covariates-and-spatial-data">Overlay covariates and spatial data</a>. The overlaying operation can be performed in R, ArcGIS, SAGA GIS or QGIS.</li>
<li>The essential part of multiple regression analysis is to build a regression model by using the environmental predictors. After extracting the values of explanatory maps and target variables into the single table, we can now start fitting multiple regression model using the table that contains data from dependent variable and predictors.</li>
<li>In particular cases, stepwise multiple linear regression (SMLR) can be used to eliminate insignificant predictors. Stepwise multiple linear regression (SMLR) usually selects predictors that have the strongest linear correlations with the target variable, which reflect the highest predictive capacity.</li>
<li>Kriging of the residuals (prediction errors): In the regression-kriging, the regression model detrends the data, produces the residuals which we need to krige and to be added to the regression model predictions.</li>
</ol>
</blockquote>
</div>
<div id="interpret-the-key-results-of-multiple-regression" class="section level3">
<h3><span class="header-section-number">6.2.5</span> Interpret the Key Results of Multiple Regression</h3>
<p>Regression analysis generates an equation to describe the statistical relationship between one or more predictor variables and the response variable. he r-squared, p-values and coefficients that appear in the output for linear regression analysis must also be reviewed. Before accepting the result of a linear regression it is important to evaluate its suitability at explaining the data. One of the many ways to do this is to visually examine the residuals. If the model is appropriate, then the residual errors should be random and normally distributed.</p>
<p><strong>R-sq</strong></p>
<p>R2 is the percentage of variation in the response that is explained by the model. The higher the R2 Value, the better the model fits your data. R-squared is always between <span class="math inline">\(0\%\)</span> and <span class="math inline">\(100\%\)</span>. R2 usually increases when additional predictors are added in the model.</p>
<p><strong>P Values</strong></p>
<p>To determine whether the association between the dependent and each predictor in the model is statistically significant, compare the p-value for the term to your significance level to assess the null hypothesis. Usually, a significance level of 0.05 works well.
P-value ≤ significance level: The relationship is statistically significant. If the p-value is less than or equal to the significance level, we can conclude that there is a statistically significant relationship between the dependent variable and the predictor.
P-value &gt; significance level: The relationship is not statistically significant, If the p-value is greater than the significance level, you cannot conclude that there is a statistically significant relationship between the dependent variable and the predictor. You may want to refit the model without the predictor.</p>
<p><strong>Residuals</strong></p>
<p>We can plot the residuals which can help us determine whether the model is adequate and meets the assumptions of the analysis. If the model is appropriate, then the residual errors should be random and normally distributed. We can plot residuals versus fits to verify the assumption that the residuals are randomly distributed and have constant variance. Ideally, the points should fall randomly on both sides of “0”, with no recognizable patterns in the points.</p>
<p>The diagnostic plots for the model should be evaluated to confirm if all the assumptions of linear regression are met. After the abovementioned assumptions are validated, we can proceed with making the prediction map using the model with significant predictors.</p>
</div>
<div id="using-the-results-of-a-regression-analysis-to-make-predictions" class="section level3">
<h3><span class="header-section-number">6.2.6</span> Using the Results of a Regression Analysis to Make Predictions</h3>
<p>The purpose of a regression analysis, of course, is to develop a model that can be used to make the prediction of a dependent variable. The derived regression equation is to be used to create the prediction map for the dependent variable.</p>
<blockquote>
<p>Raster calculation can be easily performed using “raster” Package in R or ArcGIS using the ”Raster Calculator” tool (It’s called Map Algebra in the prior versions).</p>
</blockquote>
</div>
<div id="technical-steps---regression-kriging" class="section level3">
<h3><span class="header-section-number">6.2.7</span> Technical Steps - Regression Kriging</h3>
<p><strong>Requirements</strong>
The following are required to implement Regression Kriging in R</p>
<ul>
<li><p><a href="Latest%20version%20of%20R%20software,%20network%20connection%20and%20sufficient%20RAM,%20storage%20capacity">Setting-up the Software Environment</a></p></li>
<li><p><a href="Latest%20version%20of%20RStudio">Obtaining and Installing R Studio</a></p></li>
<li><p><a href="R%20packages">R Packages</a></p></li>
<li><p><a href="Point%20Dataset">Preparation of local soil property data</a></p></li>
<li><p><a href="Environmental%20predictors">Preparation of spatial covariates</a></p></li>
<li><p><a href="Relief%20(e.g.%20DEM,%20Slope,%20TWI)">DEM-derived covariates</a></p></li>
<li><p><a href="Organism%20map%20(e.g.%20land%20use,%20NDVI,%20land%20cover)">Land cover/Land use</a></p></li>
<li><p><a href="Climate%20Data%20(e.g.%20mean%20precipitation,%20mean%20temperature)">Climate</a></p></li>
<li><p><a href="Parent%20material%20(parent%20material,%20geology)">Parent material</a></p></li>
</ul>
<div id="setting-working-space-and-initial-steps" class="section level4">
<h4><span class="header-section-number">6.2.7.1</span> Setting Working Space and Initial Steps</h4>
<p>One of the first steps should be setting our working directory. If you read/write files from/ to disk, this takes place in the working directory. If we don’t set the working directory we could easily write files to an undesirable file location. The following example shows how to set the working directory in R to our folder which contains data for the study area (point data, covariates).</p>
<p>Note that we must use the forward slash / or double backslash \\ in R! Single backslash \ will not work. Now we can check if the working directory has been correctly set by using the function:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="kw">getwd</span>()</a></code></pre></div>
</div>
<div id="data-preparation-1" class="section level4">
<h4><span class="header-section-number">6.2.7.2</span> Data Preparation</h4>
<p><strong>Point Dataset</strong></p>
<p>We previously applied spline function to produce continuous soil information to a given soil depth (0-30 cm) in section <a href="preparation.html#EqualAreaSplines">3.4.1</a>. Spline function basically imports soil profile data (including instances where layers are not contiguous), fits it to a mass-preserving spline and outputs attribute means for a given depth. The output file should contain profile id, upper (surface) and lower depth (30cm), the estimated value for the selected soil attribute (Value) and tmse (estimated mean squared error of the spline). If you used the Spline Tool V2, the coordinates were not kept in the output file. The coordinates should be added back in the data table. You can use Profile IDs to add the X, Y columns back. Once your point dataset is ready, copy this table into your working directory as a .csv file.</p>
<p><strong>Environmental Predictors (Covariates)</strong></p>
<p>In the Chapter <a href="covariates.html#covariates">5</a>, we presented and prepared several global and continental datasets. In addition to these datasets, numerous covariate layers have been prepared by ISRIC for the GSOC Map project. These are GIS raster layers of various biophysical earth surface properties for each country in the world. Some of these layers will be used as predictors in this section. Please download the covariates for your own study area from GSOCMap Data Repository as explained in section <a href="covariates.html#GSOCDataRepo">5.6</a>.</p>
<p>In section <a href="covariates.html#overlay-soil-covariates">5.9</a>, a table with the points values after data preparation and the values of our spatial predictors was prepared. This step involves loading this table.</p>
<p>Now we will import our point dataset using <code>read.csv()</code> function. The easiest way to create a data frame is to read in data from a file—this is done using the function read.csv, which works with comma delimited files. Data can be read in from other file formats as well, using different functions, but read.csv is the most commonly used approach. R is very flexible in how it reads in data from text files (<code>read.table</code>, <code>read.csv</code>, <code>read.csv2</code>, <code>read.delim</code>, <code>read.delim2</code>). Please type <code>?read.table()</code> for help.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="co"># load data</span></a>
<a class="sourceLine" id="cb53-2" data-line-number="2">dat &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/MKD_RegMatrix.csv&quot;</span>)</a>
<a class="sourceLine" id="cb53-3" data-line-number="3"></a>
<a class="sourceLine" id="cb53-4" data-line-number="4">dat<span class="op">$</span>LCEE10 &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat<span class="op">$</span>LCEE10)</a>
<a class="sourceLine" id="cb53-5" data-line-number="5">dat<span class="op">$</span>soilmap &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat<span class="op">$</span>soilmap)</a>
<a class="sourceLine" id="cb53-6" data-line-number="6"></a>
<a class="sourceLine" id="cb53-7" data-line-number="7"><span class="co"># explore the data structure</span></a>
<a class="sourceLine" id="cb53-8" data-line-number="8"><span class="kw">str</span>(dat)</a></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    2897 obs. of  23 variables:
##  $ id       : Factor w/ 2897 levels &quot;P0003&quot;,&quot;P0007&quot;,..: 1 2 3 4..
##  $ Y        : num  42 42 42.1 42 42 ...
##  $ X        : num  20.8 20.8 20.8 20.9 20.9 ...
##  $ SOC      : num  26.38 6.15 3.94 3.26 2.29 ...
##  $ BLD      : num  0.73 1.17 1.3 1.34 1.41 ...
##  $ CRFVOL   : num  8 18.6 31.9 21.7 14.5 ...
##  $ OCSKGM   : num  5.32 1.75 1.04 1.03 0.83 ...
##  $ meaERROR : num  2.16 2.85 2.65 3.16 3.63 2.83 2.94 2.49 2.77..
##  $ OCSKGMlog: num  1.6712 0.5591 0.0429 0.0286 -0.1862 ...
##  $ B04CHE3  : num  574 553 693 743 744 ...
##  $ B07CHE3  : num  38.5 37.8 42.1 43.7 43.7 ...
##  $ B13CHE3  : num  111.6 125 99.8 118.1 121 ...
##  $ B14CHE3  : num  59.2 60.3 42.4 39.9 38.7 ...
##  $ DEMENV5  : int  2327 2207 1243 1120 1098 1492 1413 1809 1731..
##  $ LCEE10   : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 3 2 1 2 2 2..
##  $ PRSCHE3  : num  998 1053 780 839 844 ...
##  $ SLPMRG5  : int  13 36 6 25 30 24 15 17 20 43 ...
##  $ TMDMOD3  : int  282 280 285 288 289 287 286 286 287 286 ...
##  $ TMNMOD3  : int  272 270 277 279 279 277 277 273 274 273 ...
##  $ TWIMRG5  : int  61 62 81 66 65 72 68 67 65 59 ...
##  $ VBFMRG5  : int  0 0 14 0 0 0 0 0 0 0 ...
##  $ VDPMRG5  : int  311 823 10048 1963 -173 -400 -9 -692 -1139 2..
##  $ soilmap  : Factor w/ 20 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 6 14 14 3..</code></pre>
<p>Since we will be working with spatial data we need to define the coordinates for the imported data. Using the coordinates() function from the sp package we can define the columns in the data frame to refer to spatial coordinates—here the coordinates are listed in columns X and Y.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="kw">library</span>(sp)</a>
<a class="sourceLine" id="cb55-2" data-line-number="2"></a>
<a class="sourceLine" id="cb55-3" data-line-number="3"><span class="co"># Promote to spatialPointsDataFrame</span></a>
<a class="sourceLine" id="cb55-4" data-line-number="4"><span class="kw">coordinates</span>(dat) &lt;-<span class="st"> </span><span class="er">~</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>Y</a>
<a class="sourceLine" id="cb55-5" data-line-number="5"></a>
<a class="sourceLine" id="cb55-6" data-line-number="6"><span class="kw">class</span>(dat)</a></code></pre></div>
<pre><code>## [1] &quot;SpatialPointsDataFrame&quot;
## attr(,&quot;package&quot;)
## [1] &quot;sp&quot;</code></pre>
<p>SpatialPointsDataFrame structure is essentially the same data frame, except that additional “spatial” elements have been added or partitioned into slots. Some important ones being the bounding box (sort of like the spatial extent of the data), and the coordinate reference system proj4string(), which we need to define for the sample dataset. To define the CRS, we must know where our data are from, and what was the corresponding CRS used when recording the spatial information in the field. For this data set, the CRS used was: WGS84 (EPSG:4326).</p>
<p>To clearly tell R this information we define the CRS which describes a reference system in a way understood by the <a href="http://trac.osgeo.org/proj/">PROJ.4 projection library</a>. An interface to the PROJ.4 library is available in the rgdal package. As an alternative to using Proj4 character strings, we can use the corresponding yet simpler EPSG code (European Petroleum Survey Group). rgdal also recognizes these codes. If you are unsure of the Proj4 or EPSG code for the spatial data that you have but know the CRS, you should consult <a href="http://spatialreference.org/" class="uri">http://spatialreference.org/</a> for assistance.</p>
<p>Please also note that, when working with spatial data, it’s very important that the CRS (coordinate reference system) of the point data and covariates are the same.</p>
<p>Now, we will define our CRS:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb57-1" data-line-number="1">dat<span class="op">@</span>proj4string &lt;-<span class="st"> </span><span class="kw">CRS</span>(<span class="dt">projargs =</span> <span class="st">&quot;+init=epsg:4326&quot;</span>)</a>
<a class="sourceLine" id="cb57-2" data-line-number="2"></a>
<a class="sourceLine" id="cb57-3" data-line-number="3">dat<span class="op">@</span>proj4string</a></code></pre></div>
<pre><code>## CRS arguments:
##  +init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs
## +ellps=WGS84 +towgs84=0,0,0</code></pre>
<p>Now we will import the covariates. When the covariate layers are in common resolution and extent, rather than working with individual rasters it is better to stack them all into a single R object. In this example, we use 13 covariates from the GSOCMap Data Repository and a rasterized version of the soil type map. The rasterization of vectorial data was covered in <a href="covariates.html#technical-steps---rasterizing-a-vector-layer-in-r">Technical Steps - Rasterizing a vector layer in R</a>. The file containing all the covariates was prepared at the end of chapter <a href="covariates.html#covariates">5</a>.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="kw">load</span>(<span class="dt">file =</span> <span class="st">&quot;covariates.RData&quot;</span>)</a>
<a class="sourceLine" id="cb59-2" data-line-number="2"></a>
<a class="sourceLine" id="cb59-3" data-line-number="3"><span class="kw">names</span>(covs)</a></code></pre></div>
<pre><code>##  [1] &quot;B04CHE3&quot; &quot;B07CHE3&quot; &quot;B13CHE3&quot; &quot;B14CHE3&quot; &quot;DEMENV5&quot; &quot;LCEE10&quot; 
##  [7] &quot;PRSCHE3&quot; &quot;SLPMRG5&quot; &quot;TMDMOD3&quot; &quot;TMNMOD3&quot; &quot;TWIMRG5&quot; &quot;VBFMRG5&quot;
## [13] &quot;VDPMRG5&quot; &quot;soilmap&quot;</code></pre>
</div>
<div id="fitting-the-mlr-model" class="section level4">
<h4><span class="header-section-number">6.2.7.3</span> Fitting the MLR Model</h4>
<p><strong>Fitting the MLR Model</strong></p>
<p>It would be better to progress with a data frame of just the data and covariates required for the modeling. In this case, we will subset the columns SOC, the covariates and the spatial coordinates (X and Y).</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb61-1" data-line-number="1">datdf &lt;-<span class="st"> </span>dat<span class="op">@</span>data</a>
<a class="sourceLine" id="cb61-2" data-line-number="2"></a>
<a class="sourceLine" id="cb61-3" data-line-number="3">datdf &lt;-<span class="st"> </span>datdf[, <span class="kw">c</span>(<span class="st">&quot;OCSKGM&quot;</span>, <span class="kw">names</span>(covs))]</a></code></pre></div>
<p>Let’s fit a linear model using with all available covariates.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="co"># Fit a multiple linear regression model between the log transformed</span></a>
<a class="sourceLine" id="cb62-2" data-line-number="2"><span class="co"># values of OCS and the top 20 covariates</span></a>
<a class="sourceLine" id="cb62-3" data-line-number="3">model.MLR &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(OCSKGM) <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> datdf)</a></code></pre></div>
<p>From the summary of our fitted model (model.MLR) above, it seems only a few of the covariates are significant in describing the spatial variation of the target variable. To determine the most predictive model we can run a stepwise regression using the <code>step()</code> function. With this function, we can also specify the mode of stepwise search, can be one of “both”, “backward”, or “forward”.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb63-1" data-line-number="1">## stepwise variable selection</a>
<a class="sourceLine" id="cb63-2" data-line-number="2">model.MLR.step &lt;-<span class="st"> </span><span class="kw">step</span>(model.MLR, <span class="dt">direction=</span><span class="st">&quot;both&quot;</span>)</a></code></pre></div>
<p>Comparing the summary of both the full and stepwise linear models, there is very little difference between the models such as the R2. Both models explain about <span class="math inline">\(23\%\)</span> of variation of the target variable. Obviously, the “full” model is more complex as it has more parameters than the “step” model.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb64-1" data-line-number="1"><span class="co"># summary and anova of the new model using stepwise covariates</span></a>
<a class="sourceLine" id="cb64-2" data-line-number="2"><span class="co"># selection</span></a>
<a class="sourceLine" id="cb64-3" data-line-number="3"><span class="kw">summary</span>(model.MLR.step)</a>
<a class="sourceLine" id="cb64-4" data-line-number="4"><span class="kw">anova</span>(model.MLR.step)</a></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = log(OCSKGM) ~ B04CHE3 + B07CHE3 + B13CHE3 + DEMENV5 + 
##     LCEE10 + PRSCHE3 + SLPMRG5 + TMDMOD3 + TMNMOD3 + VBFMRG5 + 
##     VDPMRG5 + soilmap, data = datdf)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -3.3625 -0.2637  0.0368  0.3111  1.8859 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  9.166e+00  4.343e+00   2.111  0.03489 *  
## B04CHE3     -5.877e-03  1.099e-03  -5.347 9.64e-08 ***
## B07CHE3      1.110e-01  3.460e-02   3.209  0.00135 ** 
## B13CHE3     -4.361e-03  1.640e-03  -2.659  0.00788 ** 
## DEMENV5     -1.882e-04  8.926e-05  -2.108  0.03508 *  
## LCEE102      9.745e-02  3.369e-02   2.893  0.00385 ** 
## LCEE103      1.399e-01  5.490e-02   2.548  0.01088 *  
## LCEE104     -3.612e-02  4.360e-02  -0.829  0.40741    
## PRSCHE3      9.174e-04  3.139e-04   2.923  0.00350 ** 
## SLPMRG5     -2.440e-03  1.508e-03  -1.619  0.10559    
## TMDMOD3     -5.584e-02  7.612e-03  -7.336 2.86e-13 ***
## TMNMOD3      2.467e-02  1.291e-02   1.911  0.05611 .  
## VBFMRG5      4.941e-04  9.867e-05   5.008 5.84e-07 ***
## VDPMRG5     -2.696e-05  4.360e-06  -6.185 7.11e-10 ***
## soilmap2    -3.848e-01  4.885e-01  -0.788  0.43090    
## soilmap3    -2.094e-01  4.825e-01  -0.434  0.66429    
## soilmap4    -1.955e-01  4.886e-01  -0.400  0.68919    
## soilmap5    -6.323e-02  5.202e-01  -0.122  0.90327    
## soilmap6     2.087e-01  4.841e-01   0.431  0.66649    
## soilmap7     1.459e-01  4.857e-01   0.300  0.76398    
## soilmap8    -1.875e-01  4.848e-01  -0.387  0.69904    
## soilmap9    -3.278e-01  4.817e-01  -0.681  0.49617    
## soilmap10   -1.001e-01  4.833e-01  -0.207  0.83590    
## soilmap11   -3.587e-01  4.874e-01  -0.736  0.46188    
## soilmap12   -2.135e-01  4.822e-01  -0.443  0.65797    
## soilmap13    3.091e-01  5.563e-01   0.556  0.57855    
## soilmap14   -2.224e-01  4.828e-01  -0.461  0.64506    
## soilmap15   -1.905e-01  4.876e-01  -0.391  0.69600    
## soilmap16   -3.482e-01  4.831e-01  -0.721  0.47112    
## soilmap17   -1.478e-01  4.838e-01  -0.306  0.75996    
## soilmap18   -8.714e-02  4.830e-01  -0.180  0.85684    
## soilmap19   -5.491e-01  5.082e-01  -1.080  0.28002    
## soilmap20   -3.123e-01  4.846e-01  -0.644  0.51934    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.4806 on 2864 degrees of freedom
## Multiple R-squared:  0.2472, Adjusted R-squared:  0.2388 
## F-statistic: 29.38 on 32 and 2864 DF,  p-value: &lt; 2.2e-16
## 
## Analysis of Variance Table
## 
## Response: log(OCSKGM)
##             Df Sum Sq Mean Sq  F value    Pr(&gt;F)    
## B04CHE3      1 111.35 111.347 482.0082 &lt; 2.2e-16 ***
## B07CHE3      1   2.33   2.335  10.1060  0.001494 ** 
## B13CHE3      1   1.64   1.642   7.1059  0.007726 ** 
## DEMENV5      1   5.07   5.067  21.9339 2.953e-06 ***
## LCEE10       3  17.22   5.740  24.8497 7.201e-16 ***
## PRSCHE3      1   4.91   4.910  21.2530 4.201e-06 ***
## SLPMRG5      1   1.97   1.971   8.5305  0.003520 ** 
## TMDMOD3      1   3.75   3.749  16.2300 5.756e-05 ***
## TMNMOD3      1   0.60   0.602   2.6081  0.106428    
## VBFMRG5      1  12.75  12.750  55.1943 1.433e-13 ***
## VDPMRG5      1  10.80  10.797  46.7375 9.880e-12 ***
## soilmap     19  44.83   2.359  10.2135 &lt; 2.2e-16 ***
## Residuals 2864 661.60   0.231                       
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>In those two models above, we used all available points. It is important to test the performance of a model based upon an external validation. Let’s fit a new model using a random subset of the available data. We will sample <span class="math inline">\(70\%\)</span> of the SOC data for the model calibration data set.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb66-1" data-line-number="1"><span class="co"># graphical diagnosis of the regression analysis</span></a>
<a class="sourceLine" id="cb66-2" data-line-number="2"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>))</a>
<a class="sourceLine" id="cb66-3" data-line-number="3"><span class="kw">plot</span>(model.MLR.step)</a></code></pre></div>
<pre><code>## Warning: not plotting observations with leverage one:
##   340

## Warning: not plotting observations with leverage one:
##   340</code></pre>
<p><img src="SOCMapping_files/figure-html4/unnamed-chunk-41-1.png" width="672" /></p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb68-1" data-line-number="1"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</a></code></pre></div>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb69-1" data-line-number="1"><span class="co"># collinearity test using variance inflation factors</span></a>
<a class="sourceLine" id="cb69-2" data-line-number="2"><span class="kw">library</span>(car)</a>
<a class="sourceLine" id="cb69-3" data-line-number="3"><span class="kw">vif</span>(model.MLR.step)</a></code></pre></div>
<pre><code>##              GVIF Df GVIF^(1/(2*Df))
## B04CHE3 17.352988  1        4.165692
## B07CHE3 17.580993  1        4.192969
## B13CHE3 14.463943  1        3.803149
## DEMENV5 14.325207  1        3.784866
## LCEE10   3.349841  3        1.223219
## PRSCHE3 20.323563  1        4.508166
## SLPMRG5  3.201225  1        1.789197
## TMDMOD3  6.724708  1        2.593204
## TMNMOD3  6.172634  1        2.484479
## VBFMRG5  4.182605  1        2.045142
## VDPMRG5  1.933334  1        1.390444
## soilmap 16.784795 19        1.077047</code></pre>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb71-1" data-line-number="1"><span class="co"># problematic covariates should have sqrt(VIF) &gt; 2</span></a>
<a class="sourceLine" id="cb71-2" data-line-number="2"><span class="kw">sqrt</span>(<span class="kw">vif</span>(model.MLR.step))</a></code></pre></div>
<pre><code>##             GVIF       Df GVIF^(1/(2*Df))
## B04CHE3 4.165692 1.000000        2.041003
## B07CHE3 4.192969 1.000000        2.047674
## B13CHE3 3.803149 1.000000        1.950166
## DEMENV5 3.784866 1.000000        1.945473
## LCEE10  1.830257 1.732051        1.105992
## PRSCHE3 4.508166 1.000000        2.123244
## SLPMRG5 1.789197 1.000000        1.337609
## TMDMOD3 2.593204 1.000000        1.610343
## TMNMOD3 2.484479 1.000000        1.576223
## VBFMRG5 2.045142 1.000000        1.430085
## VDPMRG5 1.390444 1.000000        1.179171
## soilmap 4.096925 4.358899        1.037809</code></pre>
<p>colinear: Temperature seasonality at 1 km (B04CHE3) and Temperature Annual Range [°C] at 1 km (B07CHE3)</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb73-1" data-line-number="1"><span class="co"># Removing B07CHE3 from the stepwise model:</span></a>
<a class="sourceLine" id="cb73-2" data-line-number="2">model.MLR.step &lt;-<span class="st"> </span><span class="kw">update</span>(model.MLR.step, . <span class="op">~</span><span class="st"> </span>. <span class="op">-</span><span class="st"> </span>B07CHE3)</a>
<a class="sourceLine" id="cb73-3" data-line-number="3"></a>
<a class="sourceLine" id="cb73-4" data-line-number="4"><span class="co"># Test the vif again:</span></a>
<a class="sourceLine" id="cb73-5" data-line-number="5"><span class="kw">sqrt</span>(<span class="kw">vif</span>(model.MLR.step))</a></code></pre></div>
<pre><code>##             GVIF       Df GVIF^(1/(2*Df))
## B04CHE3 2.268418 1.000000        1.506127
## B13CHE3 3.624615 1.000000        1.903842
## DEMENV5 3.645817 1.000000        1.909402
## LCEE10  1.818077 1.732051        1.104762
## PRSCHE3 4.460815 1.000000        2.112064
## SLPMRG5 1.783090 1.000000        1.335324
## TMDMOD3 2.572322 1.000000        1.603846
## TMNMOD3 2.299838 1.000000        1.516522
## VBFMRG5 2.015123 1.000000        1.419550
## VDPMRG5 1.387165 1.000000        1.177780
## soilmap 3.840284 4.358899        1.036043</code></pre>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb75-1" data-line-number="1"><span class="co"># summary  of the new model using stepwise covariates selection</span></a>
<a class="sourceLine" id="cb75-2" data-line-number="2"><span class="kw">summary</span>(model.MLR.step)</a></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = log(OCSKGM) ~ B04CHE3 + B13CHE3 + DEMENV5 + LCEE10 + 
##     PRSCHE3 + SLPMRG5 + TMDMOD3 + TMNMOD3 + VBFMRG5 + VDPMRG5 + 
##     soilmap, data = datdf)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -3.3857 -0.2662  0.0390  0.3096  1.9418 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  1.536e+01  3.896e+00   3.943 8.23e-05 ***
## B04CHE3     -2.919e-03  5.994e-04  -4.869 1.18e-06 ***
## B13CHE3     -5.955e-03  1.566e-03  -3.804 0.000146 ***
## DEMENV5     -2.651e-04  8.612e-05  -3.079 0.002099 ** 
## LCEE102      1.006e-01  3.373e-02   2.983 0.002879 ** 
## LCEE103      1.250e-01  5.479e-02   2.281 0.022598 *  
## LCEE104     -2.756e-02  4.358e-02  -0.632 0.527224    
## PRSCHE3      1.063e-03  3.111e-04   3.417 0.000642 ***
## SLPMRG5     -2.041e-03  1.505e-03  -1.356 0.175085    
## TMDMOD3     -5.275e-02  7.563e-03  -6.974 3.80e-12 ***
## TMNMOD3      8.998e-03  1.197e-02   0.752 0.452305    
## VBFMRG5      4.401e-04  9.738e-05   4.519 6.47e-06 ***
## VDPMRG5     -2.792e-05  4.357e-06  -6.410 1.70e-10 ***
## soilmap2    -4.166e-01  4.892e-01  -0.852 0.394494    
## soilmap3    -1.925e-01  4.832e-01  -0.398 0.690372    
## soilmap4    -1.959e-01  4.894e-01  -0.400 0.688957    
## soilmap5    -6.440e-02  5.211e-01  -0.124 0.901641    
## soilmap6     2.098e-01  4.849e-01   0.433 0.665224    
## soilmap7     1.337e-01  4.865e-01   0.275 0.783490    
## soilmap8    -1.838e-01  4.856e-01  -0.379 0.705074    
## soilmap9    -3.376e-01  4.825e-01  -0.700 0.484097    
## soilmap10   -9.951e-02  4.841e-01  -0.206 0.837162    
## soilmap11   -3.570e-01  4.882e-01  -0.731 0.464661    
## soilmap12   -2.104e-01  4.830e-01  -0.436 0.663172    
## soilmap13    2.675e-01  5.570e-01   0.480 0.631148    
## soilmap14   -2.312e-01  4.836e-01  -0.478 0.632615    
## soilmap15   -1.733e-01  4.883e-01  -0.355 0.722668    
## soilmap16   -3.620e-01  4.839e-01  -0.748 0.454464    
## soilmap17   -1.564e-01  4.846e-01  -0.323 0.746854    
## soilmap18   -6.759e-02  4.837e-01  -0.140 0.888886    
## soilmap19   -5.479e-01  5.090e-01  -1.076 0.281873    
## soilmap20   -3.061e-01  4.853e-01  -0.631 0.528351    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.4814 on 2865 degrees of freedom
## Multiple R-squared:  0.2445, Adjusted R-squared:  0.2363 
## F-statistic:  29.9 on 31 and 2865 DF,  p-value: &lt; 2.2e-16</code></pre>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb77-1" data-line-number="1"><span class="co"># outlier test using the Bonferroni test</span></a>
<a class="sourceLine" id="cb77-2" data-line-number="2"><span class="kw">outlierTest</span>(model.MLR.step)</a></code></pre></div>
<pre><code>##       rstudent unadjusted p-value Bonferonni p
## 1967 -7.114604         1.4122e-12   4.0897e-09
## 705  -6.795188         1.3108e-11   3.7959e-08
## 1154 -6.045856         1.6789e-09   4.8621e-06
## 1395 -5.112379         3.3907e-07   9.8194e-04
## 709  -5.078342         4.0515e-07   1.1733e-03
## 1229 -4.842237         1.3520e-06   3.9155e-03
## 1136 -4.468410         8.1860e-06   2.3707e-02</code></pre>
</div>
<div id="prediction-and-residual-kriging" class="section level4">
<h4><span class="header-section-number">6.2.7.4</span> Prediction and Residual Kriging</h4>
<p>Now we can make the predictions and plot the map. We can use either our DSM_data table for covariate values or <code>covs</code> object for making our prediction. Using stack avoids the step of arranging all covariates into a table format. If multiple rasters are being used, it is necessary to have them arranged as a rasterStack object. This is useful as it also ensures all the rasters are of the same extent and resolution. Here we can use the raster predict function such as below using the covStack raster stack as we created in the Step 3.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb79-1" data-line-number="1"><span class="co"># Project point data.</span></a>
<a class="sourceLine" id="cb79-2" data-line-number="2">dat &lt;-<span class="st"> </span><span class="kw">spTransform</span>(dat, <span class="kw">CRS</span>(<span class="st">&quot;+init=epsg:6204&quot;</span>))</a>
<a class="sourceLine" id="cb79-3" data-line-number="3"></a>
<a class="sourceLine" id="cb79-4" data-line-number="4"><span class="co"># project covariates to VN-2000 UTM 48N</span></a>
<a class="sourceLine" id="cb79-5" data-line-number="5">covs &lt;-<span class="st"> </span><span class="kw">projectRaster</span>(covs, <span class="dt">crs =</span> <span class="kw">CRS</span>(<span class="st">&quot;+init=epsg:6204&quot;</span>),</a>
<a class="sourceLine" id="cb79-6" data-line-number="6">                      <span class="dt">method=</span><span class="st">&#39;ngb&#39;</span>)</a>
<a class="sourceLine" id="cb79-7" data-line-number="7"></a>
<a class="sourceLine" id="cb79-8" data-line-number="8">covs<span class="op">$</span>LCEE10 &lt;-<span class="st"> </span><span class="kw">as.factor</span>(covs<span class="op">$</span>LCEE10)</a>
<a class="sourceLine" id="cb79-9" data-line-number="9">covs<span class="op">$</span>soilmap &lt;-<span class="st"> </span><span class="kw">as.factor</span>(covs<span class="op">$</span>soilmap)</a></code></pre></div>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb80-1" data-line-number="1"><span class="co"># Promote covariates to spatial grid dataframe. Takes some time and</span></a>
<a class="sourceLine" id="cb80-2" data-line-number="2"><span class="co"># a lot of memory!</span></a>
<a class="sourceLine" id="cb80-3" data-line-number="3">covs.sp &lt;-<span class="st"> </span><span class="kw">as</span>(covs, <span class="st">&quot;SpatialGridDataFrame&quot;</span>)</a>
<a class="sourceLine" id="cb80-4" data-line-number="4">covs.sp<span class="op">$</span>LCEE10 &lt;-<span class="st"> </span><span class="kw">as.factor</span>(covs.sp<span class="op">$</span>LCEE10)</a>
<a class="sourceLine" id="cb80-5" data-line-number="5">covs.sp<span class="op">$</span>soilmap &lt;-<span class="st"> </span><span class="kw">as.factor</span>(covs.sp<span class="op">$</span>soilmap)</a></code></pre></div>
<pre><code>## Checking if any bins have less than 5 points, merging bins when necessary...
## 
## Selected:
##   model      psill    range
## 1   Nug 0.16735323    0.000
## 2   Sph 0.06746394 6646.127
## 
## Tested models, best first:
##    Tested.models kappa      SSerror
## 1            Sph     0 3.964233e-07
## 25           Ste    10 4.182590e-07
## 24           Ste     5 4.266696e-07
## 23           Ste     2 4.501717e-07
## 22           Ste   1.9 4.519816e-07
## 21           Ste   1.8 4.539405e-07
## 20           Ste   1.7 4.560649e-07
## 19           Ste   1.6 4.583753e-07
## 18           Ste   1.5 4.608930e-07
## 17           Ste   1.4 4.636455e-07
## 16           Ste   1.3 4.666616e-07
## 3            Gau     0 4.680499e-07
## 15           Ste   1.2 4.699776e-07
## 14           Ste   1.1 4.736337e-07
## 13           Ste     1 4.776785e-07
## 12           Ste   0.9 4.821684e-07
## 11           Ste   0.8 4.871689e-07
## 10           Ste   0.7 4.927610e-07
## 9            Ste   0.6 4.990387e-07
## 2            Exp     0 5.061150e-07
## 8            Ste   0.5 5.061153e-07
## 7            Ste   0.4 5.141265e-07
## 6            Ste   0.3 5.232363e-07
## 5            Ste   0.2 5.336428e-07
## 4            Ste  0.05 1.148336e-06
## [using universal kriging]</code></pre>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb82-1" data-line-number="1">### RK model</a>
<a class="sourceLine" id="cb82-2" data-line-number="2"><span class="kw">library</span>(automap)</a>
<a class="sourceLine" id="cb82-3" data-line-number="3"></a>
<a class="sourceLine" id="cb82-4" data-line-number="4"></a>
<a class="sourceLine" id="cb82-5" data-line-number="5">## Run regression kriging prediction. This step can take hours...!</a>
<a class="sourceLine" id="cb82-6" data-line-number="6">OCS.krige &lt;-<span class="st"> </span><span class="kw">autoKrige</span>(<span class="dt">formula =</span></a>
<a class="sourceLine" id="cb82-7" data-line-number="7">                         <span class="kw">as.formula</span>(model.MLR.step<span class="op">$</span>call<span class="op">$</span>formula),</a>
<a class="sourceLine" id="cb82-8" data-line-number="8">                       <span class="dt">input_data =</span> dat,</a>
<a class="sourceLine" id="cb82-9" data-line-number="9">                       <span class="dt">new_data =</span> covs.sp,</a>
<a class="sourceLine" id="cb82-10" data-line-number="10">                       <span class="dt">verbose =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb82-11" data-line-number="11">                       <span class="dt">block =</span> <span class="kw">c</span>(<span class="dv">1000</span>, <span class="dv">1000</span>))</a>
<a class="sourceLine" id="cb82-12" data-line-number="12"></a>
<a class="sourceLine" id="cb82-13" data-line-number="13">OCS.krige</a></code></pre></div>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb83-1" data-line-number="1">## Convert prediction and standard deviation to rasters</a>
<a class="sourceLine" id="cb83-2" data-line-number="2">## And back-tansform the vlaues</a>
<a class="sourceLine" id="cb83-3" data-line-number="3">RKprediction &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="kw">raster</span>(OCS.krige<span class="op">$</span>krige_output[<span class="dv">1</span>]))</a>
<a class="sourceLine" id="cb83-4" data-line-number="4">RKpredsd &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="kw">raster</span>(OCS.krige<span class="op">$</span>krige_output[<span class="dv">3</span>]))</a></code></pre></div>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb84-1" data-line-number="1"><span class="kw">plot</span>(RKprediction)</a></code></pre></div>
<p><img src="SOCMapping_files/figure-html4/unnamed-chunk-49-1.png" width="672" /></p>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb85-1" data-line-number="1"><span class="kw">plot</span>(RKpredsd)</a></code></pre></div>
<p><img src="SOCMapping_files/figure-html4/unnamed-chunk-50-1.png" width="672" /></p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb86-1" data-line-number="1">## Save results as tif files</a>
<a class="sourceLine" id="cb86-2" data-line-number="2"><span class="kw">writeRaster</span>(RKprediction, <span class="dt">filename =</span> <span class="st">&quot;results/MKD_OCSKGM_RK.tif&quot;</span>,</a>
<a class="sourceLine" id="cb86-3" data-line-number="3">            <span class="dt">overwrite =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb86-4" data-line-number="4"></a>
<a class="sourceLine" id="cb86-5" data-line-number="5"><span class="kw">writeRaster</span>(RKpredsd, <span class="dt">filename =</span> <span class="st">&quot;results/MKD_OCSKGM_RKpredsd.tif&quot;</span>,</a>
<a class="sourceLine" id="cb86-6" data-line-number="6">            <span class="dt">overwrite =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb87-1" data-line-number="1"><span class="co"># save the model</span></a>
<a class="sourceLine" id="cb87-2" data-line-number="2"><span class="kw">saveRDS</span>(model.MLR.step, <span class="dt">file=</span><span class="st">&quot;results/RKmodel.Rds&quot;</span>)</a></code></pre></div>
</div>
</div>
<div id="technical-steps---cross-validation-of-regression-kriging-models" class="section level3">
<h3><span class="header-section-number">6.2.8</span> Technical Steps - Cross-validation of Regression Kriging models</h3>
<p>Cross-validation is introduced in Section <a href="chvalidation.html#xval">7.4.3</a>. In Regression-Kriging models, n-fold cross-validation and leave-one-out cross-validation can be run using the <code>krige.cv()</code> included in **gstat* R package. In this example, we will apply 10 fold cross-validation to our RK model.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb88-1" data-line-number="1">OCS.krige.cv &lt;-<span class="st"> </span><span class="kw">autoKrige.cv</span>(<span class="dt">formula =</span> </a>
<a class="sourceLine" id="cb88-2" data-line-number="2">                            <span class="kw">as.formula</span>(model.MLR.step<span class="op">$</span>call<span class="op">$</span>formula), </a>
<a class="sourceLine" id="cb88-3" data-line-number="3">                             <span class="dt">input_data =</span> dat, <span class="dt">nfold =</span> <span class="dv">10</span>)</a></code></pre></div>
<div class="sourceCode" id="cb89"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb89-1" data-line-number="1"><span class="kw">summary</span>(OCS.krige.cv)</a></code></pre></div>
<pre><code>##             [,1]    
## mean_error  0.004726
## me_mean     -0.3918 
## MAE         0.3402  
## MSE         0.2692  
## MSNE        0.9504  
## cor_obspred 0.4471  
## cor_predres -0.3132 
## RMSE        0.5188  
## RMSE_sd     0.9418  
## URMSE       0.5188  
## iqr         0.5223</code></pre>


</div>
</div>
<div id="rf" class="section level2">
<h2><span class="header-section-number">6.3</span> Data mining: Random Forest</h2>
<p><em>M Guevara, C Thine, GF Olmedo &amp; RR Vargas</em></p>
<div id="overview-2" class="section level3">
<h3><span class="header-section-number">6.3.1</span> Overview</h3>
<p>Data mining uses different forms of statistics, such as machine learning, to explore data matrices for a particular situation, from specific information sources, and with a specific objective. Data mining is used in digital soil mapping frameworks to generate spatial and temporal predictions of soil properties or classes in places where no information is available. Under a data mining-based digital soil mapping framework, the exploration of statistical relationships (linear and non-linear) between soil observational data and soil environmental predictors is generally performed by the means of machine learning. Machine learning methods represent a branch of statistics that can be used to automatically extract information from available data, including the non-linear and hidden relationships of high dimensional spaces or hyper-volumes of information when high performance or distributed computing resources are available. Machine learning methods do not rely on statistical assumptions about the spatial structure of soil variability or the empirical relationship of soil available data and its environmental predictors. Therefore machine learning methods are also suitable for digital soil mapping under limited and sparse scenarios of data availability, although in practice the statistical performance of machine learning (or any statistical method) is reduced by a low representativeness of a soil property or class in the statistical space given available data. Machine learning methods can be used for (supervised and unsupervised) regression (e.g., predicting soil organic carbon) or classification (e.g., predicting soil type classes) on digital soil mapping. Machine learning methods can be roughly divided into four main groups: linear-based (e.g., multiple linear regression), kernel-based (e.g., kernel weighted nearest neighbors or support vector machines), probabilistic-based (e.g., Bayesian statistics) and tree-based (e.g., classification and regression trees). Random forest is a tree-based machine learning algorithm that is popular on digital soil mapping because it has proven to be efficient mapping soil properties across a wide range of data scenarios and scales of soil variability. Random forest can be implemented using open source platforms and this chapter is devoted to provide a reproducible example of this machine learning algorithm applied to soil organic carbon mapping across Macedonia.</p>
</div>
<div id="random-forests" class="section level3">
<h3><span class="header-section-number">6.3.2</span> Random forests</h3>
<p>Random forest is a Decision-tree-based machine learning method used in digital soil mapping for uncovering the statistical relationship between a dependent variable (e.g., soil property) and its predictors. Decision-tree-based models (also known as classifiers) are literally like trees (e.g., with stem, many branches, and leaves). The leaves are the prediction outcomes (final decisions) that flow from higher levels based on decision rules through the stem and the branches . The decision tree model recursively splits the data into final uniform groups (classes) or unique values based on a set of rules (e.g., based on probability values and hypothesis testing). In random forest, there are many decision trees and each tree recursively splits randomly selected sub-samples from the data (Figure <a href="mappingMethods.html#fig:rfschema">6.11</a>). The name random forest originates from the fact that the original data is first randomly split into sub-samples, and many decision trees (or forest) are used to model the sub-samples.</p>
<div class="figure" style="text-align: center"><span id="fig:rfschema"></span>
<img src="images/randomForestconcept.png" alt="Schematical representation of data splitting data to generate the random subsets used to train regression trees within a Random forest model (ensemble of regression trees)" width="80%" />
<p class="caption">
Figure 6.11: Schematical representation of data splitting data to generate the random subsets used to train regression trees within a Random forest model (ensemble of regression trees)
</p>
</div>
<p>Random forest has been tested by many researchers on digital soil mapping (see for example <span class="citation">Poggio, Gimona, and Brewer (<a href="#ref-poggio2013regional">2013</a>)</span>; <span class="citation">Rad et al. (<a href="#ref-rad2014updating">2014</a>)</span>, and references therein). For soil carbon mapping (which for large areas usually rely on sparse datasets), it holds a lot of promises when compared to other prediction models, because it’s practically free of assumptions. Random Forest has shown accuracy of spatial predictions and, given the random selection of subsets and prediction factors, reduce potential over-fitting and data noise <span class="citation">(Wiesmeier et al. <a href="#ref-wiesmeier2011digital">2011</a>)</span>. Over-fitting and data noise are important uncertainty sources across high dimensionally spaces used to represent the soil forming environment. Thus, the advent of open-source platforms and freely downloadable ancillary data (e.g., worldgrids.org) to represent the soil forming environment makes of random forest and other such models increasingly appealing on digital soil mapping.</p>
<p>To predict continuous data (such as carbon density) Random forest generates an averaged ensemble of regression trees based on bagging, which is the statistical term for the random selection of subsets and predictors to generate each regression tree. Bagging is a bootstrapping aggregation technique where each sample is different from the original data set but resembles it in distribution and variability (Breiman, 1996, 2001). Each tree contributes to weight the statistical relationship between a dependent variable (e.g. soil property) and its prediction factors (e.g., terrain attributes, remote sensing, climate layers and/or legacy maps). Each tree (generated using a different subset of available data and random combinations of the prediction factors) is internally evaluated by an out-of-bag cross validation form which allows assessing the relative importance of the available prediction factors. Thus, higher weight is given to the most accurate trees (which use the most informative prediction factors). The final prediction of new data is the weighted average of all generated trees. This method has been used to generate accurate predictions of soil organic carbon from the plot to the global scale and also in a country-specific basis (Hengl et al., 2014; Bonfatti et al., 2016; Hengl et al., 2017; Guevara et al., 2018). Random forest can be implemented for digital soil mapping using open source code <span class="citation">(e.g., the R package of random forest, see Breiman <a href="#ref-breiman2017cutler">2017</a>)</span> and public sources of environmental information. The objective of this chapter is to demonstrate a reproducible framework for the implementation of the Random forest algorithm applied for soil organic carbon predictive mapping, including the uncertainty of model estimates and using open source platforms for statistical computing.</p>
</div>
<div id="conceptual-model-and-data-preparation" class="section level3">
<h3><span class="header-section-number">6.3.3</span> Conceptual model and data preparation</h3>
<p>To use Random forest for digital soil organic carbon mapping the SCORPAN (Soils, Climate, Organisms, Relief, Parent material, Age and N space) conceptual model (McBratney et al., 2003; Florinsky, 2012) will have take the following form: <span class="math inline">\(\ \text{SOC}_{x,y~t} \sim \text{randomForest} (E_{x,y~t})\)</span> where soil organic carbon estimates (<em>SOC</em>) for a specific site (<em>x,y</em>) and for a specific period of time (~t) can be modeled as a Random forest (randomForest) function of the soil forming environment (<span class="math inline">\(\ Ex,y~t\)</span>), which is represented by the <em>SOC</em> prediction factors (e.g., terrain attributes, remote sensing, climate layers and/or legacy maps). To feed the right side of the equation, <span class="math inline">\(SOC_{x,y~t}\)</span> is usually represented in a tabular form or a geospatial object (e.g., shapefile) with three fundamental columns. Two columns represent the spatial coordinates x and y (e.g., latitude and longitude) that are used to extract the values of the prediction factors for the representative locations of the <em>SOC</em> estimates. <em>SOC</em> estimates are represented in a third column (see previous chapters of this book dealing with the transformation of soil carbon density to mass units). The left side of the equation is generally represented by gridded (raster) files, so all available sources of information should be first harmonized into a common pixel size and coordinate reference system.</p>
</div>
<div id="software" class="section level3">
<h3><span class="header-section-number">6.3.4</span> Software</h3>
<p>For the Random Forest implementation, we will use the platform for statistical computing R (R Core Team, 2016). This is an open source object-oriented software that relies on specific-contributor libraries. There are several libraries for the implementation of the Random forest algorithm in R as well as several variants of the method that can be used to solve digital soil mapping problems. In this section, we will show the use of Random forest using the randomForest, the quantregForest, the raster and the caret R packages. The quantile regression forest (quantregForest; (Meinshausen, 2006)) has two main advantages. First, it can be used to extract the variance of all the trees generated by Random forest, not just the mean (as in the original randomForest package), and therefore we can calculate the dispersion of the full conditional distribution of SOC as a function of the prediction factors, which given available data, represent the Random forest model uncertainty. Second, the quantile regression forest approach can also run in parallel using all available computational resources, in a way that we can predict and estimate the uncertainty of predictions at reasonable time frames whit large datasets.</p>
</div>
<div id="tunning-random-forest-parameters" class="section level3">
<h3><span class="header-section-number">6.3.5</span> Tunning Random forest parameters</h3>
<p>Two important parameters of Random forest are mtry and ntree. The mtry parameter controls the number of prediction factors that are randomly used on each tree, while the ntree parameter controls the number of trees generated by Random forest. These two parameters can be selected by the means of cross-validation to maximize the prediction capacity of Random forest. We will use the caret package to select the most appropriate values for these parameters using 10-fold cross-validation (Kuhn et al. 2017). Tunning the main parameters of Random forest (or any other model) can be time-consuming in computational terms because implies the need to run and internally validate an independent model for each possible combination of parameter values. Thus, tunning the Random forest parameters would be relevant, given available data, to achieve the best possible accuracy of predictions.</p>
</div>
<div id="technical-steps---random-forest" class="section level3">
<h3><span class="header-section-number">6.3.6</span> Technical steps - Random forest</h3>
<p>We will use the Macedonia dataset for this exercise (see previous chapters of this book dealing with data preparation). The first dataset contains in a tabular form the <em>OCSKGM</em> values and the values of the prediction factors for the same locations (e.g., x, y, <em>OCSKGM</em>, covariate1, covariate2…) while the second database is represented by a stack of raster files containing prediction factors across all the area of interest at the spatial resolution of 0.0083º (approx. 1km). Import the datasets and load in R all our libraries of interest.</p>
<div id="data-preparation-2" class="section level4">
<h4><span class="header-section-number">6.3.6.1</span> Data Preparation</h4>
<p><strong>Point Dataset</strong></p>
<p>We previously applied spline function to produce continuous soil information to a given soil depth (0-30 cm) in section <a href="preparation.html#EqualAreaSplines">3.4.1</a>. Spline function basically imports soil profile data (including instances where layers are not contiguous), fits it to a mass-preserving spline and outputs attribute means for a given depth. The output file should contain profile id, upper (surface) and lower depth (30cm), the estimated value for the selected soil attribute (Value) and tmse (estimated mean squared error of the spline). If you used the Spline Tool V2, the coordinates were not kept in the output file. The coordinates should be added back in the data table. You can use Profile IDs to add the X, Y columns back. Once your point dataset is ready, copy this table into your working directory as a .csv file.</p>
<p><strong>Environmental Predictors (Covariates)</strong></p>
<p>In the Chapter <a href="covariates.html#covariates">5</a>, we presented and prepared several global and continental data sets. In addition to these datasets, numerous covariate layers have been prepared by ISRIC for the GSOC Map project. These are GIS raster layers of various biophysical earth surface properties for each country in the world. Some of these layers will be used as predictors in this section. Please download the covariates for your own study area from GSOCMap Data Repository as explained in Section <a href="covariates.html#GSOCDataRepo">5.6</a>.</p>
<p>In section <a href="covariates.html#overlay-soil-covariates">5.9</a>, a table with the points values after data preparation and the values of our spatial predictors was prepared. This step involves loading this table.</p>
<p>Now we will import our point dataset using <code>read.csv()</code> function. The easiest way to create a data frame is to read in data from a file—this is done using the function read.csv, which works with comma delimited files. Data can be read in from other file formats as well, using different functions, but read.csv is the most commonly used approach. R is very flexible in how it reads in data from text files (<code>read.table</code>, <code>read.csv</code>, <code>read.csv2</code>, <code>read.delim</code>, <code>read.delim2</code>). Please type <code>?read.table()</code> for help.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb91-1" data-line-number="1"><span class="co"># load data</span></a>
<a class="sourceLine" id="cb91-2" data-line-number="2">dat &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/MKD_RegMatrix.csv&quot;</span>)</a>
<a class="sourceLine" id="cb91-3" data-line-number="3"></a>
<a class="sourceLine" id="cb91-4" data-line-number="4">dat<span class="op">$</span>LCEE10 &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat<span class="op">$</span>LCEE10)</a>
<a class="sourceLine" id="cb91-5" data-line-number="5">dat<span class="op">$</span>soilmap &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat<span class="op">$</span>soilmap)</a>
<a class="sourceLine" id="cb91-6" data-line-number="6"></a>
<a class="sourceLine" id="cb91-7" data-line-number="7"><span class="co"># explore the data structure</span></a>
<a class="sourceLine" id="cb91-8" data-line-number="8"><span class="kw">str</span>(dat)</a></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    2897 obs. of  23 variables:
##  $ id       : Factor w/ 2897 levels &quot;P0003&quot;,&quot;P0007&quot;,..: 1 2 3 4..
##  $ Y        : num  42 42 42.1 42 42 ...
##  $ X        : num  20.8 20.8 20.8 20.9 20.9 ...
##  $ SOC      : num  26.38 6.15 3.94 3.26 2.29 ...
##  $ BLD      : num  0.73 1.17 1.3 1.34 1.41 ...
##  $ CRFVOL   : num  8 18.6 31.9 21.7 14.5 ...
##  $ OCSKGM   : num  5.32 1.75 1.04 1.03 0.83 ...
##  $ meaERROR : num  2.16 2.85 2.65 3.16 3.63 2.83 2.94 2.49 2.77..
##  $ OCSKGMlog: num  1.6712 0.5591 0.0429 0.0286 -0.1862 ...
##  $ B04CHE3  : num  574 553 693 743 744 ...
##  $ B07CHE3  : num  38.5 37.8 42.1 43.7 43.7 ...
##  $ B13CHE3  : num  111.6 125 99.8 118.1 121 ...
##  $ B14CHE3  : num  59.2 60.3 42.4 39.9 38.7 ...
##  $ DEMENV5  : int  2327 2207 1243 1120 1098 1492 1413 1809 1731..
##  $ LCEE10   : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 3 2 1 2 2 2..
##  $ PRSCHE3  : num  998 1053 780 839 844 ...
##  $ SLPMRG5  : int  13 36 6 25 30 24 15 17 20 43 ...
##  $ TMDMOD3  : int  282 280 285 288 289 287 286 286 287 286 ...
##  $ TMNMOD3  : int  272 270 277 279 279 277 277 273 274 273 ...
##  $ TWIMRG5  : int  61 62 81 66 65 72 68 67 65 59 ...
##  $ VBFMRG5  : int  0 0 14 0 0 0 0 0 0 0 ...
##  $ VDPMRG5  : int  311 823 10048 1963 -173 -400 -9 -692 -1139 2..
##  $ soilmap  : Factor w/ 20 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 6 14 14 3..</code></pre>
<p>Since we will be working with spatial data we need to define the coordinates for the imported data. Using the coordinates() function from the sp package we can define the columns in the data frame to refer to spatial coordinates—here the coordinates are listed in columns X and Y.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb93-1" data-line-number="1"><span class="kw">library</span>(sp)</a>
<a class="sourceLine" id="cb93-2" data-line-number="2"></a>
<a class="sourceLine" id="cb93-3" data-line-number="3"><span class="co"># Promote to spatialPointsDataFrame</span></a>
<a class="sourceLine" id="cb93-4" data-line-number="4"><span class="kw">coordinates</span>(dat) &lt;-<span class="st"> </span><span class="er">~</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>Y</a>
<a class="sourceLine" id="cb93-5" data-line-number="5"></a>
<a class="sourceLine" id="cb93-6" data-line-number="6"><span class="kw">class</span>(dat)</a></code></pre></div>
<pre><code>## [1] &quot;SpatialPointsDataFrame&quot;
## attr(,&quot;package&quot;)
## [1] &quot;sp&quot;</code></pre>
<p>SpatialPointsDataFrame structure is essentially the same data frame, except that additional “spatial” elements have been added or partitioned into slots. Some important ones being the bounding box (sort of like the spatial extent of the data), and the coordinate reference system proj4string(), which we need to define for the sample dataset. To define the CRS, we must know where our data are from, and what was the corresponding CRS used when recording the spatial information in the field. For this data set, the CRS used was: WGS84 (EPSG:4326).</p>
<p>To clearly tell R this information we define the CRS which describes a reference system in a way understood by the <a href="http://trac.osgeo.org/proj/">PROJ.4 projection library</a>. An interface to the PROJ.4 library is available in the rgdal package. As a lternative to using Proj4 character strings, we can use the corresponding yet simpler EPSG code (European Petroleum Survey Group). rgdal also recognizes these codes. If you are unsure of the Proj4 or EPSG code for the spatial data that you have but know the CRS, you should consult <a href="http://spatialreference.org/" class="uri">http://spatialreference.org/</a> for assistance.</p>
<p>Please also note that, when working with spatial data, it’s very important that the CRS (coordinate reference system) of the point data and covariates are the same.</p>
<p>Now, we will define our CRS:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb95-1" data-line-number="1">dat<span class="op">@</span>proj4string &lt;-<span class="st"> </span><span class="kw">CRS</span>(<span class="dt">projargs =</span> <span class="st">&quot;+init=epsg:4326&quot;</span>)</a>
<a class="sourceLine" id="cb95-2" data-line-number="2"></a>
<a class="sourceLine" id="cb95-3" data-line-number="3">dat<span class="op">@</span>proj4string</a></code></pre></div>
<pre><code>## CRS arguments:
##  +init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs
## +ellps=WGS84 +towgs84=0,0,0</code></pre>
<p>Now we will import the covariates. When the covariate layers are in common resolution and extent, rather than working with individual rasters it is better to stack them all into a single R object. In this example, we use 13 covariates from the GSOCMap Data Repository and a rasterized version of the soil type map. The rasterization of vectorial data was covered in <a href="covariates.html#technical-steps---rasterizing-a-vector-layer-in-r">Technical Steps - Rasterizing a vector layer in R</a>. The file containing all the covariates was prepared at the end of chapter <a href="covariates.html#covariates">5</a>.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb97-1" data-line-number="1"><span class="kw">load</span>(<span class="dt">file =</span> <span class="st">&quot;covariates.RData&quot;</span>)</a>
<a class="sourceLine" id="cb97-2" data-line-number="2"></a>
<a class="sourceLine" id="cb97-3" data-line-number="3"><span class="kw">names</span>(covs)</a></code></pre></div>
<pre><code>##  [1] &quot;B04CHE3&quot; &quot;B07CHE3&quot; &quot;B13CHE3&quot; &quot;B14CHE3&quot; &quot;DEMENV5&quot; &quot;LCEE10&quot; 
##  [7] &quot;PRSCHE3&quot; &quot;SLPMRG5&quot; &quot;TMDMOD3&quot; &quot;TMNMOD3&quot; &quot;TWIMRG5&quot; &quot;VBFMRG5&quot;
## [13] &quot;VDPMRG5&quot; &quot;soilmap&quot;</code></pre>
<p>Random forest does not have assumptions about the statistical distribution of the response variable, but it is a good practice prior to model building to analyze the statistical distribution of the response variable (e.g., if is normal or not) and its relationships with the prediction factors. Soil organic carbon tends to have a log-normal distribution with a right-skew, and transforming the original values to its natural logarithm would generate a normal distribution of soil organic carbon values. For further analysis, we will use the dataset transformed to its natural logarithm (OCSKGMlog) because this transformation, given this dataset, increases the correlation of the response variable and the covariate space.</p>
<p>Keep in mind that selecting the most appropriate prediction factors is required to generate an interpretable model and high accuracy of prediction in places where no information is available. Variable selection ideally should incorporate expert soil knowledge about the study area and statistical criteria (e.g., just to use the best-correlated predictors). Multivariate analysis (e.g., principal component analysis) is a widely used approach to identify informative predictors. Here we use this combination of prediction factors to be consistent with other book chapters and because they were previously selected for this exercise using expert knowledge about the spatial variability of soil organic carbon. Now, we will build a working hypothesis from our conceptual model, using all the continuous prediction factors for <em>OCSKGMlog</em>:</p>
<p><em>OCSKGMlog</em> ~ randomForest <em>B04CHE3 + B07CHE3 + B13CHE3 + B14CHE3 + DEMENV5 + LCEE10 + PRSCHE3 + SLPMRG5 + TMDMOD3 + TMNMOD3 + TWIMRG5 + VBFMRG5 + VDPMRG5</em></p>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb99-1" data-line-number="1"><span class="co"># For its use on R we need to define a model formula</span></a>
<a class="sourceLine" id="cb99-2" data-line-number="2"></a>
<a class="sourceLine" id="cb99-3" data-line-number="3">fm =<span class="st"> </span><span class="kw">as.formula</span>(<span class="kw">paste</span>(<span class="st">&quot;log(OCSKGM) ~&quot;</span>, <span class="kw">paste0</span>(<span class="kw">names</span>(covs[[<span class="op">-</span><span class="dv">14</span>]]),</a>
<a class="sourceLine" id="cb99-4" data-line-number="4">                                            <span class="dt">collapse =</span> <span class="st">&quot;+&quot;</span>))) </a></code></pre></div>
<p>This is the R syntax to define a model formula required for the model structure, where soil organic carbon transformed to its natural logarithm (<em>OCSKGMlog</em>) can be predicted as a function of the available prediction factors (each explained in previous chapters of this book, e.g., B04CHE3, B07CHE3, B13CHE3, B14CHE3, DEMENV5 , LCEE10, PRSCHE3, SLPMRG5, TMDMOD3, TMNMOD3, TWIMRG5, VBFMRG5, VDPMRG5).</p>
<p>Note that the variable soilmap is categorical, so is not included in the correlation analysis. In fact, although soil type polygon maps are in theory powerful predictors for <em>OCSKGM</em> we will not use this map for this exercise, because not all categories in the map are represented by available <em>OCSKGM</em> estimates, therefore this map requires a generalization of soil type units in function of the classes represented by the sites of <em>OCSKGM</em> estimates, which is beyond the scope of this chapter. Ideally, the number of observations across all the categories of soil type or any other factorial variable should be balanced. Another alternative to using an unbalanced categorical map is by generating dummy variables, where each category in the map becomes an independent binomial predictor variable (e.g., only 0 and 1 values) as is explained in the following chapter. The risk of doing so rely upon the potential underestimation of the spatial variability of the target variable under each category with a low density of available data.</p>
</div>
<div id="tuning-parameters" class="section level4">
<h4><span class="header-section-number">6.3.6.2</span> Tuning parameters</h4>
<p>Now we will use the cross-validation strategy implemented in the train function of the caret package (Kuhn et al. 2017), which default is 10-fold. The result of this function includes information to select the best mtry parameter and to decide the appropriate number of trees. The out-of-bag root mean squared error (rmse) will be used to select the optimal mtry model. To analyze the ntree parameter we will plot the number of trees against the out-of-bag rmse, an optimal ntree can be selected with the number of trees when these relationships stabilizes at the minimum possible rmse (in the y axis). Reduncing the number of trees will reduce the computational demand, which is specially important when dealing with large databases. In the presence of multidimensional and highly correlated prediction factors, avoiding an excessive number of trees will also reduce the risk of model overfitting.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb100-1" data-line-number="1"><span class="kw">library</span>(randomForest)</a></code></pre></div>
<pre><code>## randomForest 4.6-12</code></pre>
<pre><code>## Type rfNews() to see new features/changes/bug fixes.</code></pre>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb103-1" data-line-number="1"><span class="kw">library</span>(caret)</a></code></pre></div>
<pre><code>## Loading required package: lattice</code></pre>
<pre><code>## Loading required package: ggplot2</code></pre>
<pre><code>## 
## Attaching package: &#39;ggplot2&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:randomForest&#39;:
## 
##     margin</code></pre>
<div class="sourceCode" id="cb108"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb108-1" data-line-number="1"><span class="co"># Default 10-fold cross-validation</span></a>
<a class="sourceLine" id="cb108-2" data-line-number="2">ctrl &lt;-<span class="st"> </span><span class="kw">trainControl</span>(<span class="dt">method =</span> <span class="st">&quot;cv&quot;</span>, <span class="dt">savePred=</span>T)</a>
<a class="sourceLine" id="cb108-3" data-line-number="3"><span class="co"># Search for the best mtry parameter</span></a>
<a class="sourceLine" id="cb108-4" data-line-number="4">rfmodel &lt;-<span class="st"> </span><span class="kw">train</span>(fm, <span class="dt">data=</span>dat<span class="op">@</span>data, <span class="dt">method =</span> <span class="st">&quot;rf&quot;</span>, <span class="dt">trControl =</span> ctrl, </a>
<a class="sourceLine" id="cb108-5" data-line-number="5">             <span class="dt">importance=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb108-6" data-line-number="6"><span class="co"># This is a very useful function to compare and test different </span></a>
<a class="sourceLine" id="cb108-7" data-line-number="7"><span class="co"># prediction algorithms. Type names(getModelInfo()) to see all the </span></a>
<a class="sourceLine" id="cb108-8" data-line-number="8"><span class="co"># possibilitites implemented on this function</span></a></code></pre></div>
<p>The object derived from the train function can be used to generate predictions of OCSKGMlog at the spatial resolution of the prediction factors. Before generating predictions, we will plot the most important predictors sorted in decreasing order of importance. From the variable importance plot, %IncMSE represent an informative measure for variable selection. It is the increase in error (mean squared error, MSE) of predictions which was estimated with out-of-bag-cross validation as a result of prediction factor being permuted with values randomly shuffled. This is one of the strategies that Random forest uses to reduce overfitting.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb109-1" data-line-number="1"><span class="co"># Variable importance plot, compare with the correlation matrix</span></a>
<a class="sourceLine" id="cb109-2" data-line-number="2"><span class="co"># Select the best prediction factors and repeat  </span></a>
<a class="sourceLine" id="cb109-3" data-line-number="3"><span class="kw">varImpPlot</span>(rfmodel[<span class="dv">11</span>][[<span class="dv">1</span>]])</a></code></pre></div>
<div class="figure"><span id="fig:unnamed-chunk-60"></span>
<img src="SOCMapping_files/figure-html4/unnamed-chunk-60-1.png" alt="Model Decreasing Error and Node Purity" width="672" />
<p class="caption">
Figure 6.12: Model Decreasing Error and Node Purity
</p>
</div>
<div class="sourceCode" id="cb110"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb110-1" data-line-number="1"><span class="co"># Check if the error stabilizes </span></a>
<a class="sourceLine" id="cb110-2" data-line-number="2"><span class="kw">plot</span>(rfmodel[<span class="dv">11</span>][[<span class="dv">1</span>]])</a></code></pre></div>
<div class="figure"><span id="fig:unnamed-chunk-61"></span>
<img src="SOCMapping_files/figure-html4/unnamed-chunk-61-1.png" alt="select ntree" width="672" />
<p class="caption">
Figure 6.13: select ntree
</p>
</div>
<p>Random forest users are encouraged to compare and test the prediction capacity of different combinations of prediction factors in order to reduce the complexity of the model and the statistical redundancy of environmental information on further applications of predicted OCSKGM maps (e.g., quantifying the carbon dynamics). The resulting map of our Random forest model needs to be validated using the independent dataset to complement the results of the cross-validation (e.g., rmse and explained variance) derived using the train function and to have a more comprehensive interpretation of accuracy and bias. Note how the rmse and the explained variance derived from the independent validations are slightly lower than the values obtained using cross-validation.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb111-1" data-line-number="1"><span class="co">#Make a prediction across all Macedonia</span></a>
<a class="sourceLine" id="cb111-2" data-line-number="2"><span class="co">#Note that the units are still in log</span></a>
<a class="sourceLine" id="cb111-3" data-line-number="3">pred &lt;-<span class="st"> </span><span class="kw">predict</span>(covs, rfmodel)</a></code></pre></div>
<pre><code>## Warning in .local(object, ...): not sure if the correct factor
## levels are used here</code></pre>
<div class="sourceCode" id="cb113"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb113-1" data-line-number="1"><span class="co"># Back transform predictions log transformed</span></a>
<a class="sourceLine" id="cb113-2" data-line-number="2">pred &lt;-<span class="st"> </span><span class="kw">exp</span>(pred)</a>
<a class="sourceLine" id="cb113-3" data-line-number="3"></a>
<a class="sourceLine" id="cb113-4" data-line-number="4"><span class="co"># Save the result as a tiff file</span></a>
<a class="sourceLine" id="cb113-5" data-line-number="5"><span class="kw">writeRaster</span>(pred, <span class="dt">filename =</span> <span class="st">&quot;results/MKD_OCSKGM_rf.tif&quot;</span>,</a>
<a class="sourceLine" id="cb113-6" data-line-number="6">            <span class="dt">overwrite=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb113-7" data-line-number="7"></a>
<a class="sourceLine" id="cb113-8" data-line-number="8"></a>
<a class="sourceLine" id="cb113-9" data-line-number="9"><span class="kw">plot</span>(pred)</a></code></pre></div>
<div class="figure"><span id="fig:rf-pred"></span>
<img src="SOCMapping_files/figure-html4/rf-pred-1.png" alt="SOC prediction using a randomForest model" width="672" />
<p class="caption">
Figure 6.14: SOC prediction using a randomForest model
</p>
</div>
</div>
</div>
<div id="modelling-uncertainty-using-random-forest" class="section level3">
<h3><span class="header-section-number">6.3.7</span> Modelling Uncertainty Using Random Forest</h3>
<p>Ideally, a digital soil map should include a spatial explicit metric of uncertainty. The uncertainty can be roughly divided into four main components, uncertainty in soil data, uncertainty in soil covariates, uncertainty in the model and uncertainty in variations of available data. Here, we show an approach to estimate the sensitivity of the model to available data and the uncertainty of the model. The first two are beyond of the aim of this chapter. For the third and fourth we will generate a reproducible example.</p>
<div id="technical-steps---using-quantile-regression-forest-to-estimate-uncertainty" class="section level4">
<h4><span class="header-section-number">6.3.7.1</span> Technical steps - Using Quantile Regression Forest to estimate uncertainty</h4>
<p>To analyze the sensitivity of the model to available data we need to randomly split the data several times (e.g., 10 or more, is possible until the variance stabilizes) in training and testing subsets. A model generation and prediction are made on each split, in a way that the dispersion of the predicted values at the pixel level will represent the uncertainty and the sensitivity of the model to variations in available data. This process increases computational demand and memory since it will repeat n times (10 in this example) the model and the prediction using each time a different random combination of data for training and testing the models. As larger the sample and the number of realizations the more robust our validation strategy. For this example, we will use only 10 realizations and random splits of 25% of available data. The validation plot shows the regression line between observed and predicted of a model that uses 75% (black line) and the regression lines of 10 model realizations, each with a different random combination of data for training and validating the models. The rmse and the explained variance of the models is stored in the object validation (type <code>summary(validation)</code>). The standard deviation of all the ten predictions allows generating a map of model sensitivity to available data.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb114-1" data-line-number="1"><span class="co">#Generate an empty dataframe</span></a>
<a class="sourceLine" id="cb114-2" data-line-number="2">validation &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">rmse=</span><span class="kw">numeric</span>(), <span class="dt">r2=</span><span class="kw">numeric</span>())</a>
<a class="sourceLine" id="cb114-3" data-line-number="3"><span class="co">#Sensitivity to the dataset</span></a>
<a class="sourceLine" id="cb114-4" data-line-number="4"><span class="co">#Start a loop with 10 model realizations</span></a>
<a class="sourceLine" id="cb114-5" data-line-number="5"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>){</a>
<a class="sourceLine" id="cb114-6" data-line-number="6">  <span class="co"># We will build 10 models using random samples of 25%  </span></a>
<a class="sourceLine" id="cb114-7" data-line-number="7">  smp_size &lt;-<span class="st"> </span><span class="kw">floor</span>(<span class="fl">0.25</span> <span class="op">*</span><span class="st"> </span><span class="kw">nrow</span>(dat))</a>
<a class="sourceLine" id="cb114-8" data-line-number="8">  train_ind &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">seq_len</span>(<span class="kw">nrow</span>(dat)), <span class="dt">size =</span> smp_size)</a>
<a class="sourceLine" id="cb114-9" data-line-number="9">  train &lt;-<span class="st"> </span>dat[train_ind, ]</a>
<a class="sourceLine" id="cb114-10" data-line-number="10">  test &lt;-<span class="st"> </span>dat[<span class="op">-</span>train_ind, ]</a>
<a class="sourceLine" id="cb114-11" data-line-number="11">  modn &lt;-<span class="st"> </span><span class="kw">train</span>(fm, <span class="dt">data=</span>train, <span class="dt">method =</span> <span class="st">&quot;rf&quot;</span>, <span class="dt">trControl =</span> ctrl)</a>
<a class="sourceLine" id="cb114-12" data-line-number="12">  pred &lt;-<span class="st"> </span><span class="kw">stack</span>(pred, <span class="kw">predict</span>(covariates, modn))</a>
<a class="sourceLine" id="cb114-13" data-line-number="13">  test<span class="op">$</span>pred &lt;-<span class="st"> </span><span class="kw">predict</span>(modn[<span class="dv">11</span>][[<span class="dv">1</span>]], test)</a>
<a class="sourceLine" id="cb114-14" data-line-number="14">  <span class="co"># Store the results in a dataframe</span></a>
<a class="sourceLine" id="cb114-15" data-line-number="15">  validation[i, <span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">rmse</span>(test<span class="op">$</span>OCSKGMlog, test<span class="op">$</span>pred)</a>
<a class="sourceLine" id="cb114-16" data-line-number="16">  validation[i, <span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">cor</span>(test<span class="op">$</span>OCSKGMlog, test<span class="op">$</span>pred)<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb114-17" data-line-number="17">}</a></code></pre></div>
<div class="sourceCode" id="cb115"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb115-1" data-line-number="1"><span class="co">#The sensitivity map is the dispersion of all individual models</span></a>
<a class="sourceLine" id="cb115-2" data-line-number="2">sensitivity &lt;-<span class="st"> </span><span class="kw">calc</span>(pred[[<span class="op">-</span><span class="dv">1</span>]], sd)</a>
<a class="sourceLine" id="cb115-3" data-line-number="3"></a>
<a class="sourceLine" id="cb115-4" data-line-number="4"><span class="kw">plot</span>(sensitivity, <span class="dt">col=</span><span class="kw">rev</span>(<span class="kw">topo.colors</span>(<span class="dv">10</span>)), </a>
<a class="sourceLine" id="cb115-5" data-line-number="5">     <span class="dt">main=</span><span class="st">&#39;Sensitivity based on 10 realizations using 25% samples&#39;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb116-1" data-line-number="1"><span class="co">#Sensitivity of validation metrics</span></a>
<a class="sourceLine" id="cb116-2" data-line-number="2"><span class="kw">summary</span>(validation)</a></code></pre></div>
<div class="sourceCode" id="cb117"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb117-1" data-line-number="1"><span class="co"># Plot of the map based on 75% of data and the sensitivity to data </span></a>
<a class="sourceLine" id="cb117-2" data-line-number="2"><span class="co"># variations</span></a>
<a class="sourceLine" id="cb117-3" data-line-number="3">prediction75 &lt;-<span class="st"> </span><span class="kw">exp</span>(pred[[<span class="dv">1</span>]])</a>
<a class="sourceLine" id="cb117-4" data-line-number="4"></a>
<a class="sourceLine" id="cb117-5" data-line-number="5"><span class="kw">plot</span>(prediction75, <span class="dt">main=</span><span class="st">&#39;OCSKGM prediction based on 75% of data&#39;</span>, </a>
<a class="sourceLine" id="cb117-6" data-line-number="6">     <span class="dt">col=</span><span class="kw">rev</span>(<span class="kw">topo.colors</span>(<span class="dv">10</span>)))</a></code></pre></div>
<p>Finally, we will estimate the model uncertainty, represented by the full conditional distribution of the response variable (OCSKGMlog) as a function of the selected prediction factors using the quantile regression forest package of R. This approach has proven to be efficient for digital soil mapping across large areas <span class="citation">(Vaysse and Lagacherie <a href="#ref-vaysse2017using">2017</a>)</span>.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb118-1" data-line-number="1"><span class="co"># Use quantile regression forest to estimate the full conditional </span></a>
<a class="sourceLine" id="cb118-2" data-line-number="2"><span class="co"># distribution of OCSKGMlog, note that we are using the mtry </span></a>
<a class="sourceLine" id="cb118-3" data-line-number="3"><span class="co"># parameter that was selected by the train function of the caret </span></a>
<a class="sourceLine" id="cb118-4" data-line-number="4"><span class="co"># package, assuming that the 75% of data previously used well </span></a>
<a class="sourceLine" id="cb118-5" data-line-number="5"><span class="co"># resembles the statistical distribution of the entire data </span></a>
<a class="sourceLine" id="cb118-6" data-line-number="6"><span class="co"># population. Otherwise, repeat the train function with all available </span></a>
<a class="sourceLine" id="cb118-7" data-line-number="7"><span class="co"># data (using the object dat that instead of train) to select mtry.</span></a>
<a class="sourceLine" id="cb118-8" data-line-number="8"></a>
<a class="sourceLine" id="cb118-9" data-line-number="9"></a>
<a class="sourceLine" id="cb118-10" data-line-number="10">model &lt;-<span class="st"> </span><span class="kw">quantregForest</span>(<span class="dt">y=</span>dat<span class="op">$</span>OCSKGMlog, <span class="dt">x=</span>dat[,<span class="dv">1</span><span class="op">:</span><span class="dv">13</span>], <span class="dt">ntree=</span><span class="dv">500</span>, </a>
<a class="sourceLine" id="cb118-11" data-line-number="11">                   <span class="dt">keep.inbag=</span><span class="ot">TRUE</span>, <span class="dt">mtry =</span> <span class="kw">as.numeric</span>(mod<span class="op">$</span>bestTune))                        </a></code></pre></div>
<p>This method will calculate a probability distribution function for each pixel and therefore can be time-consuming. Therefore we will run it using parallel computing. Note that the code to run in parallel this analysis can also be passed to the previous predictions (predict function). The result will be a map of the standard deviation of the distribution calculated for each pixel, which represents the extreme values that a prediction can take for a specific site (e.g., pixel) given available data and predictors. Note that this analysis is performed using all available data and a second map of OCSKGM is created. Our final prediction uses all available data, while the total uncertainty (in percent) is represented by the sum of the quantile regression forest standard deviation and the sensitivity map from the previous section. The total uncertainty is then divided by the prediction to obtain a percent map, which is easier to interpret.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb119-1" data-line-number="1"><span class="kw">library</span>(snow)</a>
<a class="sourceLine" id="cb119-2" data-line-number="2"><span class="co"># Estimate model uncertainty at the pixel level using parallel </span></a>
<a class="sourceLine" id="cb119-3" data-line-number="3"><span class="co"># computing</span></a>
<a class="sourceLine" id="cb119-4" data-line-number="4"><span class="kw">beginCluster</span>() <span class="co">#define number of cores to use</span></a>
<a class="sourceLine" id="cb119-5" data-line-number="5"><span class="co"># Estimate model uncertainty</span></a>
<a class="sourceLine" id="cb119-6" data-line-number="6">unc &lt;-<span class="st"> </span><span class="kw">clusterR</span>(covariates, predict, <span class="dt">args=</span><span class="kw">list</span>(<span class="dt">model=</span>model,<span class="dt">what=</span>sd))</a>
<a class="sourceLine" id="cb119-7" data-line-number="7"><span class="co"># OCSKGMlog prediction based in all available data</span></a>
<a class="sourceLine" id="cb119-8" data-line-number="8">mean &lt;-<span class="st"> </span><span class="kw">clusterR</span>(covariates, predict, </a>
<a class="sourceLine" id="cb119-9" data-line-number="9">                 <span class="dt">args=</span><span class="kw">list</span>(<span class="dt">model=</span>model, <span class="dt">what=</span>mean))</a>
<a class="sourceLine" id="cb119-10" data-line-number="10"><span class="co"># The total uncertainty is the sum of sensitivity and model </span></a>
<a class="sourceLine" id="cb119-11" data-line-number="11"><span class="co"># uncertainty</span></a>
<a class="sourceLine" id="cb119-12" data-line-number="12">unc &lt;-<span class="st"> </span>unc <span class="op">+</span><span class="st"> </span>sensitivity</a>
<a class="sourceLine" id="cb119-13" data-line-number="13"><span class="co"># Express the uncertainty in percent (divide by the mean)</span></a>
<a class="sourceLine" id="cb119-14" data-line-number="14">Total_unc_Percent &lt;-<span class="st"> </span><span class="kw">exp</span>(unc)<span class="op">/</span><span class="kw">exp</span>(mean)</a>
<a class="sourceLine" id="cb119-15" data-line-number="15"><span class="kw">endCluster</span>()</a></code></pre></div>
<div class="sourceCode" id="cb120"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb120-1" data-line-number="1"><span class="co"># Plot both maps (the predicted OCSKGM + its associated uncertainty)</span></a>
<a class="sourceLine" id="cb120-2" data-line-number="2"><span class="kw">plot</span>(<span class="kw">exp</span>(mean), <span class="dt">main=</span><span class="st">&#39;OCSKGM based in all data&#39;</span>, </a>
<a class="sourceLine" id="cb120-3" data-line-number="3">     <span class="dt">col=</span><span class="kw">rev</span>(<span class="kw">topo.colors</span>(<span class="dv">10</span>)))</a></code></pre></div>
<div class="sourceCode" id="cb121"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb121-1" data-line-number="1"><span class="kw">plot</span>(Total_unc_Percent, <span class="dt">col=</span><span class="kw">rev</span>(<span class="kw">heat.colors</span>(<span class="dv">100</span>)), <span class="dt">zlim=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">5</span>), </a>
<a class="sourceLine" id="cb121-2" data-line-number="2">     <span class="dt">main=</span><span class="st">&#39;Total uncertainty&#39;</span>)</a></code></pre></div>
<p>Finally, the predicted OCSKGM and the total uncertainty can be saved in the working directory in a generic (*.tif) raster format.</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb122-1" data-line-number="1"><span class="co">#Save the resulting maps in separated *.tif files</span></a>
<a class="sourceLine" id="cb122-2" data-line-number="2"><span class="kw">writeRaster</span>(<span class="kw">exp</span>(mean), <span class="dt">file=</span><span class="st">&#39;rfOCSKGMprediction.tif&#39;</span>, </a>
<a class="sourceLine" id="cb122-3" data-line-number="3">            <span class="dt">overwrite=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb122-4" data-line-number="4"><span class="kw">writeRaster</span>(Total_unc_Percent, <span class="dt">file=</span><span class="st">&#39;rfOCSKGMtotalUncertPercent.tif&#39;</span>,</a>
<a class="sourceLine" id="cb122-5" data-line-number="5">            <span class="dt">overwrite=</span><span class="ot">TRUE</span>)</a></code></pre></div>
<p>We have created two maps in the working directory, one represents the predicted OCSKGM and the second one its uncertainty, which is the sum of the model sensitivity to data variations and the full conditional distribution of the response variable as a function of available prediction factors. The following chapters of this book will show you how to prepare a stock report based on this soil carbon digital soil maps.</p>


</div>
</div>
</div>
<div id="svm" class="section level2">
<h2><span class="header-section-number">6.4</span> Data mining: Support Vector Machines</h2>
<p><em>GF Olmedo &amp; M Guevara</em></p>
<div id="overview-3" class="section level3">
<h3><span class="header-section-number">6.4.1</span> Overview</h3>
<p>Support vector machines (svm) is a kernel-based machine learning technique suitable for mapping SOC. svm use decision surfaces (defined by a kernel function) to map non-linear relationships across a high-dimension induced feature space (Cortes and Vapnik 1995, Machine Learning,20, 273-297). svm is widely used to perform classification and regression analysis on digital soil mapping. According to <span class="citation">Pedregosa et al. (<a href="#ref-scikit">2011</a>)</span> the advantages of svm are:</p>
<ul>
<li>Effective in high dimensional spaces.</li>
<li>Still effective in cases where the number of dimensions is greater than the number of samples.</li>
<li>Uses a subset of training points in the decision function (called support vectors), so it is also memory efficient.</li>
<li>Versatile: different Kernel functions can be specified for the decision function. Common kernels are provided, but it is also possible to specify custom kernels.</li>
</ul>
<p>And the disadvantages of svm include:</p>
<ul>
<li>If the number of features is much greater than the number of samples, avoid over-fitting in choosing Kernel functions and regularization term is crucial.</li>
<li>svm do not directly provide probability estimates, these are calculated using an expensive five-fold cross-validation.</li>
</ul>
<p>In digital soil mapping, the problems usually involve working in high dimensional spaces (were the dimensions are the covariates) with a limited number of samples. svm is a technique mostly used in classification problems, but it can be used to solve regression problems, such as modeling the continuous variability of SOC using environmental covariates. When svm is used to solve regression problem is called support vector regression.</p>
<p>Support vector regression applies a simple linear method to the data but in a high-dimensional feature space non-linearly related to the input space. It creates n hyperplanes through the n-dimensional spectral-space and each hyperplanes separates numerical data based on a kernel function (e.g., Gaussian). svm uses parameters such as gamma, cost and epsilon. These parameters are used to define the shape of the hyperplane, including the margin from the closest point to the hyperplane that divides data with the largest possible margin and defines the tolerance to errors on each single training. Linear models are fitted to the support vectors and used for prediction purposes. The support vectors are the points which fall within each hyperplane <span class="citation">(Guevara et al. <a href="#ref-soil-2017-40">2018</a>)</span>.</p>
<p>In the example below, we will use the implementation of svm in the R package <code>e1071</code> <span class="citation">(Meyer et al. <a href="#ref-e1071">2017</a>)</span>. The package e1071 offers an interface to the award-winning C++ implementation by Chih-Chung Chang and Chih-Jen Lin, libsvm (current version: 2.6). For further implementation details on libsvm, see <span class="citation">Chang and Lin (<a href="#ref-chang2001libsvm">2001</a>)</span>.</p>
<p>svm is a broad research area and for a better understanding of the mathematical background we can recommend the following books: <span class="citation">Vapnik (<a href="#ref-vapnik2013nature">2013</a>)</span>, <span class="citation">Friedman, Hastie, and Tibshirani (<a href="#ref-friedman2001elements">2001</a>)</span>, and <span class="citation">James et al. (<a href="#ref-james2013introduction">2013</a>)</span>.</p>
</div>
<div id="technical-steps---fitting-an-svm-model-to-predict-the-soc" class="section level3">
<h3><span class="header-section-number">6.4.2</span> Technical Steps - Fitting an SVM Model to Predict the SOC</h3>
<div id="setting-working-space-and-initial-steps-1" class="section level4">
<h4><span class="header-section-number">6.4.2.1</span> Setting Working Space and Initial Steps</h4>
<p>One of the first steps should be setting our working directory. If you read/write files from/ to disk, this takes place in the working directory. If we don’t set the working directory we could easily write files to an undesirable file location. The following example shows how to set the working directory in R to our folder which contains data for the study area (point data, covariates).</p>
<p>Note that we must use the forward slash / or double backslash \\ in R! Single backslash \ will not work. Now we can check if the working directory has been correctly set by using the function:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb123-1" data-line-number="1"><span class="kw">getwd</span>()</a></code></pre></div>
</div>
<div id="data-preparation-3" class="section level4">
<h4><span class="header-section-number">6.4.2.2</span> Data Preparation</h4>
<p><strong>Point Dataset</strong></p>
<p>We previously applied spline function to produce continuous soil information to a given soil depth (0-30 cm) in the section <a href="preparation.html#EqualAreaSplines">3.4.1</a>. Spline function basically imports soil profile data (including instances where layers are not contiguous), fits it to a mass-preserving spline and outputs attribute means for a given depth. The output file should contain profile id, upper (surface) and lower depth (30cm), estimated value for the selected soil attribute (Value) and tmse (estimated mean squared error of the spline). If you used the Spline Tool V2, the coordinates were not kept in the output file. The coordinates should be added back in the data table. You can use Profile IDs to add the X, Y columns back. Once your point dataset is ready, copy this table into your working directory as a .csv file.</p>
<p><strong>Environmental Predictors (Covariates)</strong></p>
<p>In the Chapter <a href="covariates.html#covariates">5</a>, we presented and prepared several global and continental datasets. In addition to these datasets, numerous covariate layers have been prepared by ISRIC for the GSOC Map project. These are GIS raster layers of various biophysical earth surface properties for each country in the world. Some of these layers will be used as predictors in this section. Please download the covariates for your own study area from GSOCMap Data Repository as explained in Section <a href="covariates.html#GSOCDataRepo">5.6</a>.</p>
<p>In section <a href="covariates.html#overlay-soil-covariates">5.9</a>, a table with the points values after data preparation and the values of our spatial predictors was prepared. This step involves loading this table.</p>
<p>Now we will import our point dataset using <code>read.csv()</code> function. The easiest way to create a data frame is to read in data from a file—this is done using the function read.csv, which works with comma delimited files. Data can be read in from other file formats as well, using different functions, but read.csv is the most commonly used approach. R is very flexible in how it reads in data from text files (<code>read.table</code>, <code>read.csv</code>, <code>read.csv2</code>, <code>read.delim</code>, <code>read.delim2</code>). Please type <code>?read.table()</code> for help.</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb124-1" data-line-number="1"><span class="co"># load data</span></a>
<a class="sourceLine" id="cb124-2" data-line-number="2">dat &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/MKD_RegMatrix.csv&quot;</span>)</a>
<a class="sourceLine" id="cb124-3" data-line-number="3"></a>
<a class="sourceLine" id="cb124-4" data-line-number="4">dat<span class="op">$</span>LCEE10 &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat<span class="op">$</span>LCEE10)</a>
<a class="sourceLine" id="cb124-5" data-line-number="5">dat<span class="op">$</span>soilmap &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat<span class="op">$</span>soilmap)</a>
<a class="sourceLine" id="cb124-6" data-line-number="6"></a>
<a class="sourceLine" id="cb124-7" data-line-number="7"><span class="co"># explore the data structure</span></a>
<a class="sourceLine" id="cb124-8" data-line-number="8"><span class="kw">str</span>(dat)</a></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    2897 obs. of  23 variables:
##  $ id       : Factor w/ 2897 levels &quot;P0003&quot;,&quot;P0007&quot;,..: 1 2 3 4..
##  $ Y        : num  42 42 42.1 42 42 ...
##  $ X        : num  20.8 20.8 20.8 20.9 20.9 ...
##  $ SOC      : num  26.38 6.15 3.94 3.26 2.29 ...
##  $ BLD      : num  0.73 1.17 1.3 1.34 1.41 ...
##  $ CRFVOL   : num  8 18.6 31.9 21.7 14.5 ...
##  $ OCSKGM   : num  5.32 1.75 1.04 1.03 0.83 ...
##  $ meaERROR : num  2.16 2.85 2.65 3.16 3.63 2.83 2.94 2.49 2.77..
##  $ OCSKGMlog: num  1.6712 0.5591 0.0429 0.0286 -0.1862 ...
##  $ B04CHE3  : num  574 553 693 743 744 ...
##  $ B07CHE3  : num  38.5 37.8 42.1 43.7 43.7 ...
##  $ B13CHE3  : num  111.6 125 99.8 118.1 121 ...
##  $ B14CHE3  : num  59.2 60.3 42.4 39.9 38.7 ...
##  $ DEMENV5  : int  2327 2207 1243 1120 1098 1492 1413 1809 1731..
##  $ LCEE10   : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 3 2 1 2 2 2..
##  $ PRSCHE3  : num  998 1053 780 839 844 ...
##  $ SLPMRG5  : int  13 36 6 25 30 24 15 17 20 43 ...
##  $ TMDMOD3  : int  282 280 285 288 289 287 286 286 287 286 ...
##  $ TMNMOD3  : int  272 270 277 279 279 277 277 273 274 273 ...
##  $ TWIMRG5  : int  61 62 81 66 65 72 68 67 65 59 ...
##  $ VBFMRG5  : int  0 0 14 0 0 0 0 0 0 0 ...
##  $ VDPMRG5  : int  311 823 10048 1963 -173 -400 -9 -692 -1139 2..
##  $ soilmap  : Factor w/ 20 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 6 14 14 3..</code></pre>
<p>Since we will be working with spatial data we need to define the coordinates for the imported data. Using the coordinates() function from the sp package we can define the columns in the data frame to refer to spatial coordinates—here the coordinates are listed in columns X and Y.</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb126-1" data-line-number="1"><span class="kw">library</span>(sp)</a>
<a class="sourceLine" id="cb126-2" data-line-number="2"></a>
<a class="sourceLine" id="cb126-3" data-line-number="3"><span class="co"># Promote to spatialPointsDataFrame</span></a>
<a class="sourceLine" id="cb126-4" data-line-number="4"><span class="kw">coordinates</span>(dat) &lt;-<span class="st"> </span><span class="er">~</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>Y</a>
<a class="sourceLine" id="cb126-5" data-line-number="5"></a>
<a class="sourceLine" id="cb126-6" data-line-number="6"><span class="kw">class</span>(dat)</a></code></pre></div>
<pre><code>## [1] &quot;SpatialPointsDataFrame&quot;
## attr(,&quot;package&quot;)
## [1] &quot;sp&quot;</code></pre>
<p>SpatialPointsDataFrame structure is essentially the same data frame, except that additional “spatial” elements have been added or partitioned into slots. Some important ones being the bounding box (sort of like the spatial extent of the data), and the coordinate reference system proj4string(), which we need to define for the sample dataset. To define the CRS, we must know where our data are from, and what was the corresponding CRS used when recording the spatial information in the field. For this data set, the CRS used was: WGS84 (EPSG:4326).</p>
<p>To clearly tell R this information we define the CRS which describes a reference system in a way understood by the <a href="http://trac.osgeo.org/proj/">PROJ.4 projection library</a>. An interface to the PROJ.4 library is available in the rgdal package. As an alternative to using Proj4 character strings, we can use the corresponding yet simpler EPSG code (European Petroleum Survey Group). rgdal also recognizes these codes. If you are unsure of the Proj4 or EPSG code for the spatial data that you have but know the CRS, you should consult <a href="http://spatialreference.org/" class="uri">http://spatialreference.org/</a> for assistance.</p>
<p>Please also note that, when working with spatial data, it’s very important that the CRS (coordinate reference system) of the point data and covariates are the same.</p>
<p>Now, we will define our CRS:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb128-1" data-line-number="1">dat<span class="op">@</span>proj4string &lt;-<span class="st"> </span><span class="kw">CRS</span>(<span class="dt">projargs =</span> <span class="st">&quot;+init=epsg:4326&quot;</span>)</a>
<a class="sourceLine" id="cb128-2" data-line-number="2"></a>
<a class="sourceLine" id="cb128-3" data-line-number="3">dat<span class="op">@</span>proj4string</a></code></pre></div>
<pre><code>## CRS arguments:
##  +init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs
## +ellps=WGS84 +towgs84=0,0,0</code></pre>
<p>Now we will import the covariates. When the covariate layers are in common resolution and extent, rather than working with individual rasters it is better to stack them all into a single R object. In this example, we use 13 covariates from the GSOCMap Data Repository and a rasterized version of the soil type map. The rasterization of vectorial data was covered in <a href="covariates.html#technical-steps---rasterizing-a-vector-layer-in-r">Technical Steps - Rasterizing a vector layer in R</a>. The file containing all the covariates was prepared at the end of chapter <a href="covariates.html#covariates">5</a>.</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb130-1" data-line-number="1"><span class="kw">load</span>(<span class="dt">file =</span> <span class="st">&quot;covariates.RData&quot;</span>)</a>
<a class="sourceLine" id="cb130-2" data-line-number="2"></a>
<a class="sourceLine" id="cb130-3" data-line-number="3"><span class="kw">names</span>(covs)</a></code></pre></div>
<pre><code>##  [1] &quot;B04CHE3&quot; &quot;B07CHE3&quot; &quot;B13CHE3&quot; &quot;B14CHE3&quot; &quot;DEMENV5&quot; &quot;LCEE10&quot; 
##  [7] &quot;PRSCHE3&quot; &quot;SLPMRG5&quot; &quot;TMDMOD3&quot; &quot;TMNMOD3&quot; &quot;TWIMRG5&quot; &quot;VBFMRG5&quot;
## [13] &quot;VDPMRG5&quot; &quot;soilmap&quot;</code></pre>
</div>
<div id="variable-selection-using-correlation-analysis" class="section level4">
<h4><span class="header-section-number">6.4.2.3</span> Variable selection using correlation analysis</h4>
<div class="sourceCode" id="cb132"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb132-1" data-line-number="1"><span class="co"># plot the names of the covariates</span></a>
<a class="sourceLine" id="cb132-2" data-line-number="2"><span class="kw">names</span>(dat<span class="op">@</span>data)</a></code></pre></div>
<pre><code>##  [1] &quot;id&quot;        &quot;SOC&quot;       &quot;BLD&quot;       &quot;CRFVOL&quot;    &quot;OCSKGM&quot;   
##  [6] &quot;meaERROR&quot;  &quot;OCSKGMlog&quot; &quot;B04CHE3&quot;   &quot;B07CHE3&quot;   &quot;B13CHE3&quot;  
## [11] &quot;B14CHE3&quot;   &quot;DEMENV5&quot;   &quot;LCEE10&quot;    &quot;PRSCHE3&quot;   &quot;SLPMRG5&quot;  
## [16] &quot;TMDMOD3&quot;   &quot;TMNMOD3&quot;   &quot;TWIMRG5&quot;   &quot;VBFMRG5&quot;   &quot;VDPMRG5&quot;  
## [21] &quot;soilmap&quot;</code></pre>
<p>For the variable selection we will use <code>cor()</code> function. <code>x</code> must be a table including only the column with the response variable, and <code>y</code> must be a table including ONLY the covariates. Besides, remember <code>dat@data</code> in the <code>data.frame</code> included in the <code>spatialPointsDataFrame</code>. For <code>y</code>, columns 1 to 7 are out, because they are not covariates. At the same time, correlation analysis cannot be applied to categorical covariates, this means that columns 13 and 21 have to be removed too.</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb134-1" data-line-number="1">selectedCovs &lt;-<span class="st"> </span><span class="kw">cor</span>(<span class="dt">x =</span> <span class="kw">as.matrix</span>(dat<span class="op">@</span>data[,<span class="dv">5</span>]),</a>
<a class="sourceLine" id="cb134-2" data-line-number="2">           <span class="dt">y =</span> <span class="kw">as.matrix</span>(dat<span class="op">@</span>data[,<span class="op">-</span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">7</span>,<span class="dv">13</span>,<span class="dv">21</span>)]))</a>
<a class="sourceLine" id="cb134-3" data-line-number="3"></a>
<a class="sourceLine" id="cb134-4" data-line-number="4"><span class="co"># print correlation results</span></a>
<a class="sourceLine" id="cb134-5" data-line-number="5">selectedCovs</a></code></pre></div>
<pre><code>##         B04CHE3    B07CHE3  B13CHE3   B14CHE3   DEMENV5
## [1,] -0.4199537 -0.3926615 0.330696 0.3481847 0.3926275
##        PRSCHE3   SLPMRG5    TMDMOD3    TMNMOD3    TWIMRG5
## [1,] 0.3948779 0.2593964 -0.4077552 -0.2963631 -0.2525764
##         VBFMRG5    VDPMRG5
## [1,] -0.1156285 -0.3001934</code></pre>
<p>Now we used the correlation results to select the top five covariates.</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb136-1" data-line-number="1"><span class="kw">library</span>(reshape)</a>
<a class="sourceLine" id="cb136-2" data-line-number="2">x &lt;-<span class="st"> </span><span class="kw">subset</span>(<span class="kw">melt</span>(selectedCovs), value <span class="op">!=</span><span class="st"> </span><span class="dv">1</span> <span class="op">|</span><span class="st"> </span>value <span class="op">!=</span><span class="st"> </span><span class="ot">NA</span>)</a>
<a class="sourceLine" id="cb136-3" data-line-number="3">x &lt;-<span class="st"> </span>x[<span class="kw">with</span>(x, <span class="kw">order</span>(<span class="op">-</span><span class="kw">abs</span>(x<span class="op">$</span>value))),]</a>
<a class="sourceLine" id="cb136-4" data-line-number="4"></a>
<a class="sourceLine" id="cb136-5" data-line-number="5">idx &lt;-<span class="st"> </span><span class="kw">as.character</span>(x<span class="op">$</span>X2[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>])</a>
<a class="sourceLine" id="cb136-6" data-line-number="6"></a>
<a class="sourceLine" id="cb136-7" data-line-number="7">dat2 &lt;-<span class="st"> </span>dat[<span class="kw">c</span>(<span class="st">&#39;OCSKGM&#39;</span>, idx)]</a>
<a class="sourceLine" id="cb136-8" data-line-number="8"><span class="kw">names</span>(dat2)</a></code></pre></div>
<pre><code>## [1] &quot;OCSKGM&quot;  &quot;B04CHE3&quot; &quot;TMDMOD3&quot; &quot;PRSCHE3&quot; &quot;B07CHE3&quot; &quot;DEMENV5&quot;</code></pre>
<div class="sourceCode" id="cb138"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb138-1" data-line-number="1">COV &lt;-<span class="st"> </span>covs[[idx]]</a>
<a class="sourceLine" id="cb138-2" data-line-number="2"></a>
<a class="sourceLine" id="cb138-3" data-line-number="3"><span class="co"># Selected covariates</span></a>
<a class="sourceLine" id="cb138-4" data-line-number="4"><span class="kw">names</span>(COV)</a></code></pre></div>
<pre><code>## [1] &quot;B04CHE3&quot; &quot;TMDMOD3&quot; &quot;PRSCHE3&quot; &quot;B07CHE3&quot; &quot;DEMENV5&quot;</code></pre>
</div>
<div id="categorical-variables-in-svm-models" class="section level4">
<h4><span class="header-section-number">6.4.2.4</span> Categorical variables in svm models</h4>
<p>According to <span class="citation">Hsu et al. (<a href="#ref-hsu2003practical">2003</a>)</span>, svm requires each variable to be represented by a vector of real numbers. This means that factor variables, like <code>covs$LCEE10</code> and <code>covs$soilmap</code>has to be converted into numeric data. In statistics, this kind of variables are called boolean indicators or dummy variables. Dummy variables take a value of 0 or 1 indicating the presence or absence of a specific value/category in our factor covariate, i.e. if we have 5 categories like in <code>covs$LCEE10</code>, we will have 5 dummy variables indicating the presence/absence of every category. For converting our covariates to dummies we will have to create a new function that returns the dummy rasterStack from the factor version of the rasterLayer.</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb140-1" data-line-number="1">dummyRaster &lt;-<span class="st"> </span><span class="cf">function</span>(rast){</a>
<a class="sourceLine" id="cb140-2" data-line-number="2">  rast &lt;-<span class="st"> </span><span class="kw">as.factor</span>(rast)</a>
<a class="sourceLine" id="cb140-3" data-line-number="3">  result &lt;-<span class="st"> </span><span class="kw">list</span>()</a>
<a class="sourceLine" id="cb140-4" data-line-number="4">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(<span class="kw">levels</span>(rast)[[<span class="dv">1</span>]][[<span class="dv">1</span>]])){</a>
<a class="sourceLine" id="cb140-5" data-line-number="5">    result[[i]] &lt;-<span class="st"> </span>rast <span class="op">==</span><span class="st"> </span><span class="kw">levels</span>(rast)[[<span class="dv">1</span>]][[<span class="dv">1</span>]][i]</a>
<a class="sourceLine" id="cb140-6" data-line-number="6">    <span class="kw">names</span>(result[[i]]) &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="kw">names</span>(rast), </a>
<a class="sourceLine" id="cb140-7" data-line-number="7">                                 <span class="kw">levels</span>(rast)[[<span class="dv">1</span>]][[<span class="dv">1</span>]][i])</a>
<a class="sourceLine" id="cb140-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb140-9" data-line-number="9">  <span class="kw">return</span>(<span class="kw">stack</span>(result))</a>
<a class="sourceLine" id="cb140-10" data-line-number="10">}</a></code></pre></div>
<p>We can use the function we just created to convert our categorical covariates to dummies and then stack all the layers together.</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb141-1" data-line-number="1"><span class="co"># convert soilmap from factor to dummy</span></a>
<a class="sourceLine" id="cb141-2" data-line-number="2">soilmap_dummy &lt;-<span class="st"> </span><span class="kw">dummyRaster</span>(covs<span class="op">$</span>soilmap)</a>
<a class="sourceLine" id="cb141-3" data-line-number="3"></a>
<a class="sourceLine" id="cb141-4" data-line-number="4"><span class="co"># convert LCEE10 from factor to dummy</span></a>
<a class="sourceLine" id="cb141-5" data-line-number="5">LCEE10_dummy &lt;-<span class="st"> </span><span class="kw">dummyRaster</span>(covs<span class="op">$</span>LCEE10)</a>
<a class="sourceLine" id="cb141-6" data-line-number="6"></a>
<a class="sourceLine" id="cb141-7" data-line-number="7"><span class="co"># Stack the 5 COV layers with the 2 dummies</span></a>
<a class="sourceLine" id="cb141-8" data-line-number="8">COV &lt;-<span class="st"> </span><span class="kw">stack</span>(COV, soilmap_dummy, LCEE10_dummy)</a>
<a class="sourceLine" id="cb141-9" data-line-number="9"></a>
<a class="sourceLine" id="cb141-10" data-line-number="10"><span class="co"># print the final layer names</span></a>
<a class="sourceLine" id="cb141-11" data-line-number="11"><span class="kw">names</span>(COV)</a></code></pre></div>
<pre><code>##  [1] &quot;B04CHE3&quot;   &quot;TMDMOD3&quot;   &quot;PRSCHE3&quot;   &quot;B07CHE3&quot;   &quot;DEMENV5&quot;  
##  [6] &quot;soilmap1&quot;  &quot;soilmap2&quot;  &quot;soilmap3&quot;  &quot;soilmap4&quot;  &quot;soilmap5&quot; 
## [11] &quot;soilmap6&quot;  &quot;soilmap7&quot;  &quot;soilmap8&quot;  &quot;soilmap9&quot;  &quot;soilmap10&quot;
## [16] &quot;soilmap11&quot; &quot;soilmap12&quot; &quot;soilmap13&quot; &quot;soilmap14&quot; &quot;soilmap15&quot;
## [21] &quot;soilmap16&quot; &quot;soilmap17&quot; &quot;soilmap18&quot; &quot;soilmap19&quot; &quot;soilmap20&quot;
## [26] &quot;LCEE101&quot;   &quot;LCEE102&quot;   &quot;LCEE103&quot;   &quot;LCEE104&quot;</code></pre>
<p>We have to convert the columns with categorical variables in the soil samples <code>data.frame</code> to dummies as well. For doing this we can use function <code>model.matrix()</code>. After this, we use <code>cbind()</code> to merge the resulting <code>data.frame</code>.</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb143-1" data-line-number="1"><span class="co"># convert soilmap column to dummy, the result is a matrix</span></a>
<a class="sourceLine" id="cb143-2" data-line-number="2"><span class="co"># to have one column per category we had to add -1 to the formula</span></a>
<a class="sourceLine" id="cb143-3" data-line-number="3">dat_soilmap_dummy &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span>soilmap <span class="dv">-1</span>, <span class="dt">data =</span> dat<span class="op">@</span>data)</a>
<a class="sourceLine" id="cb143-4" data-line-number="4"><span class="co"># convert the matrix to a data.frame</span></a>
<a class="sourceLine" id="cb143-5" data-line-number="5">dat_soilmap_dummy &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(dat_soilmap_dummy)</a>
<a class="sourceLine" id="cb143-6" data-line-number="6"></a>
<a class="sourceLine" id="cb143-7" data-line-number="7"></a>
<a class="sourceLine" id="cb143-8" data-line-number="8"><span class="co"># convert LCEE10 column to dummy, the result is a matrix</span></a>
<a class="sourceLine" id="cb143-9" data-line-number="9"><span class="co"># to have one column per category we had to add -1 to the formula</span></a>
<a class="sourceLine" id="cb143-10" data-line-number="10">dat_LCEE10_dummy &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span>LCEE10 <span class="dv">-1</span>, <span class="dt">data =</span> dat<span class="op">@</span>data)</a>
<a class="sourceLine" id="cb143-11" data-line-number="11"><span class="co"># convert the matrix to a data.frame</span></a>
<a class="sourceLine" id="cb143-12" data-line-number="12">dat_LCEE10_dummy &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(dat_LCEE10_dummy)</a>
<a class="sourceLine" id="cb143-13" data-line-number="13"></a>
<a class="sourceLine" id="cb143-14" data-line-number="14">dat<span class="op">@</span>data &lt;-<span class="st"> </span><span class="kw">cbind</span>(dat<span class="op">@</span>data, dat_LCEE10_dummy, dat_soilmap_dummy)</a>
<a class="sourceLine" id="cb143-15" data-line-number="15"></a>
<a class="sourceLine" id="cb143-16" data-line-number="16"><span class="kw">names</span>(dat<span class="op">@</span>data)</a></code></pre></div>
<pre><code>##  [1] &quot;id&quot;        &quot;SOC&quot;       &quot;BLD&quot;       &quot;CRFVOL&quot;    &quot;OCSKGM&quot;   
##  [6] &quot;meaERROR&quot;  &quot;OCSKGMlog&quot; &quot;B04CHE3&quot;   &quot;B07CHE3&quot;   &quot;B13CHE3&quot;  
## [11] &quot;B14CHE3&quot;   &quot;DEMENV5&quot;   &quot;LCEE10&quot;    &quot;PRSCHE3&quot;   &quot;SLPMRG5&quot;  
## [16] &quot;TMDMOD3&quot;   &quot;TMNMOD3&quot;   &quot;TWIMRG5&quot;   &quot;VBFMRG5&quot;   &quot;VDPMRG5&quot;  
## [21] &quot;soilmap&quot;   &quot;LCEE101&quot;   &quot;LCEE102&quot;   &quot;LCEE103&quot;   &quot;LCEE104&quot;  
## [26] &quot;soilmap1&quot;  &quot;soilmap2&quot;  &quot;soilmap3&quot;  &quot;soilmap4&quot;  &quot;soilmap5&quot; 
## [31] &quot;soilmap6&quot;  &quot;soilmap7&quot;  &quot;soilmap8&quot;  &quot;soilmap9&quot;  &quot;soilmap10&quot;
## [36] &quot;soilmap11&quot; &quot;soilmap12&quot; &quot;soilmap13&quot; &quot;soilmap14&quot; &quot;soilmap15&quot;
## [41] &quot;soilmap16&quot; &quot;soilmap17&quot; &quot;soilmap18&quot; &quot;soilmap19&quot; &quot;soilmap20&quot;</code></pre>
</div>
<div id="fitting-a-svm-model" class="section level4">
<h4><span class="header-section-number">6.4.2.5</span> Fitting a svm model</h4>
<p>To improve the model performance the parameters of the svm can be tuned. In this example, we will show how to tune 2 parameters using a grid search for hyperparameter optimization using the function <code>tune()</code>. The first parameter is epsilon which is the insensitive-loss function (The larger epsilon is, the larger errors in the solution are not penalized). The default value for epsilon is 0.1, and we will try 11 different value from 0.05 to 0.12 in 0.1 increments. the second parameter is the cost which is the cost of constraints violation – it is the ‘C’-constant of the regularization term in the Lagrange formulation. The default value for this parameter is 1, and we will try values from 1 to 20 in 5 increments. The value of cost helps us to avoid overfitting. This is a heavy and time consuming computational step since we will try a extensive number of different models in order to find the best parameters for our svm model.</p>
<pre><code>## 
## Attaching package: &#39;e1071&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:raster&#39;:
## 
##     interpolate</code></pre>
<div class="sourceCode" id="cb147"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb147-1" data-line-number="1"><span class="kw">library</span>(e1071)</a>
<a class="sourceLine" id="cb147-2" data-line-number="2"><span class="kw">library</span>(caret)</a>
<a class="sourceLine" id="cb147-3" data-line-number="3"></a>
<a class="sourceLine" id="cb147-4" data-line-number="4"><span class="co">#  Test different values of epsilon and cost</span></a>
<a class="sourceLine" id="cb147-5" data-line-number="5">  tuneResult &lt;-<span class="st"> </span><span class="kw">tune</span>(svm, OCSKGM <span class="op">~</span>.,  <span class="dt">data =</span> dat<span class="op">@</span>data[,<span class="kw">c</span>(<span class="st">&quot;OCSKGM&quot;</span>,</a>
<a class="sourceLine" id="cb147-6" data-line-number="6">                                                         <span class="kw">names</span>(COV))],</a>
<a class="sourceLine" id="cb147-7" data-line-number="7">                     <span class="dt">ranges =</span> <span class="kw">list</span>(<span class="dt">epsilon =</span> <span class="kw">seq</span>(<span class="fl">0.1</span>,<span class="fl">0.2</span>,<span class="fl">0.02</span>),</a>
<a class="sourceLine" id="cb147-8" data-line-number="8">                                   <span class="dt">cost =</span> <span class="kw">c</span>(<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">15</span>,<span class="dv">20</span>)))</a></code></pre></div>
<p>We can plot the performance of the different models. When the region is darker, the RMSE is closer to zero.</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb148-1" data-line-number="1"><span class="kw">plot</span>(tuneResult)</a></code></pre></div>
<div class="figure"><span id="fig:unnamed-chunk-80"></span>
<img src="SOCMapping_files/figure-html4/unnamed-chunk-80-1.png" alt="Performance of the different svm models in the parameter tuning procedure" width="672" />
<p class="caption">
Figure 6.15: Performance of the different svm models in the parameter tuning procedure
</p>
</div>
</div>
<div id="select-the-model-with-the-best-combination-of-epsilon-and-cost" class="section level4">
<h4><span class="header-section-number">6.4.2.6</span> Select the model with the best combination of epsilon and cost</h4>
<p>The best model is the one with the lowest mean squared error derived by cross-validation. The parameters for the cross-validation can be defined in the <code>tune.control()</code> function. By default, it uses cross-validation using 10 folds.</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb149-1" data-line-number="1"><span class="co"># Choose the model with the best combination of epsilon and cost</span></a>
<a class="sourceLine" id="cb149-2" data-line-number="2">tunedModel &lt;-<span class="st"> </span>tuneResult<span class="op">$</span>best.model</a>
<a class="sourceLine" id="cb149-3" data-line-number="3"></a>
<a class="sourceLine" id="cb149-4" data-line-number="4"><span class="kw">print</span>(tunedModel)</a></code></pre></div>
<pre><code>## 
## Call:
## best.tune(method = svm, train.x = OCSKGM ~ ., data = dat@data[, 
##     c(&quot;OCSKGM&quot;, names(COV))], ranges = list(epsilon = seq(0.1, 
##     0.2, 0.02), cost = c(5, 7, 15, 20)))
## 
## 
## Parameters:
##    SVM-Type:  eps-regression 
##  SVM-Kernel:  radial 
##        cost:  5 
##       gamma:  0.03448276 
##     epsilon:  0.2 
## 
## 
## Number of Support Vectors:  2193</code></pre>
</div>
<div id="predict-the-ocs-using-the-model" class="section level4">
<h4><span class="header-section-number">6.4.2.7</span> Predict the OCS using the model</h4>
<div class="sourceCode" id="cb151"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb151-1" data-line-number="1"><span class="co"># Use the model to predict the SOC in the covariates space</span></a>
<a class="sourceLine" id="cb151-2" data-line-number="2">OCSsvm &lt;-<span class="st"> </span><span class="kw">predict</span>(COV, tunedModel)</a>
<a class="sourceLine" id="cb151-3" data-line-number="3"></a>
<a class="sourceLine" id="cb151-4" data-line-number="4"><span class="co"># Save the result</span></a>
<a class="sourceLine" id="cb151-5" data-line-number="5"><span class="kw">writeRaster</span>(OCSsvm, <span class="dt">filename =</span> <span class="st">&quot;results/MKD_OCSKGM_svm.tif&quot;</span>,</a>
<a class="sourceLine" id="cb151-6" data-line-number="6">            <span class="dt">overwrite=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb151-7" data-line-number="7"></a>
<a class="sourceLine" id="cb151-8" data-line-number="8"><span class="kw">plot</span>(OCSsvm)</a></code></pre></div>
<div class="figure"><span id="fig:unnamed-chunk-82"></span>
<img src="SOCMapping_files/figure-html4/unnamed-chunk-82-1.png" alt="SOC prediction using a support vector machines model" width="672" />
<p class="caption">
Figure 6.16: SOC prediction using a support vector machines model
</p>
</div>
<p>Finally, we can evaluate the contribution of each covariate to the model <span class="citation">(Guyon and Elisseeff <a href="#ref-guyon2003introduction">2003</a>)</span>:</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb152-1" data-line-number="1"><span class="co"># Variable importance in svm. Code by:</span></a>
<a class="sourceLine" id="cb152-2" data-line-number="2"><span class="co"># stackoverflow.com/questions/34781495</span></a>
<a class="sourceLine" id="cb152-3" data-line-number="3"></a>
<a class="sourceLine" id="cb152-4" data-line-number="4">w &lt;-<span class="st"> </span><span class="kw">t</span>(tunedModel<span class="op">$</span>coefs) <span class="op">%*%</span><span class="st"> </span>tunedModel<span class="op">$</span>SV     <span class="co"># weight vectors</span></a>
<a class="sourceLine" id="cb152-5" data-line-number="5">w &lt;-<span class="st"> </span><span class="kw">apply</span>(w, <span class="dv">2</span>, <span class="cf">function</span>(v){<span class="kw">sqrt</span>(<span class="kw">sum</span>(v<span class="op">^</span><span class="dv">2</span>))})  <span class="co"># weight</span></a>
<a class="sourceLine" id="cb152-6" data-line-number="6"></a>
<a class="sourceLine" id="cb152-7" data-line-number="7">w &lt;-<span class="st"> </span><span class="kw">sort</span>(w, <span class="dt">decreasing =</span> T)</a>
<a class="sourceLine" id="cb152-8" data-line-number="8"><span class="kw">print</span>(w)</a></code></pre></div>
<pre><code>##      B04CHE3     soilmap6      TMDMOD3     soilmap7     soilmap1 
## 6.712914e+01 4.443748e+01 4.010740e+01 3.928593e+01 3.882377e+01 
##      DEMENV5      PRSCHE3      B07CHE3      LCEE103     soilmap2 
## 3.824383e+01 3.350877e+01 3.107515e+01 2.646657e+01 2.478332e+01 
##    soilmap19      LCEE104    soilmap16      LCEE101     soilmap5 
## 2.441025e+01 1.529174e+01 1.448675e+01 1.324205e+01 1.309922e+01 
##    soilmap15      LCEE102     soilmap4    soilmap20     soilmap9 
## 1.295171e+01 1.175225e+01 8.849019e+00 8.166970e+00 6.701250e+00 
##    soilmap10     soilmap3    soilmap17    soilmap12     soilmap8 
## 6.046196e+00 5.059617e+00 4.705567e+00 3.552720e+00 2.691221e+00 
##    soilmap18    soilmap14    soilmap11    soilmap13 
## 5.275093e-01 1.498048e-01 7.365523e-02 1.110223e-15</code></pre>
<p>svm is a powerful technique which represent another welcome possibility to generate reliable and interpretable SOC predictions across different scales of data availability, including country-specific SOC maps.</p>

</div>
</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-hengl2007regression">
<p>Hengl, Tomislav, Gerard BM Heuvelink, and David G Rossiter. 2007. “About Regression-Kriging: From Equations to Case Studies.” <em>Computers &amp; Geosciences</em> 33 (10). Elsevier:1301–15.</p>
</div>
<div id="ref-Breiman1996">
<p>Breiman, Leo. 1996. “Bagging Predictors.” <em>Machine Learning</em> 24 (2):123–40. <a href="https://doi.org/10.1023/A:1018054314350" class="uri">https://doi.org/10.1023/A:1018054314350</a>.</p>
</div>
<div id="ref-Karatzoglou2006">
<p>Karatzoglou, Alexandros, David Meyer, and Kurt Hornik. 2006. “Support Vector Algorithm in R.” <em>Journal of Statistical Software</em> 15 (9):1–28.</p>
</div>
<div id="ref-soil-2017-40">
<p>Guevara, M., G. F. Olmedo, E. Stell, Y. Yigini, Y. Aguilar Duarte, C. Arellano Hernández, G. E. Arévalo, et al. 2018. “No Silver Bullet for Digital Soil Mapping: Country-Specific Soil Organic Carbon Estimates Across Latin America.” <em>SOIL Discussions</em> 2018:1–20. <a href="https://doi.org/10.5194/soil-2017-40" class="uri">https://doi.org/10.5194/soil-2017-40</a>.</p>
</div>
<div id="ref-poggio2013regional">
<p>Poggio, Laura, Alessandro Gimona, and Mark J Brewer. 2013. “Regional Scale Mapping of Soil Properties and Their Uncertainty with a Large Number of Satellite-Derived Covariates.” <em>Geoderma</em> 209. Elsevier:1–14.</p>
</div>
<div id="ref-rad2014updating">
<p>Rad, Mohammad Reza Pahlavan, Norair Toomanian, Farhad Khormali, Colby W Brungard, Chooghi Bayram Komaki, and Patrick Bogaert. 2014. “Updating Soil Survey Maps Using Random Forest and Conditioned Latin Hypercube Sampling in the Loess Derived Soils of Northern Iran.” <em>Geoderma</em> 232. Elsevier:97–106.</p>
</div>
<div id="ref-wiesmeier2011digital">
<p>Wiesmeier, Martin, Frauke Barthold, Benjamin Blank, and Ingrid Kögel-Knabner. 2011. “Digital Mapping of Soil Organic Matter Stocks Using Random Forest Modeling in a Semi-Arid Steppe Ecosystem.” <em>Plant and Soil</em> 340 (1-2). Springer:7–24.</p>
</div>
<div id="ref-breiman2017cutler">
<p>Breiman, L. 2017. “Cutler’s Random Forests for Classification and Regression. 2015. R Package Version 4.6. 12.”</p>
</div>
<div id="ref-vaysse2017using">
<p>Vaysse, Kévin, and Philippe Lagacherie. 2017. “Using Quantile Regression Forest to Estimate Uncertainty of Digital Soil Mapping Products.” <em>Geoderma</em> 291. Elsevier:55–64.</p>
</div>
<div id="ref-scikit">
<p>Pedregosa, F., G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, et al. 2011. “Scikit-Learn: Machine Learning in Python.” <em>Journal of Machine Learning Research</em> 12:2825–30.</p>
</div>
<div id="ref-e1071">
<p>Meyer, David, Evgenia Dimitriadou, Kurt Hornik, Andreas Weingessel, and Friedrich Leisch. 2017. <em>E1071: Misc Functions of the Department of Statistics, Probability Theory Group (Formerly: E1071), Tu Wien</em>. <a href="https://CRAN.R-project.org/package=e1071" class="uri">https://CRAN.R-project.org/package=e1071</a>.</p>
</div>
<div id="ref-chang2001libsvm">
<p>Chang, Chih-Chung, and Chih-Jen Lin. 2001. “LIBSVM: A Library for Support Vector Machines [Eb/Ol].”</p>
</div>
<div id="ref-vapnik2013nature">
<p>Vapnik, Vladimir. 2013. <em>The Nature of Statistical Learning Theory</em>. Springer science &amp; business media.</p>
</div>
<div id="ref-friedman2001elements">
<p>Friedman, Jerome, Trevor Hastie, and Robert Tibshirani. 2001. <em>The Elements of Statistical Learning</em>. Vol. 1. Springer series in statistics New York.</p>
</div>
<div id="ref-james2013introduction">
<p>James, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2013. <em>An Introduction to Statistical Learning</em>. Vol. 112. Springer.</p>
</div>
<div id="ref-hsu2003practical">
<p>Hsu, Chih-Wei, Chih-Chung Chang, Chih-Jen Lin, and others. 2003. “A Practical Guide to Support Vector Classification.” Taipei.</p>
</div>
<div id="ref-guyon2003introduction">
<p>Guyon, Isabelle, and André Elisseeff. 2003. “An Introduction to Variable and Feature Selection.” <em>Journal of Machine Learning Research</em> 3 (Mar):1157–82.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="covariates.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="chvalidation.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/061-mapping.Rmd",
"text": "Edit"
},
"download": ["SOCMapping.pdf", "SOCMapping.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
